! function(t) {
    var e = {};

    function i(s) {
        if (e[s]) return e[s].exports;
        var n = e[s] = {
            i: s,
            l: !1,
            exports: {}
        };
        return t[s].call(n.exports, n, n.exports, i), n.l = !0, n.exports
    }
    i.m = t, i.c = e, i.d = function(t, e, s) {
        i.o(t, e) || Object.defineProperty(t, e, {
            configurable: !1,
            enumerable: !0,
            get: s
        })
    }, i.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default
        } : function() {
            return t
        };
        return i.d(e, "a", e), e
    }, i.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, i.p = "", i(i.s = 23)
}([function(t, e, i) {
    "use strict";
    var s, n, r, o, a, h;
    Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            var e = function() {
                function t() {}
                return t.getName = function() {
                    return "background_template"
                }, t.getPNG = function() {
                    return i(30)
                }, t
            }();
            t.ImagesBackgroundTemplate = e;
            var s = function() {
                function t() {}
                return t.getName = function() {
                    return "frame"
                }, t.getPNG = function() {
                    return i(31)
                }, t
            }();
            t.ImagesFrame = s;
            var n = function() {
                function t() {}
                return t.getName = function() {
                    return "preload_play_btn"
                }, t.getPNG = function() {
                    return i(32)
                }, t
            }();
            t.ImagesPreloadPlayBtn = n;
            var r = function() {
                function t() {}
                return t.getName = function() {
                    return "preload_title"
                }, t.getPNG = function() {
                    return i(33)
                }, t
            }();
            t.ImagesPreloadTitle = r;
            var o = function() {
                function t() {}
                return t.getName = function() {
                    return "rect16"
                }, t.getPNG = function() {
                    return i(34)
                }, t
            }();
            t.ImagesRect16 = o;
            var a = function() {
                function t() {}
                return t.getName = function() {
                    return "sky_gradient_01"
                }, t.getPNG = function() {
                    return i(35)
                }, t
            }();
            t.ImagesSkyGradient1 = a;
            var h = function() {
                function t() {}
                return t.getName = function() {
                    return "sky_gradient_02"
                }, t.getPNG = function() {
                    return i(36)
                }, t
            }();
            t.ImagesSkyGradient2 = h
        }(e.Images || (e.Images = {})), e.Spritesheets || (e.Spritesheets = {}), s = e.Atlases || (e.Atlases = {}), o = function() {
            function t() {}
            return t.getName = function() {
                return "main"
            }, t.getJSONHash = function() {
                return i(37)
            }, t.getPNG = function() {
                return i(38)
            }, t
        }(), s.SpritesheetsMain = o, n = o = s.SpritesheetsMain || (s.SpritesheetsMain = {}), (r = n.Frames || (n.Frames = {})).Arm = "arm.png", r.Ball = "ball.png", r.BestPrizeBanner = "best_prize_banner.png", r.Bestsign = "bestsign.png", r.Block1 = "block_1.png", r.BlockNoPattern = "block_no_pattern.png", r.BoostArrows = "boost_arrows.png", r.BoostArrowsSix = "boost_arrows_six.png", r.Box = "box.png", r.BtnBack = "btn_back.png", r.BtnBuyChar = "btn_buy_char.png", r.BtnCharSelectTitle = "btn_char_select_title.png", r.BtnClaim = "btn_claim.png", r.BtnClaimChar = "btn_claim_char.png", r.BtnClaimChest = "btn_claim_chest.png", r.BtnContinue = "btn_continue.png", r.BtnFreeChar = "btn_free_char.png", r.BtnGetKeys = "btn_get_keys.png", r.BtnPlayChar = "btn_play_char.png", r.BtnProgressionChar = "btn_progression_char.png", r.BtnRestart = "btn_restart.png", r.BtnSkip = "btn_skip.png", r.BtnUpgradeBoost = "btn_upgrade_boost.png", r.BtnUpgradeMax = "btn_upgrade_max.png", r.BtnUpgradeRewarded = "btn_upgrade_rewarded.png", r.BtnUpgradeStrength = "btn_upgrade_strength.png", r.Bubble = "bubble.png", r.Bush = "bush.png", r.BuyBtnSmall = "buy_btn_small.png", r.Cactus = "cactus.png", r.CharBtn = "char_btn.png", r.CharBtnSelected = "char_btn_selected.png", r.CharSelectButton = "char_select_button.png", r.Checkmark = "checkmark.png", r.ChestPanel = "chest_panel.png", r.ChestSmall = "chest_small.png", r.Circle = "circle.png", r.Circle16 = "circle16.png", r.Circle32 = "circle32.png", r.CloseBtn = "close_btn.png", r.Cloud = "cloud.png", r.Coin = "coin.png", r.CoinPile = "coin_pile.png", r.Desyrel = "desyrel.png", r.EyeClosed = "eye_closed.png", r.Filmgrej = "filmgrej.png", r.Fire = "fire.png", r.FirePlupp = "fire_plupp.png", r.Giftbox = "giftbox.png", r.Goal = "goal.png", r.GoalGlow = "goal_glow.png", r.Grass = "grass.png", r.Hand = "hand.png", r.HandHit = "hand_hit.png", r.Hit = "hit.png", r.Key = "key.png", r.M = "m.png", r.MoreGamesPlay = "more_games_play.png", r.MoreGamesTop = "more_games_top.png", r.Newbest = "newbest.png", r.NoAds = "no_ads.png", r.Palmtree = "palmtree.png", r.Pratbubbla = "pratbubbla.png", r.Progressbar = "progressbar.png", r.Propeller = "propeller.png", r.Rect = "rect.png", r.Rect16 = "rect16.png", r.RectMiddle = "rect_middle.png", r.RectTop = "rect_top.png", r.RestorePurchases = "restore_purchases.png", r.Rope = "rope.png", r.RopeStandard = "ropeStandard.png", r.RoundedScore = "roundedScore.png", r.Scorebubble = "scorebubble.png", r.SharescoreBtn = "sharescore_btn.png", r.SkinBatman = "skin_batman.png", r.SkinBatmanMenu = "skin_batman_menu.png", r.SkinBee = "skin_bee.png", r.SkinBeeMenu = "skin_bee_menu.png", r.SkinBuddy = "skin_buddy.png", r.SkinBuddyMenu = "skin_buddy_menu.png", r.SkinCarlzon = "skin_carlzon.png", r.SkinCarlzonMenu = "skin_carlzon_menu.png", r.SkinCat = "skin_cat.png", r.SkinCatMenu = "skin_cat_menu.png", r.SkinChicken = "skin_chicken.png", r.SkinChickenMenu = "skin_chicken_menu.png", r.SkinGolden = "skin_golden.png", r.SkinGoldenMenu = "skin_golden_menu.png", r.SkinHanger = "skin_hanger.png", r.SkinHangerBig = "skin_hanger_big.png", r.SkinHangerBigMenu = "skin_hanger_big_menu.png", r.SkinHangerMenu = "skin_hanger_menu.png", r.SkinHangerStickman = "skin_hanger_stickman.png", r.SkinHangerStickmanMenu = "skin_hanger_stickman_menu.png", r.SkinHelmet = "skin_helmet.png", r.SkinHelmetMenu = "skin_helmet_menu.png", r.SkinMario = "skin_mario.png", r.SkinMarioMenu = "skin_mario_menu.png", r.SkinMummy = "skin_mummy.png", r.SkinMummyMenu = "skin_mummy_menu.png", r.SkinNinja = "skin_ninja.png", r.SkinNinjaMenu = "skin_ninja_menu.png", r.SkinPig = "skin_pig.png", r.SkinPigMenu = "skin_pig_menu.png", r.SkinPuckman = "skin_puckman.png", r.SkinPuckmanMenu = "skin_puckman_menu.png", r.SkinRobot = "skin_robot.png", r.SkinRobotMenu = "skin_robot_menu.png", r.SkinSlime = "skin_slime.png", r.SkinSlimeMenu = "skin_slime_menu.png", r.SkinStarman = "skin_starman.png", r.SkinStarmanMenu = "skin_starman_menu.png", r.SkinSurfer = "skin_surfer.png", r.SkinSurferMenu = "skin_surfer_menu.png", r.SkinTarantula = "skin_tarantula.png", r.SkinTarantulaMenu = "skin_tarantula_menu.png", r.SkinVenom = "skin_venom.png", r.SkinVenomMenu = "skin_venom_menu.png", r.SkinZombie = "skin_zombie.png", r.SkinZombieMenu = "skin_zombie_menu.png", r.SkyGradient1 = "sky_gradient_01.png", r.SkyGradient2 = "sky_gradient_02.png", r.SkyGradient3 = "sky_gradient_03.png", r.SkyGradient4 = "sky_gradient_04.png", r.SkyGradient5 = "sky_gradient_05.png", r.SkyGradient6 = "sky_gradient_06.png", r.Snowman = "snowman.png", r.SoundOff = "sound_off.png", r.SoundOn = "sound_on.png", r.Spikeball = "spikeball.png", r.Spring = "spring.png", r.Starburst = "starburst.png", r.Sunglasses = "sunglasses.png", r.Title = "title.png", r.Torso1 = "torso_01.png",
        function(t) {
            var e = function() {
                function t() {}
                return t.getName = function() {
                    return "button"
                }, t.getMP3 = function() {
                    return i(39)
                }, t.getOGG = function() {
                    return i(40)
                }, t
            }();
            t.SoundsButton = e;
            var s = function() {
                function t() {}
                return t.getName = function() {
                    return "buyskin"
                }, t.getMP3 = function() {
                    return i(41)
                }, t.getOGG = function() {
                    return i(42)
                }, t
            }();
            t.SoundsBuyskin = s;
            var n = function() {
                function t() {}
                return t.getName = function() {
                    return "coin"
                }, t.getMP3 = function() {
                    return i(43)
                }, t.getOGG = function() {
                    return i(44)
                }, t
            }();
            t.SoundsCoin = n;
            var r = function() {
                function t() {}
                return t.getName = function() {
                    return "coins_reward"
                }, t.getMP3 = function() {
                    return i(45)
                }, t.getOGG = function() {
                    return i(46)
                }, t
            }();
            t.SoundsCoinsReward = r;
            var o = function() {
                function t() {}
                return t.getName = function() {
                    return "confetti"
                }, t.getMP3 = function() {
                    return i(47)
                }, t.getOGG = function() {
                    return i(48)
                }, t
            }();
            t.SoundsConfetti = o;
            var a = function() {
                function t() {}
                return t.getName = function() {
                    return "die"
                }, t.getMP3 = function() {
                    return i(49)
                }, t.getOGG = function() {
                    return i(50)
                }, t
            }();
            t.SoundsDie = a;
            var h = function() {
                function t() {}
                return t.getName = function() {
                    return "error"
                }, t.getMP3 = function() {
                    return i(51)
                }, t.getOGG = function() {
                    return i(52)
                }, t
            }();
            t.SoundsError = h;
            var l = function() {
                function t() {}
                return t.getName = function() {
                    return "goal"
                }, t.getMP3 = function() {
                    return i(53)
                }, t.getOGG = function() {
                    return i(54)
                }, t
            }();
            t.SoundsGoal = l;
            var c = function() {
                function t() {}
                return t.getName = function() {
                    return "hanger"
                }, t.getMP3 = function() {
                    return i(55)
                }, t.getOGG = function() {
                    return i(56)
                }, t
            }();
            t.SoundsHanger = c;
            var u = function() {
                function t() {}
                return t.getName = function() {
                    return "highscore"
                }, t.getMP3 = function() {
                    return i(57)
                }, t.getOGG = function() {
                    return i(58)
                }, t
            }();
            t.SoundsHighscore = u;
            var d = function() {
                function t() {}
                return t.getName = function() {
                    return "restart"
                }, t.getMP3 = function() {
                    return i(59)
                }, t.getOGG = function() {
                    return i(60)
                }, t
            }();
            t.SoundsRestart = d;
            var p = function() {
                function t() {}
                return t.getName = function() {
                    return "splat"
                }, t.getMP3 = function() {
                    return i(61)
                }, t.getOGG = function() {
                    return i(62)
                }, t
            }();
            t.SoundsSplat = p;
            var f = function() {
                function t() {}
                return t.getName = function() {
                    return "spring"
                }, t.getMP3 = function() {
                    return i(63)
                }, t.getOGG = function() {
                    return i(64)
                }, t
            }();
            t.SoundsSpring = f;
            var g = function() {
                function t() {}
                return t.getName = function() {
                    return "swisch1"
                }, t.getMP3 = function() {
                    return i(65)
                }, t.getOGG = function() {
                    return i(66)
                }, t
            }();
            t.SoundsSwisch1 = g;
            var m = function() {
                function t() {}
                return t.getName = function() {
                    return "swisch2"
                }, t.getMP3 = function() {
                    return i(67)
                }, t.getOGG = function() {
                    return i(68)
                }, t
            }();
            t.SoundsSwisch2 = m;
            var y = function() {
                function t() {}
                return t.getName = function() {
                    return "swisch3"
                }, t.getMP3 = function() {
                    return i(69)
                }, t.getOGG = function() {
                    return i(70)
                }, t
            }();
            t.SoundsSwisch3 = y;
            var v = function() {
                function t() {}
                return t.getName = function() {
                    return "swischBack"
                }, t.getMP3 = function() {
                    return i(71)
                }, t.getOGG = function() {
                    return i(72)
                }, t
            }();
            t.SoundsSwischBack = v
        }(e.Audio || (e.Audio = {})), e.Audiosprites || (e.Audiosprites = {}), e.GoogleWebFonts || (e.GoogleWebFonts = {}), e.CustomWebFonts || (e.CustomWebFonts = {}), e.BitmapFonts || (e.BitmapFonts = {}),
        function(t) {
            var e = function() {
                function t() {}
                return t.getName = function() {
                    return "levels"
                }, t.getJSON = function() {
                    return i(73)
                }, t
            }();
            t.Levels = e;
            var s = function() {
                function t() {}
                return t.getName = function() {
                    return "levels2"
                }, t.getJSON = function() {
                    return i(74)
                }, t
            }();
            t.Levels2 = s;
            var n = function() {
                function t() {}
                return t.getName = function() {
                    return "locale"
                }, t.getJSON = function() {
                    return i(75)
                }, t
            }();
            t.Locale = n
        }(e.JSON || (e.JSON = {})), a = e.XML || (e.XML = {}), h = function() {
            function t() {}
            return t.getName = function() {
                return "desyrel"
            }, t.getXML = function() {
                return i(76)
            }, t
        }(), a.XmlsDesyrel = h, e.Text || (e.Text = {}),
        function(t) {
            var e = function() {
                function t() {}
                return t.getName = function() {
                    return "box2d-plugin-full.min"
                }, t.getJS = function() {
                    return i(77)
                }, t
            }();
            t.ScriptBox2dPluginFullMin = e;
            var s = function() {
                function t() {}
                return t.getName = function() {
                    return "EasePack.min"
                }, t.getJS = function() {
                    return i(78)
                }, t
            }();
            t.ScriptEasePackMin = s;
            var n = function() {
                function t() {}
                return t.getName = function() {
                    return "random-js.min"
                }, t.getJS = function() {
                    return i(79)
                }, t
            }();
            t.ScriptRandomJsMin = n;
            var r = function() {
                function t() {}
                return t.getName = function() {
                    return "TweenMax.min"
                }, t.getJS = function() {
                    return i(80)
                }, t
            }();
            t.ScriptTweenMaxMin = r
        }(e.Scripts || (e.Scripts = {})), e.Shaders || (e.Shaders = {}), e.Misc || (e.Misc = {})
}, function(t, e, i) {
    (function(e) {
        t.exports = e.Phaser = i(26)
    }).call(e, i(13))
}, function(t, e) {
    var i, s, n, r, o, a, h, l;
    (s = i || (i = {}))[s.white = 16644818] = "white", s[s.scoreGateHighscoreTint = 16732754] = "scoreGateHighscoreTint", s[s.yellow = 16775294] = "yellow", s[s.facebookBlue = 14672878] = "facebookBlue", s[s.gameover = 16447430] = "gameover", s[s.dark = 4473924] = "dark", s[s.perfectGreen = 3925034] = "perfectGreen", s[s.greatYellow = 16383597] = "greatYellow", s[s.fireHanger = 16644894] = "fireHanger", s[s.fireBack = 16744337] = "fireBack", (r = n || (n = {})).main = "Concert One", r.bitmapMain = "desyrel", (a = o || (o = {}))[a.LEVEL = 0] = "LEVEL", a[a.EVENT = 1] = "EVENT", a[a.BODYPART = 2] = "BODYPART", (l = h || (h = {}))[l.level = 1] = "level", l[l.hanger = 2] = "hanger", l[l.blood = 4] = "blood", l[l.enemy = 8] = "enemy", l[l.coin = 22] = "coin";
    var c = 4433595,
        u = 1818023,
        d = [];
    d[0] = {
        back: "sky_gradient_01",
        ground: 16112760,
        grass: 50977,
        shadow: c
    }, d[1] = {
        back: "sky_gradient_01",
        ground: 1748185,
        grass: 15137791,
        shadow: c
    }, d[2] = {
        back: "sky_gradient_01",
        ground: 7197747,
        grass: 43836,
        shadow: c
    }, d[3] = {
        back: "sky_gradient_01",
        ground: 8014307,
        grass: 5770654,
        shadow: c
    }, d[4] = {
        back: "sky_gradient_01",
        ground: 14895587,
        grass: 6414336,
        shadow: c
    }, d[5] = {
        back: "sky_gradient_01",
        ground: 14895433,
        grass: 15138559,
        shadow: c
    }, d[6] = {
        back: "sky_gradient_01",
        ground: 14280753,
        grass: 3392016,
        shadow: c
    }, d[7] = {
        back: "sky_gradient_01",
        ground: 14723386,
        grass: 8739087,
        shadow: c
    }, d[8] = {
        back: "sky_gradient_01",
        ground: 16542358,
        grass: 8537189,
        shadow: c
    }, d[9] = {
        back: "sky_gradient_01",
        ground: 7829367,
        grass: 8445963,
        shadow: c
    }, d[10] = {
        back: "sky_gradient_02",
        ground: 16112760,
        grass: 50977,
        shadow: u
    }, d[11] = {
        back: "sky_gradient_02",
        ground: 1748185,
        grass: 15137791,
        shadow: u
    }, d[12] = {
        back: "sky_gradient_02",
        ground: 7197747,
        grass: 43836,
        shadow: u
    }, d[13] = {
        back: "sky_gradient_02",
        ground: 8014307,
        grass: 5770654,
        shadow: u
    }, d[14] = {
        back: "sky_gradient_02",
        ground: 14895587,
        grass: 6414336,
        shadow: u
    }, d[15] = {
        back: "sky_gradient_02",
        ground: 14895433,
        grass: 15138559,
        shadow: u
    }, d[16] = {
        back: "sky_gradient_02",
        ground: 14280753,
        grass: 3392016,
        shadow: u
    }, d[17] = {
        back: "sky_gradient_02",
        ground: 14723386,
        grass: 8739087,
        shadow: u
    }, d[18] = {
        back: "sky_gradient_02",
        ground: 16542358,
        grass: 8537189,
        shadow: u
    }, d[19] = {
        back: "sky_gradient_02",
        ground: 7829367,
        grass: 8445963,
        shadow: u
    };
    var p, f, g = [];
    g[0] = {
        ground: 7197747,
        grass: 50977,
        sprite: "bush.png"
    }, g[1] = {
        ground: 16112760,
        grass: -1,
        sprite: "palmtree.png"
    }, g[2] = {
        ground: 6086399,
        grass: 15268607,
        sprite: "snowman.png"
    }, g[3] = {
        ground: 15240243,
        grass: 9854244,
        sprite: "cactus.png"
    }, (f = p || (p = {})).SHOOT_ROPE = "shoot_rope", f.DROP_ROPE = "drop_rope", f.HANG = "hang", f.SCORE = "score", f.PRESS_BUTTON = "press_button", f.PRESS_BUTTON_RESTART = "press_button_restart", f.GAME_OVER = "game_over", f.HANGER_HURT = "hanger_hurt", f.TITLE_SCREEN_SHOW = "title_screen_show", f.HIGHSCORE = "highscore", f.COIN = "coin", f.BUY_SKIN = "buy_skin", f.NOT_ENOUGH = "not_enough", f.ERROR = "error", f.NINJA = "ninja", f.CONFETTI = "confetti", f.SPRING = "spring", f.COINS_REWARD = "coins_reward";
    var m = [];
    m.push("Great swinging there [name]!"), m.push("Watch out for the buzz saws [name]!"), m.push("You're a talented swinger [name]!"), m.push("Get the coins [name]!"), m.push("Don't lose your body parts [name]!"), m.push("That's some pro swinging [name]!"), m.push("Awesome swinging [name]!");
    var y = {},
        v = 2.5,
        x = 16776960,
        b = 16716032,
        _ = 9725209,
        T = 5385984,
        w = 16113045,
        S = 9344,
        C = 16744576;
    y.skin_hanger = {
        scale: .8,
        ropeColor: _,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 200,
        name: "HANGER",
        locked: !1,
        backColor: 58623,
        noEyes: !1,
        pantsColor: T,
        shirtColor: b,
        skinColor: w
    }, y.skin_zombie = {
        scale: .8,
        ropeColor: _,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 400,
        name: "ZOMBIE",
        pantsColor: T,
        shirtColor: w,
        skinColor: 3650816,
        locked: !0,
        backColor: 13537533
    }, y.skin_pig = {
        scale: .8,
        ropeColor: _,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 500,
        name: "PIGGIE",
        pantsColor: T,
        shirtColor: 12798795,
        skinColor: C,
        locked: !0,
        backColor: 8190438
    }, y.skin_robot = {
        scale: .8,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 500,
        name: "ROBOT",
        pantsColor: 2961196,
        shirtColor: 9278088,
        skinColor: 14410706,
        locked: !0,
        backColor: 15509467
    }, y.skin_ninja = {
        hidden: !1,
        scale: .8,
        ropeColor: 16711680,
        width: 30,
        damageForce: v,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 500,
        name: "NINJA",
        pantsColor: 0,
        shirtColor: 0,
        skinColor: 0,
        locked: !0,
        backColor: 16747675
    }, y.skin_tarantula = {
        scale: .8,
        ropeColor: 16777215,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 400,
        score: 140,
        name: "TARANTULA",
        pantsColor: S,
        shirtColor: b,
        skinColor: S,
        locked: !0,
        backColor: 16763221
    }, y.skin_mario = {
        scale: .8,
        ropeColor: b,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 200,
        score: 340,
        name: "JUMP MAN",
        pantsColor: S,
        shirtColor: b,
        skinColor: w,
        locked: !0,
        backColor: 7645183
    }, y.skin_batman = {
        scale: .8,
        ropeColor: 6710886,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 800,
        score: 640,
        name: "ALBERT",
        pantsColor: 1052688,
        shirtColor: 6710886,
        skinColor: 1052688,
        locked: !0,
        backColor: 7463167
    }, y.skin_mummy = {
        scale: .8,
        ropeColor: 5327676,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 1e3,
        name: "MUMMY",
        pantsColor: 3878947,
        shirtColor: 15394259,
        skinColor: 7565415,
        locked: !0,
        backColor: 16630601
    }, y.skin_starman = {
        scale: .8,
        ropeColor: S,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 1e3,
        name: "STAR",
        pantsColor: S,
        shirtColor: S,
        skinColor: 16282543,
        locked: !0,
        backColor: 16630601
    }, y.skin_cat = {
        scale: .8,
        ropeColor: C,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 1e3,
        name: "CAT",
        pantsColor: 3497360,
        shirtColor: C,
        skinColor: 3497360,
        locked: !0,
        backColor: 16241238
    }, y.skin_helmet = {
        scale: .8,
        ropeColor: _,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 1e3,
        name: "HOODIE",
        pantsColor: T,
        shirtColor: 16738565,
        skinColor: 6697745,
        locked: !0,
        backColor: 8839167
    }, y.skin_venom = {
        scale: .8,
        ropeColor: 16777215,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 800,
        name: "INK",
        pantsColor: 1116715,
        shirtColor: 1116715,
        skinColor: 1116715,
        locked: !0,
        backColor: 14339936
    }, y.skin_puckman = {
        scale: .8,
        ropeColor: 12976128,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 800,
        name: "PUCK MAN",
        pantsColor: 12976128,
        shirtColor: b,
        skinColor: x,
        locked: !0,
        backColor: 6414015
    }, y.skin_surfer = {
        scale: .8,
        ropeColor: x,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 2e3,
        name: "SURFER",
        pantsColor: T,
        shirtColor: x,
        skinColor: 13718423,
        locked: !0,
        backColor: 7798759
    }, y.skin_golden = {
        scale: .8,
        ropeColor: 16777057,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 2e3,
        name: "GOLDEN",
        pantsColor: 16766976,
        shirtColor: x,
        skinColor: 16766976,
        locked: !0,
        backColor: 3864050
    }, y.skin_chicken = {
        scale: .8,
        ropeColor: 16733525,
        damageForce: v,
        width: 38,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 2e3,
        name: "CHICKEN",
        pantsColor: 16711422,
        shirtColor: 16711422,
        skinColor: 16711422,
        locked: !0,
        backColor: 3864050
    }, y.skin_hanger_big = {
        scale: 1.3,
        ropeColor: _,
        ropeSpeed: .5,
        damageForce: 11,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        coins: 2e3,
        name: "BIG HANGER",
        locked: !0,
        backColor: 58623,
        pantsColor: T,
        shirtColor: b,
        skinColor: w
    }, y.skin_bee = {
        scale: .8,
        ropeColor: _,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        score: 1040,
        coins: 400,
        name: "TIGER",
        pantsColor: T,
        shirtColor: x,
        skinColor: 16738565,
        locked: !0,
        backColor: 16749716
    }, y.skin_slime = {
        scale: .8,
        ropeColor: 1196050,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        score: 1540,
        coins: 400,
        name: "SLIME",
        pantsColor: 1196050,
        shirtColor: C,
        skinColor: 28672,
        locked: !0,
        backColor: 15720284
    }, y.skin_carlzon = {
        scale: .8,
        ropeColor: _,
        damageForce: v,
        width: 30,
        ropeDamping: 10,
        ropeFrequency: 10,
        score: 2140,
        coins: 800,
        name: "CARLZON",
        pantsColor: 4853004,
        shirtColor: 16777215,
        skinColor: 15381526,
        locked: !0,
        backColor: 6944218
    };
    window.Colors = i, window.Fonts = n, window.HangerObjectTypes = o, window.HangerCollisionGroups = h, window.HangerShirtColors = [0], window.HangerLevelColors = [16112760], window.FxEvent = p, window.BASE_SPEED = 1, window.CANVAS_RENDERING = !1, window.SHARE_IMAGE = "", window.SYSTEM_FONT = "Arial", window.SKINS = y, window.ACTIVE_SKIN = "skin_hanger", window.SOLO_SHARE_TEXTS = m, window.TIME_SINCE_LAST_SESSION = -2, window.CONFETTI = null, window.ISCONTEXT = null, window.SAFE_TOP = 0, window.SAFE_SIDE = 0, window.GRADIENT_BACK = "sky_gradient_01.png", window.HIDE_UI = !1, window.MULTI_HANGERS = !1, window.SHADOW_COLOR = 7323857, window.SHADOWS = !0, window.GRASS = !0, window.GROUNDPATTERNS = !0, window.LEVELBOXES = !1, window.FPSMETER = !1, window.LEVEL_INDEX = 1, window.BASE_SEED = 1233, window.LEVELS = null, window.EDITOR_MODE = !1, window.COLOR_THEMES = d, window.SCORE = 0, window.OVERRIDE_COLORS = {
        level: 0,
        back: 0,
        stickman: 0
    }, window.LEVEL_SET = "A", window.SKINS_IN_REWARD = ["skin_hanger", "skin_zombie", "skin_bee", "skin_slime", "skin_carlzon", "skin_helmet", "skin_venom", "skin_puckman"], window.BOOSTER_LEVEL = 0, window.STRENGTH_LEVEL = 0, window.ENDCOLORS = g, window.BEST_SCORE = 0, window.NO_ADS = !1, window.IAP_IN_PROGRESS = !1, window.KEYS = 0, window.GLOBAL_GAME = null, window.NO_BLOOD = !1, window.HUZ = !1
}, function(t, e, i) {
    "use strict";
    var s;
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), (s = e.AD_PLACEMENT || (e.AD_PLACEMENT = {})).CONTINUE = "continue", s.DOUBLE_UP = "doubleUp", s.CHARACTER_UNLOCK = "characterUnlock", s.CLAIM_REWARD = "claimReward", s.PROGRESSION_CHARACTER = "progressionChar", s.UPGRADE_STRENGTH = "upgradeStrength", s.UPGRADE_BOOST = "upgradeBoost", s.SKIP_LEVEL = "skipLevel", s.GET_MORE_KEYS = "moreKeys", s.INTERSTITIAL = "interstitial";
    var n = function() {
        function t() {
            this.isAdsSupported = !0, this.statsCoins = 0, this.rewardedCount = 0, this.rewardedLoaded = !1, this.rewardedInProgress = !1
        }
        return t.prototype.init = function() {
            this.loadData(), this.preloadRewarded()
        }, t.prototype.buyIAP = function(t) {}, t.prototype.restorePurchases = function() {}, t.prototype.loadData = function(t) {
            void 0 === t && (t = null);
            var e = localStorage.getItem("hanger_web_save2");
            if ((e = JSON.parse(e)) && e.coins && (this.statsCoins = e.coins), e && e.skins)
                for (var i in SKINS) e.skins[i] && (SKINS[i].locked = e.skins[i].locked);
            e && e.level && (LEVEL_INDEX = e.level), e && e.activeSkin && (ACTIVE_SKIN = e.activeSkin), e && e.score && (SCORE = e.score), e && e.strengthLevel && (STRENGTH_LEVEL = e.strengthLevel), e && e.boosterLevel && (BOOSTER_LEVEL = e.boosterLevel), e && e.bestScore && (BEST_SCORE = e.bestScore), e && e.keys && (KEYS = e.keys), e && e.noAds && (NO_ADS = e.noAds), t && t()
        }, t.prototype.showAppReview = function() {}, t.prototype.analyticsEvent = function(t) {}, t.prototype.saveData = function() {
            var t = {
                coins: this.statsCoins,
                skins: SKINS,
                level: LEVEL_INDEX,
                activeSkin: ACTIVE_SKIN,
                score: SCORE,
                levelSet: LEVEL_SET,
                boosterLevel: BOOSTER_LEVEL,
                strengthLevel: STRENGTH_LEVEL,
                bestScore: BEST_SCORE,
                noAds: NO_ADS,
                keys: KEYS
            };
            localStorage.setItem("hanger_web_save2", JSON.stringify(t))
        }, t.prototype.isInterstitialLoaded = function() {
            return !0
        }, t.prototype.showInterstitial = function(t, e, i) {
            this.rewardedCount < 1 && !NO_ADS ? (setTimeout(function() {
                return e.call(i)
            }, 400), HUZ || "undefined" == typeof gdsdk || "undefined" === gdsdk.showAd || gdsdk.showAd()) : e.call(i)
        }, t.prototype.preloadRewarded = function() {
            var t = this;
            this.rewardedLoaded || HUZ || "undefined" === gdsdk || "undefined" === gdsdk.preloadAd || gdsdk.preloadAd("rewarded").then(function(e) {
                t.rewardedLoaded = !0, console.log("REWARDED AD LOADED")
            }).catch(function(t) {})
        }, t.prototype.isRewardedPreloaded = function() {
            return this.rewardedLoaded
        }, t.prototype.showRewarded = function(t, e, i) {
            var s = this;
            this.rewardedInProgress || (this.rewardedInProgress = !0, HUZ || "undefined" === gdsdk || "undefined" === gdsdk.showAd || (this.rewardedLoaded = !1, gdsdk.showAd("rewarded")), setTimeout(function() {
                s.rewardedInProgress = !1, e.call(i)
            }, 300), setTimeout(function() {
                s.preloadRewarded()
            }))
        }, t.prototype.showBanner = function() {}, t.prototype.removeBanner = function() {}, t.prototype.hideBanner = function() {}, t.prototype.impact = function() {}, t.prototype.unlockAll = function() {
            for (var t in SKINS) SKINS[t].locked = !1;
            this.saveData()
        }, t.prototype.resetSaveData = function() {
            for (var t in SKINS) SKINS[t].locked = "skin_hanger" != t;
            ACTIVE_SKIN = "skin_hanger", this.statsCoins = 0, LEVEL_INDEX = 1, SCORE = 0, LEVEL_SET = "A", BOOSTER_LEVEL = 0, STRENGTH_LEVEL = 0, BEST_SCORE = 0, KEYS = 0, NO_ADS = !1, this.saveData()
        }, t.prototype.levelStart = function() {}, t.prototype.levelComplete = function() {}, t.prototype.levelFail = function() {}, Object.defineProperty(t, "Instance", {
            get: function() {
                return this._instance || (this._instance = new this)
            },
            enumerable: !0,
            configurable: !0
        }), t
    }();
    e.default = n;
    n.Instance
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s = function() {
        function t() {
            this.currentLanguage = "EN"
        }
        return Object.defineProperty(t.prototype, "language", {
            get: function() {
                return this.currentLanguage
            },
            set: function(t) {
                this.currentLanguage = t
            },
            enumerable: !0,
            configurable: !0
        }), t.prototype.init = function(t, e) {
            this.data = t, this.game = e
        }, t.prototype.getBitmapText = function(t, e, i, s, n) {
            void 0 === e && (e = 50), void 0 === i && (i = -1), void 0 === s && (s = null), void 0 === n && (n = !0);
            var r = this.game.add.bitmapText(0, 0, Fonts.bitmapMain, this.getText(t, n, s), e);
            return i > 0 && r.width > i && r.scale.set(i / r.width, i / r.width * 1.1), r
        }, t.prototype.getText = function(t, e, i) {
            if (void 0 === e && (e = !0), void 0 === i && (i = null), !this.data) return "";
            var s = "";
            if (this.data[t] && (s = this.data[t][this.currentLanguage] ? this.data[t][this.currentLanguage] : this.data[t].EN), i)
                for (var n in i) s = s.replace("{" + n + "}", i[n]);
            return e && (s = s.toUpperCase()), s
        }, Object.defineProperty(t, "Instance", {
            get: function() {
                return this._instance || (this._instance = new this)
            },
            enumerable: !0,
            configurable: !0
        }), t
    }();
    e.default = s;
    s.Instance
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s, n, r = i(11),
        o = i(89),
        a = i(90),
        h = i(91),
        l = i(92),
        c = i(93),
        u = i(94),
        d = i(95),
        p = i(96);
    (n = s = e.EventType || (e.EventType = {}))[n.BUZZ_SAW = 0] = "BUZZ_SAW", n[n.CRATE_STACK = 1] = "CRATE_STACK", n[n.PROPELLER = 2] = "PROPELLER", n[n.CRATE = 3] = "CRATE", n[n.SPRING = 4] = "SPRING", n[n.BOOST = 5] = "BOOST", n[n.BOOST6 = 6] = "BOOST6", n[n.BIGBALL = 7] = "BIGBALL", n[n.BIGPROPELLER = 8] = "BIGPROPELLER";
    var f = function() {
        function t(t, e, i, s, n) {
            this.blockSize = 248, this.maxBlocksSeen = 0, this.game = t, this.activeEvents = [], this.eventCache = [], this.eventPositions = e, this.levelConfig = n, this.frontLayer = i, this.backLayer = s
        }
        return t.prototype.preBuildCache = function() {
            for (var t = 0; t < this.eventPositions.length; t++);
        }, t.prototype.getEventOfType = function(t) {
            for (var e, i = 0; i < this.eventCache.length; i++)
                if (this.eventCache[i].type == t && 0 == this.eventCache[i].inUse) return e = this.eventCache[i], this.eventCache.splice(i, 1), e;
            return this.createEventOfType(t)
        }, t.prototype.createEventOfType = function(t, e, i) {
            void 0 === e && (e = 0), void 0 === i && (i = 0);
            var n = null;
            return t == s.BUZZ_SAW && (n = new o.default(this.game, this.backLayer, e, i)), t == s.PROPELLER && (n = new a.default(this.game, this.backLayer, e, i)), t != s.CRATE && t != s.CRATE_STACK || (n = new h.default(this.game, this.frontLayer, e, i)), t == s.SPRING && (n = new l.default(this.game, this.backLayer, e, i)), t == s.BOOST && (n = new c.default(this.game, this.backLayer, e, i)), t == s.BOOST6 && (n = new u.default(this.game, this.backLayer, e, i)), t == s.BIGBALL && (n = new d.default(this.game, this.frontLayer, e, i)), t == s.BIGPROPELLER && (n = new p.default(this.game, this.frontLayer, e, i)), n ? (this.activeEvents.push(n), n.inUse = !0, n.visible = !0, n) : null
        }, t.prototype.addEvent = function(t) {
            var e = 1;
            t.type == s.CRATE_STACK && (e = 5, t.type = s.CRATE);
            for (var i = 0; i < e; i++) {
                var n = this.game.world.centerY + 500 - (-1 * this.levelConfig.getBottomBlockPosAt(t.pos) - 25 * i);
                n > this.game.height && (n = this.game.world.centerY);
                var r = this.getEventOfType(t.type);
                if (!r) return void console.warn("no event found: " + t.type);
                r.visible = !0, r.inUse = !0, r.activate(), r.body ? (r.body.x = 248 * t.pos + t.x, t.ignoreLevelHeight ? r.body.y = this.game.height / 2 + t.y : r.body.y = n + t.y) : (r.x = 248 * t.pos + t.x, t.ignoreLevelHeight ? r.y = this.game.height / 2 + t.y : r.y = n + t.y), r.inUse = !0, r.visible = !0, this.activeEvents.push(r)
            }
        }, t.prototype.update = function(t, e) {
            for (var i = 0; i < this.activeEvents.length; i++)
                if (this.activeEvents[i].update(), t - this.activeEvents[i].x > 1e3) {
                    var s = this.activeEvents[i];
                    s.inUse = !1, s.visible = !1, this.activeEvents.splice(i, 1), this.eventCache.push(s)
                } if (e > this.maxBlocksSeen) {
                for (i = 0; i < this.eventPositions.length; i++) this.eventPositions[i].pos == e && (this.eventPositions[i].pos < 4 * this.levelConfig.length - 1 || this.eventPositions[i].force) && this.addEvent(this.eventPositions[i]);
                if (this.levelConfig.customEvents)
                    for (i = 0; i < this.levelConfig.customEvents.length; i++)
                        if (this.levelConfig.customEvents[i].pos == e) {
                            var n = this.levelConfig.customEvents[i],
                                o = 0,
                                a = 0,
                                h = 4,
                                l = 0,
                                c = !1;
                            n.type && (l = n.type), n.pos && (h = n.pos), n.x && (o = n.x), n.y && (a = n.y), n.ignoreLevelHeight && (c = n.ignoreLevelHeight), (h < 4 * this.levelConfig.length - 1 || n.force) && this.addEvent(new r.default(l, h, o, a, c))
                        } this.maxBlocksSeen = e
            }
        }, t
    }();
    e.default = f
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(2), i(1);
    var s = i(0),
        n = function() {
            function t() {
                this.bigCoinMessage = null, this.library = {}
            }
            return t.prototype.init = function(t) {
                this.game = t
            }, t.prototype.add = function(t, e, i, s, n) {
                void 0 === i && (i = 1), void 0 === s && (s = 0), void 0 === n && (n = 0), null == this.library[t] && (this.library[t] = []), this.library[t].push({
                    name: e,
                    volume: i,
                    loop: s,
                    randomVariations: n
                })
            }, t.prototype.fx = function(t) {
                if (this.game && null != this.library[t])
                    for (var e = 0, i = this.library[t]; e < i.length; e++) {
                        var s = i[e];
                        if (s.randomVariations > 0) {
                            var n = s.name.substring(0, s.name.length - 1);
                            this.game.sound.play(n + (Math.floor(Math.random() * s.randomVariations) + 1), s.volume, s.loop)
                        } else this.game.sound.play(s.name, s.volume, s.loop)
                    }
            }, t.prototype.showMessage = function(t, e, i, n, r, o) {
                var a = this;
                void 0 === t && (t = ""), void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === n && (n = 0), void 0 === r && (r = Colors.white), void 0 === o && (o = -1), this.game && this.game.camera && 1 != HIDE_UI && (TweenMax.killTweensOf(this.bigMessage), this.bigMessage.text = t, this.bigMessage.visible = !0, this.bigMessage.parent.addChild(this.bigMessage), this.bigMessage.tint = r, -1 == o && (o = 0 == n ? 2 : 1), 0 == n ? (this.bigMessage.scale.x = 4, this.bigMessage.scale.y = 4, this.bigMessage.alpha = 0, TweenMax.to(this.bigMessage.scale, .25, {
                    x: 1,
                    y: 1,
                    ease: Bounce.easeOut
                }), TweenMax.to(this.bigMessage, .1, {
                    alpha: 1
                }), TweenMax.to(this.bigMessage, .25, {
                    delay: o,
                    alpha: 0,
                    onComplete: function() {
                        return a.hideMessage()
                    }
                })) : 1 == n && (this.bigMessage.alpha = 0, this.bigMessage.scale.x = 0, this.bigMessage.scale.y = 0, TweenMax.to(this.bigMessage.scale, .25, {
                    x: 1,
                    y: 1,
                    ease: Back.easeOut
                }), TweenMax.to(this.bigMessage, .1, {
                    alpha: 1
                }), TweenMax.to(this.bigMessage, .25, {
                    delay: o,
                    alpha: 0,
                    onComplete: function() {
                        return a.hideMessage()
                    }
                })), this.bigMessage.cameraOffset.y = 0 == e ? this.game.height - 85 : e, i && (this.bigCoinMessage || (this.bigCoinMessage = this.game.make.sprite(0, 0, s.Atlases.SpritesheetsMain.getName(), s.Atlases.SpritesheetsMain.Frames.Coin), this.bigCoinMessage.x = this.game.width / 2 - 85, this.bigCoinMessage.y = this.game.height - 50, this.bigCoinMessage.anchor.set(.5), this.bigCoinMessage.fixedToCamera = !0, this.bigCoinMessage.visible = !0, this.bigCoinMessage.cameraOffset.y = this.bigMessage.cameraOffset.y + 5), this.bigMessage.cameraOffset.y = this.bigMessage.cameraOffset.y, this.bigMessage.parent.addChild(this.bigCoinMessage), this.bigCoinMessage.scale.x = 4, this.bigCoinMessage.scale.y = 4, this.bigCoinMessage.alpha = 0, this.bigCoinMessage.cameraOffset.y = this.bigMessage.cameraOffset.y + 5, this.bigCoinMessage.visible = !0, TweenMax.to(this.bigCoinMessage.scale, .25, {
                    x: 1,
                    y: 1,
                    ease: Bounce.easeOut
                }), TweenMax.to(this.bigCoinMessage, .1, {
                    alpha: 1
                }), TweenMax.to(this.bigCoinMessage, .25, {
                    delay: 2,
                    alpha: 0,
                    onComplete: function() {
                        return a.hideMessage()
                    }
                })))
            }, t.prototype.hideMessage = function() {
                1 === this.bigMessage.scale.x && (this.bigMessage.visible = !1, this.bigCoinMessage && (this.bigCoinMessage.visible = !1))
            }, Object.defineProperty(t, "Instance", {
                get: function() {
                    return this._instance || (this._instance = new this)
                },
                enumerable: !0,
                configurable: !0
            }), t
        }();
    e.default = n;
    n.Instance
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = function(t) {
        function e(e, i, s, n, r, o) {
            void 0 === s && (s = 0), void 0 === n && (n = 0);
            var a = t.call(this, i, s, n, r, o) || this;
            return a.pos = -1, a.ignoreLevelHeight = !1, a.type = e, a.autoCull = !0, a
        }
        return n(e, t), e.prototype.inactivate = function() {
            this.inUse = !1
        }, e.prototype.activate = function() {
            this.inUse = !0
        }, e
    }(Phaser.Sprite);
    e.default = r
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s = {
        nearestMultiple: function(t, e) {
            return Math.round(t / e) * e
        },
        scaleBetween: function(t, e, i) {
            return t + (e - t) * i
        },
        percentageBetween2: function(t, e, i) {
            return (t - e) / (i - e)
        }
    };
    e.default = s
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.parseBounds = function(t) {
        t.x = t.x ? t.x : 0, t.y = t.y ? t.y : 0, t.width <= 0 ? console.warn("PhaserListView: bounds.width <= 0") : t.height <= 0 && console.warn("PhaserListView: bounds.height <= 0");
        return t
    }, e.getWidthOrHeight = function(t, e) {
        return t["nominal" + o(e)] || t[e]
    }, e.capitalizeFirstLetter = o, e.findChild = a, e.detectDrag = h, e.dispatchClicks = function(t, e, i) {
        if ("onInputUp" == i && h(t)) return;
        var s = a(e, function(e) {
            var i = e.worldPosition,
                s = e.anchor,
                n = e.pivot,
                r = e.width,
                o = e.height,
                a = e.scale,
                h = i.x - (s ? s.x * r : 0) - n.x * a.x,
                l = i.y - (s ? s.y * o : 0) - n.y * a.y;
            return e.inputEnabled && new Phaser.Rectangle(h, l, e.width, e.height).contains(t.x, t.y)
        });
        s && s.events && s.events[i] && s.events[i].dispatch && s.events[i].dispatch(s, t, !0);
        return s
    };
    var s, n = i(18),
        r = (s = n) && s.__esModule ? s : {
            default: s
        };

    function o(t) {
        return t.charAt(0).toUpperCase() + t.slice(1)
    }

    function a(t, e) {
        var i = arguments.length <= 2 || void 0 === arguments[2] ? null : arguments[2];
        if (!t) return !1;
        for (var s = 0; s < t.length; s++) {
            var n = t[s];
            if (n) {
                if (e.call(i, n)) return n;
                var r = a(n.children, e, i);
                if (r) return r
            }
        }
        return !1
    }

    function h(t) {
        var e = Math.abs(t.positionDown.x - t.positionUp.x),
            i = Math.abs(t.positionDown.y - t.positionUp.y);
        t.timeUp, t.timeDown;
        return e > r.default.AUTO_DETECT_THRESHOLD || i > r.default.AUTO_DETECT_THRESHOLD
    }
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = i(0),
        o = i(83),
        a = i(16),
        h = i(17),
        l = i(98),
        c = i(108),
        u = i(109),
        d = i(111);
    i(2);
    var p = i(6);
    i(3);
    var f = i(3),
        g = i(112),
        m = i(114),
        y = i(116),
        v = i(117),
        x = i(118),
        b = i(22),
        _ = i(119),
        T = i(120),
        w = i(4),
        S = function(t) {
            function e() {
                var e = null !== t && t.apply(this, arguments) || this;
                return e.isPlaying = !1, e.cameraOffset = 0, e.endScore = 0, e.highestScorePostedThisSession = 0, e.lastFrameScore = 0, e.maxFps = 0, e.lowFPSMode = !1, e.autostartNext = !1, e.lastFrameCoins = 0, e.interstitialShownThisRound = !1, e.revivals = 0, e.reviveX = 0, e.isWinning = !1, e.isWinningDone = !1, e.extraScore = 0, e.currentExtraScore = 0, e.firstRope = !1, e.showTutorialTime = 1e3, e.winTime = 0, e.justRevived = !1, e.startTime = 0, e
            }
            return n(e, t), e.prototype.create = function() {
                var t = this;
                this.revivals = 0, this.isWinning = !1, this.isWinningDone = !1, this.isPlaying = !1, this.extraScore = 0, this.currentExtraScore = 0, this.firstRope = !1, this.handTutorial = null, this.game.sound.muteOnPause = !1;
                var i = new URL(window.location.href);
                i.searchParams.get("level") && e.first && (LEVEL_INDEX = parseInt(i.searchParams.get("level"))), e.first = !1, f.default.Instance.game = this.game, 1 == this.game.renderType && (CANVAS_RENDERING = !0), this.game.physics.startSystem(Phaser.Physics.BOX2D), this.game.physics.box2d.gravity.y = 600, this.game.physics.box2d.useElapsedTime = !1, this.interstitialShownThisRound = !1, this.game.renderer, PIXI.CanvasRenderer, this.game.renderer.clearBeforeRender = !0, this.game.camera.flash(16777215, 200), this.game.time.desiredFps = 60;
                var s = this.game;
                s.stage.setBackgroundColor(58623);
                var n = COLOR_THEMES[(LEVEL_INDEX - 1) % COLOR_THEMES.length];
                GRADIENT_BACK = n.back, SHADOW_COLOR = n.shadow, CANVAS_RENDERING ? (this.game.physics.box2d.velocityIterations = 2, this.game.physics.box2d.positionIterations = 2, this.game.time.desiredFps = 30) : (this.back = new a.default(this.game, this.camera), this.game.add.existing(this.back)), e.DEBUG_back = this.back, s.world.setBounds(-200, 0, 3e6, s.world.bounds.height);
                var c = s.world.centerY,
                    u = b.default.GenerateRandomLevelBasedOnIndex(LEVEL_INDEX);
                if (u.levelColor = n.ground, u.grassColor = n.grass, 0 != OVERRIDE_COLORS.level && (u.levelColor = OVERRIDE_COLORS.level), 0 != OVERRIDE_COLORS.back && this.back.updateDebugTint(), this.level = new h.default(s, u), this.level.create(), e.currentLevel = this.level, this.hanger = new o.default(s, SKINS.skin_hanger.scale, 130, c), this.hanger.minRopeLength = 2 + this.game.height / 250, this.level.hanger = this.hanger, e.currentHanger = this.hanger, this.hanger.ropeHitEffect.setColor(this.level.config.levelColor), this.extraHangers = [], MULTI_HANGERS)
                    for (var d = 0; d < 5; d++) {
                        var m = null;
                        (m = new o.default(s, .75 * SKINS.skin_hanger.scale, 300 + 70 * d, 900)).minRopeLength = 4, this.extraHangers.push(m)
                    }
                if (ACTIVE_SKIN && this.hanger.setSkin(ACTIVE_SKIN), this.coinsIcon = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Coin), this.coinsIcon.inputEnabled = !0, this.coinsIcon.clickCount = 0, this.coinsIcon.events.onInputDown.add(function() {
                        t.coinsIcon.clickCount++, t.coinsIcon.clickCount % 3 == 0 && t.isPlaying
                    }, this), this.scoreText = this.game.add.bitmapText(s.world.centerX, s.world.centerY, Fonts.bitmapMain, "", 140), this.scoreText.x = s.width / 2, this.scoreText.y = 200 + 2 * SAFE_TOP, this.scoreText.anchor.set(.5), this.scoreText.fixedToCamera = !0, this.coinsText = this.game.add.bitmapText(20, 10, Fonts.bitmapMain, "" + f.default.Instance.statsCoins, 35), this.coinsText.x = this.game.width - 55 - SAFE_SIDE, this.coinsText.y = 23 + SAFE_TOP, this.coinsText.anchor.set(1, .5), this.coinsText.fixedToCamera = !0, this.coinsIcon.anchor.set(0, .5), this.coinsIcon.x = this.game.width - 50 - SAFE_SIDE, this.coinsIcon.y = 26 + SAFE_TOP, this.coinsIcon.fixedToCamera = !0, this.coinsIcon.scale.set(.7), this.backBtn = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnBack), this.backBtn.anchor.set(0, .5), this.backBtn.scale.set(.6), this.backBtn.x = 55 + SAFE_SIDE, this.backBtn.y = 28 + SAFE_TOP, this.backBtn.inputEnabled = !0, this.backBtn.fixedToCamera = !0, this.backBtn.events.onInputDown.add(function() {
                        t.realRestart()
                    }), this.backBtn.visible = !1, this.game.add.existing(this.backBtn), this.game.time.advancedTiming = !0, this.spaceKey = this.game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR), this.game.camera.fx.scale.set(1.5, 1.5), this.game.camera.fx.x = -100, this.game.camera.fx.y = -100, this.cameraOffset = this.game.camera.width / 2, this.startScreen = new l.default(this.game, this.startGame, this.hanger, this.onUpgrade, this.realRestart, this), this.game.add.existing(this.startScreen), this.startScreen.visible = !0, this.scoreText.visible = !1, this.progress = new y.default(this.game, this.level.config.length, LEVEL_INDEX), this.game.add.existing(this.progress), this.progress.visible = !1, this.muteButton = new v.default(this.game), this.muteButton.cameraOffset.x = 10 + SAFE_SIDE, this.muteButton.cameraOffset.y = 6 + SAFE_TOP, this.muteButton.fixedToCamera = !0, this.bigMessage = this.game.add.bitmapText(s.world.centerX, s.world.centerY, Fonts.bitmapMain, "NOT ENOUGH!", 70), this.bigMessage.x = s.width / 2, this.bigMessage.y = s.height / 2 - 50, this.bigMessage.anchor.set(.5), this.bigMessage.fixedToCamera = !0, this.bigMessage.tint = Colors.white, this.bigMessage.visible = !1, setTimeout(function() {
                        return t.hanger.shoot(0, 250)
                    }, 100), this.game.physics.box2d.frameRate = 1 / 60, CANVAS_RENDERING && (this.game.physics.box2d.frameRate = 1 / 30), p.default.Instance.bigMessage = this.bigMessage, this.bigCoinMessage = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Coin), this.bigCoinMessage.x = this.game.width / 2 - 85, this.bigCoinMessage.y = this.game.height / 2 - 50, this.bigCoinMessage.anchor.set(.5), this.bigCoinMessage.fixedToCamera = !0, this.bigCoinMessage.visible = !1, p.default.Instance.bigCoinMessage = this.bigCoinMessage, this.confetti = new g.default(this.game), this.game.add.existing(this.confetti), CONFETTI = this.confetti, this.game.world.sendToBack(this.back), this.fpstext = this.game.add.bitmapText(0, 50, Fonts.bitmapMain, "0", 50), this.fpstext.tint = 0, this.fpstext.fixedToCamera = !0, this.fpstext.visible = !1, 1 == LEVEL_INDEX ? this.showTutorialTime = 1e3 : this.showTutorialTime = 4e3, 1 == e.showskiplevelNext) {
                    this.skip = new Phaser.Group(this.game);
                    var x = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnSkip);
                    x.anchor.set(.5), this.skip.fixedToCamera = !0, this.skip.cameraOffset.x = s.width - 80, this.skip.cameraOffset.y = SAFE_TOP + 180, this.skip.visible = !1, this.skip.add(x);
                    var _ = w.default.Instance.getBitmapText("lbl_skip", 24, 108);
                    _.anchor.set(.5), this.skip.add(_), _.x = -2, _.y = 24, x.inputEnabled = !0, x.events.onInputDown.add(function() {
                        f.default.Instance.showRewarded(f.AD_PLACEMENT.SKIP_LEVEL, function() {
                            LEVEL_INDEX += 1, f.default.Instance.saveData(), e.showskiplevelNext = !1, t.restart()
                        }, t)
                    })
                }
                f.default.Instance.rewardedCount = 0, setTimeout(function() {
                    f.default.Instance.showBanner()
                }, 1e3), f.default.Instance.preloadRewarded()
            }, e.prototype.onUpgrade = function() {
                var t = this;
                this.startScreen && (this.startScreen.visible = !1);
                var e = this.game.add.sprite(this.hanger.lowerArmL.x, this.hanger.getTorsoY(), r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Starburst);
                e.alpha = .8, e.scale.set(2, 2), e.anchor.set(.5, .5), e.blendMode = PIXI.blendModes.ADD, this.game.physics.box2d.frameRate = 1 / 600, TweenMax.from(e.scale, 1, {
                    x: 0,
                    y: 0
                }), TweenMax.to(e, 1.2, {
                    rotation: 3
                }), this.game.world.sendToBack(e), this.game.world.sendToBack(this.back), TweenMax.to(e.scale, 1, {
                    delay: 1,
                    x: 7,
                    y: 7
                }), TweenMax.to(e, 1.2, {
                    delay: 1.2,
                    alpha: 0,
                    onComplete: function() {
                        e.destroy()
                    }
                }), setTimeout(function() {
                    t.game.camera.flash(16777215, 1e3), t.confetti.shoot(t.game.width / 2, t.hanger.getTorsoY(), 30), p.default.Instance.fx(FxEvent.HIGHSCORE), t.startScreen.visible = !0, t.game.physics.box2d.frameRate = 1 / 60
                }, 1e3)
            }, e.prototype.showHandTutorial = function() {
                this.handTutorial || 0 != this.isPlaying && 1 != this.isWinning && (this.handTutorial = new _.default(this.game), this.handTutorial.fixedToCamera = !0, this.game.add.existing(this.handTutorial))
            }, e.prototype.checkForLowFPSMode = function() {
                CANVAS_RENDERING
            }, e.prototype.revivalGameOver = function() {
                var t = this;
                if (1 != this.isWinning && 0 != this.isPlaying) {
                    this.revivals++, this.backBtn.visible = !1, this.scoreText.visible = !1, this.game.physics.box2d.frameRate = .001, this.isPlaying = !1, this.skip && (this.skip.visible = !1), this.continueScreen = new x.default(this.game, function() {
                        t.showRewardedAdToRevive()
                    }, function() {
                        t.gameOver()
                    }, this), this.game.add.existing(this.continueScreen), this.continueScreen.visible = !0;
                    clearTimeout(this.lowFPSModeTimeout)
                }
            }, e.prototype.showRewardedAdToRevive = function() {
                this.continueScreen.stop(), this.scoreText.visible = !0, this.doRevive()
            }, e.prototype.doRevive = function() {
                var t = this;
                this.level.makeSafe(this.reviveX), this.backBtn.visible = !0;
                var e = this.hanger;
                e.stopped = !0, this.hanger = new o.default(this.game, e.hangerScale, this.reviveX - 50, 600), this.level.hanger = this.hanger, this.hanger.stopped = !0, setTimeout(function() {
                    t.hanger.startBoost(), t.hanger.stopped = !1
                }, 200), ACTIVE_SKIN && this.hanger.setSkin(ACTIVE_SKIN), setTimeout(function() {
                    e.destroy()
                }, 1e3), this.hanger.ropeHitEffect.setColor(this.level.config.levelColor), this.isPlaying = !0, this.game.world.filters = null, this.continueScreen.destroy(), this.continueScreen = null, this.justRevived = !0, this.startTime = this.game.time.time, this.hanger.shield = 100
            }, e.prototype.startGame = function() {
                this.skip && (this.skip.visible = !0, TweenMax.from(this.skip.cameraOffset, .6, {
                    x: this.game.width + 200,
                    delay: 1
                }));
                p.default.Instance.fx(FxEvent.PRESS_BUTTON), this.hanger.minRopeLength = 2, this.hanger.shield = 100, this.startScreen.created = !1, this.startScreen.debugMenu && this.startScreen.debugMenu.hide(), 1 == NO_ADS && f.default.Instance.hideBanner(), this.startScreen.destroy(), TweenLite.to(this, 1, {
                    cameraOffset: this.game.camera.width / 3.5 - 25
                }), this.isPlaying = !0, this.progress.visible = !0, this.startTime = this.game.time.time, f.default.Instance.levelStart(), this.backBtn.visible = !0, TweenMax.from(this.backBtn, .25, {
                    alpha: 0,
                    delay: .5
                }), HIDE_UI && (this.scoreText.visible = !1, this.coinsIcon.visible = !1, this.coinsText.visible = !1, this.progress.visible = !1), this.hanger.startBoost(), this.game.input.onDown.add(this.onDown, this), this.game.input.onUp.add(this.onUp, this), this.spaceKey.onDown.add(this.onDown, this), this.spaceKey.onUp.add(this.onUp, this), this.hanger.drop()
            }, e.prototype.restartWin = function(t) {
                void 0 === t && (t = !1), this.winScreen && (this.winScreen.claimBtn.visible = !1, this.winScreen.claimText.visible = !1, this.winScreen.claimedDouble && TweenMax.to(this, .4, {
                    extraScore: 2 * Math.floor(this.extraScore)
                }), this.coinConfetti && this.coinConfetti && this.coinConfetti.claimAll()), this.game.time.events.add(1.75 * Phaser.Timer.SECOND, this.realRestart, this), this.autostartNext = t, p.default.Instance.fx(FxEvent.PRESS_BUTTON_RESTART), this.interstitialShownThisRound = !1
            }, e.prototype.restart = function(t) {
                void 0 === t && (t = !1), this.gameOverScreen && (this.gameOverScreen.okBtn.visible = !1), this.game.time.events.add(.4 * Phaser.Timer.SECOND, this.realRestart, this), this.autostartNext = t, p.default.Instance.fx(FxEvent.PRESS_BUTTON_RESTART), this.interstitialShownThisRound = !1
            }, e.prototype.realRestart = function() {
                clearTimeout(this.lowFPSModeTimeout), CANVAS_RENDERING || this.back.destroy(), this.level.destroy(), this.hanger.destroy(), this.scoreText.destroy(), this.progress.destroy(), this.highscoreText && (this.highscoreText.destroy(), this.highscoreText = null), this.gameOverScreen && this.gameOverScreen.destroy(), this.continueScreen && this.continueScreen.destroy(), this.winScreen && this.winScreen.destroy(), this.skip && (TweenMax.killTweensOf(this.skip), this.skip.destroy()), TweenMax.killTweensOf(this), this.game.state.restart(!0, !1)
            }, e.prototype.onDown = function() {
                this.handTutorial && (this.handTutorial.visible = !1, this.handTutorial.destroy(), this.handTutorial = null), this.hanger.isLocked || (0 == this.firstRope && (this.firstRope = !0), !0 === this.isPlaying && !1 === this.hanger.isHanging && (this.hanger.shoot(), f.default.Instance.impact()), this.justRevived && (this.justRevived = !1))
            }, e.prototype.onUp = function() {
                if (this.game.sound && this.game.sound.context && this.game.sound.context.resume(), !this.hanger.isStartBoost) {
                    !0 === this.isPlaying && !0 === this.hanger.isHanging && this.hanger.drop();
                    for (var t = 0; t < this.extraHangers.length; t++) this.extraHangers[t].drop()
                }
            }, e.prototype.preRender = function() {
                if (this.hanger.isLocked && this.game.time.time - this.startTime > 200 && (this.hanger.isLocked = !1), 1 == this.justRevived && (this.hanger.shield = 50), 1 == this.isPlaying && 0 == this.firstRope && !this.handTutorial && this.game.time.time - this.startTime > this.showTutorialTime && this.showHandTutorial(), this.hanger.isStartBoost && this.game.time.time - this.startTime > 5e3 && 0 == this.justRevived && this.hanger.endStartBoost(), this.lastFrameCoins !== f.default.Instance.statsCoins + this.hanger.coinsTaken) {
                    var t = 1;
                    Math.abs(this.lastFrameCoins - (f.default.Instance.statsCoins + this.hanger.coinsTaken)) > 10 && (t = 10), this.lastFrameCoins > f.default.Instance.statsCoins + this.hanger.coinsTaken ? this.lastFrameCoins = this.lastFrameCoins - t : this.lastFrameCoins < f.default.Instance.statsCoins + this.hanger.coinsTaken && (this.lastFrameCoins = this.lastFrameCoins + t), this.coinsText.text = "" + this.lastFrameCoins
                }
                1 == this.isWinning && (this.currentExtraScore = 5 * Math.floor((this.hanger.head.body.x + 124) / 248 - (this.level.goal.x - 248) / 248) + .5, this.extraScore != this.currentExtraScore && (TweenMax.killTweensOf(this.scoreGlow), this.scoreGlow.alpha = 1, TweenMax.to(this.scoreGlow, .2, {
                    alpha: 0,
                    yoyo: !0,
                    repeat: 1
                })), this.scoreText.text = "" + Math.floor(this.extraScore), this.currentExtraScore > 5 && (this.scoreGlow.visible = !0, this.scoreGlow.x = this.level.goal.x - 248 + 248 * this.currentExtraScore / 5), Math.abs(this.hanger.head.body.velocity.x) + Math.abs(this.hanger.head.body.velocity.y) < .5 && this.winDone(), this.game.time.totalElapsedSeconds() - this.winTime > 13 && this.winDone(), this.bestBubble && this.currentExtraScore > 5 * BEST_SCORE && (this.bestBubble.visible = !1)), !0 === this.isPlaying ? (this.hanger.idle && 0 == this.hanger.dead && 0 == this.isWinning && 0 == this.isWinningDone && (this.handTutorial || this.showHandTutorial()), this.isWinning ? (this.game.camera.x = this.game.camera.x + .75 * (this.hanger.head.x - this.cameraOffset - this.camera.x), this.level.updateLevel(this.hanger.head.body.x)) : (this.game.camera.x = this.game.camera.x + .25 * (this.hanger.lowerArmL.x - this.cameraOffset - this.camera.x), this.level.updateLevel(this.hanger.lowerArmL.body.x)), this.lastFrameScore !== this.level.scoreGatesPassed && (this.lastFrameScore = this.level.scoreGatesPassed, this.progress.updateScorePart(this.hanger.lowerArmL.x / this.level.goal.x)), this.progress.updateProgress(this.hanger.lowerArmL.x / this.level.goal.x), this.progress.updateComboScore(this.level.comboScore), !0 === this.hanger.dead && (this.reviveX = this.hanger.lowerArmL.x, 0 == this.revivals ? this.revivalGameOver() : this.gameOver()), this.hanger.lowerArmL.x > this.level.goal.x ? this.win() : this.level.goal.x - this.hanger.lowerArmL.x < 300 && this.hanger.boostTowardsGoal()) : this.game.camera.x = this.game.camera.x + .25 * (this.hanger.lowerArmL.x - this.cameraOffset - this.camera.x)
            }, e.prototype.switchSkinAndScale = function() {}, e.prototype.getImageCropped = function(t, e, i, s, n, r) {}, e.prototype.win = function() {
                if (!this.isWinning) {
                    if (this.hanger.head.body.angularDamping = 5, this.winTime = this.game.time.totalElapsedSeconds(), this.skip && (this.skip.visible = !1), e.showskiplevelNext = !1, this.hanger.onFire && this.hanger.resetOnFire(), this.backBtn.visible = !1, this.progress.visible = !1, this.isWinning = !0, this.scoreText.visible = !1, this.continueScreen && (this.continueScreen.destroy(), this.continueScreen = null), this.handTutorial && (this.handTutorial.visible = !1), TweenMax.to(this, 1, {
                            delay: 1,
                            cameraOffset: this.game.width / 2
                        }), p.default.Instance.fx(FxEvent.HIGHSCORE), this.game.input.onDown.remove(this.onDown, this), this.game.input.onUp.remove(this.onUp, this), this.spaceKey.onDown.remove(this.onDown, this), this.spaceKey.onUp.remove(this.onUp, this), this.scoreGlow = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.GoalGlow), this.scoreGlow.width = 248, this.scoreGlow.y = this.game.height - (500 + SAFE_TOP / 2), this.scoreGlow.visible = !1, this.scoreGlow.anchor.x = .6, this.game.world.sendToBack(this.scoreGlow), this.game.world.sendToBack(this.back), BEST_SCORE > 10) {
                        this.bestBubble = new Phaser.Group(this.game), this.bestBubble.fixedToCamera = !0, this.bestBubble.cameraOffset.x = this.game.width - 66, this.bestBubble.cameraOffset.y = this.game.height / 2 - 100;
                        var t = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Scorebubble);
                        t.anchor.set(.5), this.bestBubble.add(t);
                        var i = w.default.Instance.getBitmapText("lbl_best", 30, 100);
                        i.alpha = 0, i.anchor.set(.5), i.x = -15, i.y = -16, this.bestBubble.add(i);
                        var s = this.game.make.bitmapText(0, 0, Fonts.bitmapMain, (5 * BEST_SCORE).toString() + w.default.Instance.getText("unit_meter", !1), 30);
                        this.bestBubble.add(s), s.alpha = 0, s.anchor.set(.5), s.x = -15, s.y = 12, this.bestBubble.scale.set(.85), TweenMax.from(this.bestBubble.scale, 1, {
                            delay: 1,
                            x: 0,
                            y: 0,
                            ease: Elastic.easeOut
                        }), TweenMax.to(s, .2, {
                            alpha: 1,
                            delay: .5
                        }), TweenMax.to(i, .2, {
                            alpha: 1,
                            delay: .5
                        })
                    }
                    this.physics.box2d.gravity.y = 650, this.hanger.slowMotion(5, 800), this.game.camera.flash(16777215, 1e3, !0, 1), this.confetti.shoot(this.hanger.lowerArmL.x - this.game.camera.x, this.hanger.lowerArmL.y, 30, 20, 1), this.hanger.drop(), f.default.Instance.impact(), f.default.Instance.levelComplete()
                }
            }, e.prototype.winDone = function() {
                var t = this;
                1 != this.isWinningDone && (this.isWinningDone = !0, TweenMax.to(this, .4, {
                    extraScore: this.currentExtraScore
                }), this.scoreText.visible = !0, f.default.Instance.statsCoins = f.default.Instance.statsCoins + this.hanger.coinsTaken, this.hanger.coinsTaken = 0, KEYS >= 3 ? (console.log("CHESTSCREEN"), KEYS = 0, this.chestScreen = new d.default(this.game, function() {
                    t.chestScreen.visible = !1, t.chestScreen.destroy(), t.startWinProcess()
                }, this, this.confetti), this.game.add.existing(this.chestScreen), this.game.world.bringToTop(this.coinsIcon), this.game.world.bringToTop(this.coinsText)) : this.startWinProcess())
            }, e.prototype.startWinProcess = function() {
                var t = !1;
                if (LEVEL_INDEX % 5 == 0) {
                    t = !0;
                    var i = void 0;
                    for (var s in SKINS) SKINS[s].score && (SCORE < SKINS[s].score ? i || (i = s) : SKINS[s].score);
                    i && SCORE + this.currentExtraScore >= SKINS[i].score && (t = !1, e.giveRewardNext = !0)
                } else 1 == e.giveRewardNext && (e.giveRewardNext = !1, t = !0);
                if (LEVEL_INDEX += 1, f.default.Instance.saveData(), 1 == t) {
                    var n = "";
                    if (LEVEL_INDEX % 10 < 4) n = (50 * (Math.floor(4 * Math.random()) + 1)).toString();
                    else
                        for (var r = 0; r < SKINS_IN_REWARD.length; r++) {
                            s = SKINS_IN_REWARD[r];
                            "" == n && SKINS[s] && SKINS[s].locked && (n = s)
                        }
                    "" != n ? (this.unlockChestScreen = new T.default(this.game, n, this.chestRewardDone, this, this.confetti), this.game.add.existing(this.unlockChestScreen), this.scoreText.visible = !1) : this.startWinScreen()
                } else this.startWinScreen()
            }, e.prototype.chestRewardDone = function() {
                this.unlockChestScreen && (this.unlockChestScreen.visible = !1), this.startWinScreen()
            }, e.prototype.startWinScreen = function() {
                var t = this,
                    e = Math.floor((this.hanger.head.body.x + 124) / 248 - (this.level.goal.x - 248) / 248),
                    i = !1;
                e > BEST_SCORE && (BEST_SCORE > 0 && (i = !0), BEST_SCORE = e), this.winScreen = new u.default(this.game, this.restartWin, Math.floor(this.currentExtraScore), this, this.confetti, this.scoreText, i), this.game.add.existing(this.winScreen), this.winScreen.alpha = 0, this.scoreText.visible = !0, TweenMax.to(this.winScreen, .1, {
                    alpha: 1,
                    delay: 1.5
                }), TweenMax.to(this.scoreText.scale, .3, {
                    x: .6,
                    y: .6,
                    delay: 1.5
                }), this.scoreText.text.length < 3 ? TweenMax.to(this.scoreText.cameraOffset, .3, {
                    x: this.game.width / 2 + 25,
                    y: this.game.height / 2 - 125,
                    delay: 1.5
                }) : TweenMax.to(this.scoreText.cameraOffset, .3, {
                    x: this.game.width / 2 + 30,
                    y: this.game.height / 2 - 125,
                    delay: 1.5
                }), this.game.world.bringToTop(this.scoreText), setTimeout(function() {
                    TweenMax.to(t.scoreText.scale, .3, {
                        x: 1.3,
                        y: 1.3,
                        ease: Bounce.easeOut
                    }), t.scoreText.tint = 16710968;
                    var e = new m.default(t.game);
                    t.coinConfetti = e, e.shoot(t.hanger.head.x - t.game.camera.x, t.hanger.head.y + 20, Math.min(.5 * t.currentExtraScore, 40), 20, .1)
                }, 500)
            }, e.prototype.gameOver = function() {
                this.isWinning || (this.continueScreen && (this.continueScreen.destroy(), this.continueScreen = null), p.default.Instance.fx(FxEvent.GAME_OVER), this.backBtn.visible = !1, this.isPlaying = !1, this.game.input.onDown.remove(this.onDown, this), this.game.input.onUp.remove(this.onUp, this), this.spaceKey.onDown.remove(this.onDown, this), this.spaceKey.onUp.remove(this.onUp, this), this.endScore = this.level.scoreGatesPassed, this.gameOverScreen = new c.default(this.game, this.restart, null, this.hanger.coinsTaken, this, !1, null, this.endScore), this.game.add.existing(this.gameOverScreen), this.scoreText.fixedToCamera = !1, this.scoreText.y = -800, this.scoreText.x = 0, this.scoreText.visible = !1, f.default.Instance.statsCoins = f.default.Instance.statsCoins + this.hanger.coinsTaken, f.default.Instance.saveData(), this.hanger.coinsTaken = 0, this.gameOverScreen.addChild(this.scoreText), this.game.camera.shake(.02, 300), this.game.add.tween(this.scoreText).to({
                    y: -300
                }, 400, Phaser.Easing.Back.Out, !0, 500, 0), this.highscoreText && (this.highscoreText.visible = !1), f.default.Instance.levelFail(), e.showskiplevelNext = !0, e.firstGameOver = !1)
            }, e.prototype.render = function() {
                this.game.time.fps && (this.game.time.fps > this.maxFps && (this.maxFps = this.game.time.fps), FPSMETER ? (this.fpstext.text = "" + this.game.time.fps, this.fpstext.visible = !0) : this.fpstext.visible = !1), this.hanger.render()
            }, e.firstGameOver = !0, e.first = !0, e.showskiplevelNext = !1, e.giveRewardNext = !1, e
        }(Phaser.State);
    e.default = S
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s = function() {
        return function(t, e, i, s, n, r) {
            void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = !1), void 0 === r && (r = !1), this.ignoreLevelHeight = !1, this.force = !1, this.type = t, this.pos = e, this.x = i, this.y = s, this.ignoreLevelHeight = n, this.force = r
        }
    }();
    e.default = s
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s, n = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var s = e[i];
                    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(t, s.key, s)
                }
            }
            return function(e, i, s) {
                return i && t(e.prototype, i), s && t(e, s), e
            }
        }(),
        r = i(8),
        o = (s = r) && s.__esModule ? s : {
            default: s
        },
        a = i(9);
    var h = new Phaser.Point,
        l = {
            from: 0,
            to: 200,
            direction: "y",
            momentum: !1,
            snapping: !1,
            bouncing: !1,
            deceleration: .5,
            overflow: 20,
            snapStep: 10,
            emitMoving: !1,
            duration: 2,
            speedLimit: 3,
            flickTimeThreshold: 100,
            offsetThreshold: 30,
            acceleration: .5,
            accelerationT: 250,
            maxAcceleration: 4,
            time: {},
            multiplier: 1,
            swipeEnabled: !1,
            swipeThreshold: 5,
            swipeTimeThreshold: 250,
            minDuration: .5,
            addListeners: !0
        },
        c = function() {
            function t(e, i) {
                var s = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2],
                    n = arguments.length <= 3 || void 0 === arguments[3] ? {} : arguments[3];
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.game = e, this.clickObject = i, this.maskLimits = s, this.o = this.options = Object.assign({}, l, n), this._updateMinMax(), this.dispatchValues = {
                    step: 0,
                    total: 0,
                    percent: 0
                }, this.addListeners(), this.clickables = [], this.isDown = !1, this.isScrolling = !1, this.scrollObject = {}, this.init(), this.tweenScroll = this.game.add.tween(this.scrollObject).to({}, 0, Phaser.Easing.Quartic.Out), this.tweenScroll.onUpdateCallback(this.handleUpdate, this), this.tweenScroll.onComplete.add(this.handleComplete, this)
            }
            return n(t, [{
                key: "destroy",
                value: function() {
                    this.tweenScroll.stop(), this.removeListeners(), this.clickObject.destroy(), this.clickables = null, this.options = this.o = null, this.maskLimits = null, this.enabled = !1, this.game = null, this.dispatchValues = null, this.isDown = null, this.target = null, this.destroyed = !0
                }
            }, {
                key: "addListeners",
                value: function() {
                    this.events = {
                        onUpdate: new Phaser.Signal,
                        onInputUp: new Phaser.Signal,
                        onInputDown: new Phaser.Signal,
                        onInputMove: new Phaser.Signal,
                        onComplete: new Phaser.Signal,
                        onSwipe: new Phaser.Signal
                    }, this.o.addListeners && (this.clickObject.inputEnabled = !0, this.clickObject.events.onInputDown.add(this.handleDown, this), this.clickObject.events.onInputUp.add(this.handleUp, this))
                }
            }, {
                key: "removeListeners",
                value: function() {
                    this.o.addListeners && (this.clickObject.events.onInputDown.remove(this.handleDown, this), this.clickObject.events.onInputUp.remove(this.handleUp, this));
                    for (var t in this.events) this.events.hasOwnProperty(t) && this.events[t].dispose()
                }
            }, {
                key: "enable",
                value: function() {
                    this.enabled = !0
                }
            }, {
                key: "disable",
                value: function() {
                    this.enabled = !1
                }
            }, {
                key: "init",
                value: function() {
                    this.scrollObject[this.o.direction] = this.o.from, this.maxOffset = this.maskLimits[this.o.direction] * this.o.speedLimit, this.enable()
                }
            }, {
                key: "reset",
                value: function() {
                    this.tweenScroll.pause(), this.o.multiplier = 1, this.init()
                }
            }, {
                key: "setFromTo",
                value: function(t, e) {
                    this.o.from = t, this.o.to = e, this._updateMinMax()
                }
            }, {
                key: "isTweening",
                value: function() {
                    return this.tweenScroll.isRunning
                }
            }, {
                key: "registerClickables",
                value: function(t) {
                    this.clickables = t
                }
            }, {
                key: "handleDown",
                value: function(t, e) {
                    this.enabled && (this.isDown = !0, this.target = this.requested = this.scrollObject[this.o.direction], this.o.time.down = e.timeDown, this.o.addListeners && this.game.input.addMoveCallback(this.handleMove, this), this.isTweening() && this.o.time.down - this.o.time.up < this.o.accelerationT ? this.o.multiplier += this.o.acceleration : this.o.multiplier = 1, this.tweenScroll.stop(), this.tweenScroll.pendingDelete = !1, (0, a.dispatchClicks)(e, this.clickables, "onInputDown"), this.events.onInputDown.dispatch(t, e))
                }
            }, {
                key: "handleMove",
                value: function(t, e, i) {
                    this.enabled && (this.isScrolling = !0, h.set(e, i), this.diff = this.old - h[this.o.direction], this.diff = this._requestDiff(this.diff, this.target, this.min, this.max, this.o.overflow), this.target -= this.diff, this.old = h[this.o.direction], this.o.time.move = this.game.time.time, this.acc = Math.min(Math.abs(this.diff / 30), this.o.maxAcceleration), this.scrollObject[this.o.direction] = this.target, this.handleUpdate(), this.o.emitMoving && this.events.onInputMove.dispatch(t, e, i))
                }
            }, {
                key: "handleUp",
                value: function(t, e) {
                    this.isDown = !1, this.o.addListeners && this.game.input.deleteMoveCallback(this.handleMove, this), this.o.time.up = e.timeUp, this.o.time.up - this.o.time.down > this.o.accelerationT && (this.o.multiplier = 1);
                    var i = {
                        duration: 1,
                        target: this.target
                    };
                    this.o.bouncing || (i.duration = .01), !this.o.infinite && this.scrollObject[this.o.direction] > this.max ? (this.target = this.max, this.tweenTo(i.duration, this.target)) : !this.o.infinite && this.scrollObject[this.o.direction] < this.min ? (this.target = this.min, this.tweenTo(i.duration, this.target)) : (this._addMomentum(i), this._addSwiping(i, e), this._addSnapping(i), this._addLimits(i), this._calculateDuration(i), this.tweenTo(i.duration, i.target)), (0, a.dispatchClicks)(e, this.clickables, "onInputUp"), this.events.onInputUp.dispatch(t, e, a.dispatchClicks)
                }
            }, {
                key: "_addMomentum",
                value: function(t) {
                    if (!this.o.momentum) return t.target;
                    var e = Math.pow(this.acc, 2) * this.maskLimits[this.o.direction];
                    return e = Math.min(this.maxOffset, e), e = this.diff > 0 ? -this.o.multiplier * e : this.o.multiplier * e, this.o.time.up - this.o.time.move < this.o.flickTimeThreshold && 0 !== e && Math.abs(e) > this.o.offsetThreshold && (t.target += e), t
                }
            }, {
                key: "_addSwiping",
                value: function(t, e) {
                    var i = Math.abs(this.down - this.current);
                    if (this.o.swipeEnabled && this.o.time.up - this.o.time.down < this.o.swipeTimeThreshold && i > this.o.swipeThreshold) {
                        var s = e[this.o.direction] < this.down ? "forward" : "backward";
                        "forward" == s ? t.target -= this.o.snapStep / 2 : t.target += this.o.snapStep / 2, this.events.onSwipe.dispatch(s)
                    }
                    return t
                }
            }, {
                key: "_addSnapping",
                value: function(t) {
                    return this.o.snapping ? (t.target = o.default.nearestMultiple(t.target, this.o.snapStep), t) : t
                }
            }, {
                key: "_addLimits",
                value: function(t) {
                    return this.o.infinite ? t : (t.target = Math.max(t.target, this.min), t.target = Math.min(t.target, this.max), t)
                }
            }, {
                key: "_calculateDuration",
                value: function(t) {
                    var e = Math.abs(t.target - this.scrollObject[this.o.direction]);
                    return t.duration = this.o.duration * e / this.maxOffset, t.duration = Math.max(this.o.minDuration, t.duration), t
                }
            }, {
                key: "_requestDiff",
                value: function(t, e, i, s, n) {
                    if (this.o.infinite) return t;
                    return e > s ? t *= (s + n - e) / n : e < i && (t *= -(i - n - e) / n), t
                }
            }, {
                key: "tweenToSnap",
                value: function(t, e) {
                    var i = this.o.from - this.o.snapStep * e;
                    this.tweenTo(t, i)
                }
            }, {
                key: "tweenTo",
                value: function(t, e) {
                    if (0 == t) return this.setTo(e);
                    var i, s, n, r = (i = {}, s = this.o.direction, n = e, s in i ? Object.defineProperty(i, s, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : i[s] = n, i);
                    this.tweenScroll.onUpdateCallback(this.handleUpdate, this), this.tweenScroll.onComplete.add(this.handleComplete, this), this.tweenScroll.updateTweenData("vEnd", r, -1), this.tweenScroll.updateTweenData("duration", 1e3 * t, -1), this.tweenScroll.updateTweenData("percent ", 0, -1), this.tweenScroll.start()
                }
            }, {
                key: "cancel",
                value: function() {
                    this.isDown = !1
                }
            }, {
                key: "setTo",
                value: function(t) {
                    this.scrollObject[this.o.direction] = t, this.tweenScroll.stop(), this.handleUpdate(), this.handleComplete()
                }
            }, {
                key: "handleUpdate",
                value: function() {
                    if (this.enabled) {
                        this.o.infinite ? this.dispatchValues.total = Phaser.Math.wrap(this.scrollObject[this.o.direction], this.min, this.max) : this.dispatchValues.total = this.scrollObject[this.o.direction];
                        var t = this.dispatchValues.total - this.previousTotal;
                        t < -this.length / 2 ? t += this.length : t > this.length / 2 && (t -= this.length), this.dispatchValues.step = t, this.dispatchValues.percent = o.default.percentageBetween2(this.dispatchValues.total, this.o.from, this.o.to), this.events.onUpdate.dispatch(this.dispatchValues), this.previousTotal = this.dispatchValues.total
                    }
                }
            }, {
                key: "handleComplete",
                value: function() {
                    this.enabled && (this.isScrolling = !1, this.o.multiplier = 1, this.events.onComplete.dispatch())
                }
            }, {
                key: "_updateMinMax",
                value: function() {
                    this.min = Math.min(this.o.from, this.o.to), this.max = Math.max(this.o.from, this.o.to), this.length = Math.abs(this.max - this.min), this.previousTotal = this.o.from
                }
            }]), t
        }();
    e.default = c
}, function(t, e) {
    var i;
    i = function() {
        return this
    }();
    try {
        i = i || Function("return this")() || (0, eval)("this")
    } catch (t) {
        "object" == typeof window && (i = window)
    }
    t.exports = i
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s, n, r = i(0);
    (n = s = e.ScreenOrientation || (e.ScreenOrientation = {}))[n.PORTRAIT = 0] = "PORTRAIT", n[n.LANDSCAPE = 1] = "LANDSCAPE";
    var o = function() {
        return function() {}
    }();
    e.ScreenMetrics = o;
    var a = function() {
        function t() {}
        return t.AddBitmapFontAddMethod = function() {
            Phaser.Cache.prototype.addBitmapFontFromImage = function(t, e, i, s, n, r, o) {
                var a = this.getImage(i, !0),
                    h = {
                        url: e,
                        data: a.data,
                        font: null,
                        base: a.base
                    };
                void 0 === r && (r = 0), void 0 === o && (o = 0), h.font = "json" === n ? Phaser.LoaderParser.jsonBitmapFont(s, h.base, r, o, null, 1) : Phaser.LoaderParser.xmlBitmapFont(s, h.base, r, o, null, 1), this._cache.bitmapFont[t] = h, this._resolveURL(e, h)
            }
        }, t.createShadowSprite = function(t, e, i) {
            void 0 === i && (i = "shadow");
            var s = e.frameName;
            e.frameName == r.Atlases.SpritesheetsMain.Frames.Rect && (s = r.Atlases.SpritesheetsMain.Frames.Rect16), e.frameName == r.Atlases.SpritesheetsMain.Frames.Coin && (s = r.Atlases.SpritesheetsMain.Frames.Circle16);
            var n = t.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), s);
            return n.width = e.width, n.height = e.height, n.anchor.x = e.anchor.x, n.anchor.y = e.anchor.y, n.tint = SHADOW_COLOR, n
        }, t
    }();
    e.PhaserUtils = a;
    var h = function() {
        function t() {}
        return t.calculateScreenMetrics = function(t, e, i, n, r) {
            void 0 === i && (i = s.LANDSCAPE), this.screenMetrics = new o, this.screenMetrics.windowWidth = window.innerWidth, this.screenMetrics.windowHeight = window.innerHeight, this.screenMetrics.defaultGameWidth = t, this.screenMetrics.defaultGameHeight = e;
            var a = this.screenMetrics.windowWidth < this.screenMetrics.windowHeight && i === s.LANDSCAPE,
                h = this.screenMetrics.windowHeight < this.screenMetrics.windowWidth && i === s.PORTRAIT;
            (a || h) && (l = [this.screenMetrics.windowHeight, this.screenMetrics.windowWidth], this.screenMetrics.windowWidth = l[0], this.screenMetrics.windowHeight = l[1]), n && r ? (this.screenMetrics.maxGameWidth = n, this.screenMetrics.maxGameHeight = r) : i === s.LANDSCAPE ? (this.screenMetrics.maxGameWidth = Math.round(1.11 * this.screenMetrics.defaultGameWidth), this.screenMetrics.maxGameHeight = Math.round(1.2 * this.screenMetrics.defaultGameHeight)) : (this.screenMetrics.maxGameWidth = Math.round(1.2 * this.screenMetrics.defaultGameWidth), this.screenMetrics.maxGameHeight = Math.round(1.11 * this.screenMetrics.defaultGameHeight));
            var l, c = i === s.LANDSCAPE ? 1.6 : .625,
                u = this.screenMetrics.windowWidth / this.screenMetrics.windowHeight;
            return u > c ? (this.screenMetrics.gameHeight = this.screenMetrics.defaultGameHeight, this.screenMetrics.gameWidth = 2 * Math.ceil(this.screenMetrics.gameHeight * u * .5), this.screenMetrics.gameWidth = Math.min(this.screenMetrics.gameWidth, this.screenMetrics.maxGameWidth), this.screenMetrics.offsetX = .5 * (this.screenMetrics.gameWidth - this.screenMetrics.defaultGameWidth), this.screenMetrics.offsetY = 0) : (this.screenMetrics.gameWidth = this.screenMetrics.defaultGameWidth, this.screenMetrics.gameHeight = 2 * Math.ceil(this.screenMetrics.gameWidth / u * .5), this.screenMetrics.gameHeight = Math.min(this.screenMetrics.gameHeight, this.screenMetrics.maxGameHeight), this.screenMetrics.offsetX = 0, this.screenMetrics.offsetY = .5 * (this.screenMetrics.gameHeight - this.screenMetrics.defaultGameHeight)), this.screenMetrics.scaleX = this.screenMetrics.windowWidth / this.screenMetrics.gameWidth, this.screenMetrics.scaleY = this.screenMetrics.windowHeight / this.screenMetrics.gameHeight, this.screenMetrics
        }, t
    }();
    e.ScreenUtils = h;
    var l = function() {
        function t() {}
        return t.toCamelCase = function(t) {
            return t.replace(/[^A-Za-z0-9]/g, " ").replace(/^\w|[A-Z]|\b\w|\s+/g, function(t, e) {
                return 0 == +t || "-" === t || "." === t ? "" : 0 === e ? t.toLowerCase() : t.toUpperCase()
            })
        }, t.toPascalCase = function(e) {
            var i = t.toCamelCase(e);
            return i[0].toUpperCase() + i.substr(1)
        }, t
    }();
    e.StringUtils = l
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = function(t) {
        function e(e, i, s, n, r, o, a, h) {
            void 0 === i && (i = 6), void 0 === s && (s = 2 * Math.PI), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === o && (o = !1), void 0 === a && (a = Colors.yellow), void 0 === h && (h = 5);
            var l = t.call(this, e) || this;
            l.extraX = 0, l.noDelay = !1, l.angleOffset = 0, l.scaleValue = 5, l.noDelay = o, l.extraX = r, l.spawnAngle = s, l.angleOffset = n, l.parts = new Array, l.scaleValue = h;
            for (var c = 0; c < i; c++) {
                var u = l.createCircle(1, a);
                l.parts.push(u), l.addChild(u)
            }
            return l
        }
        return n(e, t), e.prototype.play = function() {
            var t;
            this.visible = !0, this.renderable = !0;
            for (var e = 0; e < this.parts.length; e++) {
                t = this.parts[e], this.resetPart(t);
                var i = .22 * Math.random();
                1 == this.noDelay && (i = 0);
                var s = e * this.spawnAngle / this.parts.length + (.2 * Math.random() - .1) - this.angleOffset,
                    n = (100 + 20 * Math.random()) * Math.cos(s) + this.extraX,
                    r = (100 + 20 * Math.random()) * Math.sin(s);
                TweenLite.to(t, 1.3, {
                    delay: i,
                    x: n,
                    y: r,
                    ease: Cubic.easeOut,
                    onCompleteScope: this,
                    onComplete: function() {
                        this.visible = !1, this.renderable = !1
                    }
                }), TweenLite.to(t.scale, 1.3, {
                    delay: i,
                    x: 0,
                    y: 0,
                    ease: Cubic.easeOut
                })
            }
        }, e.prototype.resetPart = function(t) {
            t.x = 0, t.y = 0, t.scale.x = (.35 + .15 * Math.random()) * this.scaleValue, t.scale.y = (.35 + .15 * Math.random()) * this.scaleValue, t.rotation = 0, t.alpha = 1, t.visible = !0, TweenLite.killTweensOf(t), TweenLite.killTweensOf(t.scale)
        }, e.prototype.setTint = function(t) {
            for (var e = 0; e < this.parts.length; e++) this.parts[e].tint = t
        }, e.prototype.createCircle = function(t, e) {
            var i = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Circle16);
            return i.width = t, i.height = t, i.anchor.set(.5), i.tint = e, i
        }, e
    }(Phaser.Group);
    e.default = o
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = function(t) {
        function e(e, i) {
            var s = t.call(this, e) || this;
            return s.camera = i, s.fixedToCamera = !0, s.layers = [], s.initLayers(), s
        }
        return n(e, t), e.prototype.initLayers = function() {
            this.game.height, SAFE_TOP;
            null != GRADIENT_BACK && this.showGradientInstead()
        }, e.prototype.showGradientInstead = function() {
            for (var t = 0; t < this.layers.length; t++) this.layers[t].visible = !1;
            this.gradientOver && (this.removeChild(this.gradientOver), this.gradientOver.kill()), this.gradientOver = this.game.add.sprite(0, 0, GRADIENT_BACK), this.gradientOver.width = this.game.width, this.gradientOver.height = this.game.height, this.addChild(this.gradientOver)
        }, e.prototype.addLayer = function(t, e, i, s, n, r, o) {
            void 0 === r && (r = 1), void 0 === o && (o = null);
            var a = this.game.add.sprite(0, 0, t, e);
            a.speed = n, this.layers.push(a), this.addChild(a), a.alpha = r, a.anchor.set(0, 1), a.y = s, a.off = 0, a.autoCull = !0, (a = this.game.add.sprite(0, 0, t, e)).speed = n, this.layers.push(a), this.addChild(a), a.alpha = r, a.anchor.set(0, 1), a.y = s, a.off = a.width, a.autoCull = !0
        }, e.prototype.updateDebugTint = function() {
            0 != OVERRIDE_COLORS.back && (this.gradientOver.tint = OVERRIDE_COLORS.back)
        }, e.prototype.update = function() {}, e
    }(Phaser.Group);
    e.default = r
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0),
        o = i(86),
        a = i(87);
    i(2);
    var h = i(6),
        l = i(15),
        c = i(88),
        u = i(5),
        d = i(5),
        p = i(11),
        f = i(97),
        g = i(4),
        m = function(t) {
            function e(e, i) {
                var s = t.call(this, e) || this;
                return s.scoreGatesPassed = 0, s.maxX = 0, s.blockSize = 248, s.startPos = -s.blockSize, s.tint = 2130808, s.blockCount = 8, s.maxBlockSeen = 1, s.blocksPerColor = 20, s.blockMax = 0, s.blockMin = 0, s.maxBlockVariation = 0, s.blockRandomCount = 0, s.comboScore = 0, s.initedEndZone = !1, s.goalCount = 0, s.endBlockCount = 0, s.topBlocks = [], s.bottomBlocks = [], s.blockMin = e.world.centerY - 840, s.blockMax = e.world.centerY + 850, s.config = i, s.comboScore = 0, s.endBlockCount = 0, s
            }
            return n(e, t), e.prototype.create = function() {
                var t = this.game,
                    e = this.startPos;
                this.backLayer = new Phaser.Group(this.game, this), this.levelLayer = new Phaser.Group(this.game, this), this.frontLayer = new Phaser.Group(this.game, this), this.bitmapTextLayer = new Phaser.Group(this.game, this), this.dynamicTextLayer = new Phaser.Group(this.game, this);
                this.config.eventPositions.push(new p.default(d.EventType.BOOST, 4 * this.config.length - 1, 50, -420, !0, !0)), this.config.eventPositions.push(new p.default(d.EventType.BOOST, 4 * this.config.length - 1, 50, -270, !0, !0)), this.config.eventPositions.push(new p.default(d.EventType.BOOST, 4 * this.config.length - 1, 50, -120, !0, !0)), this.config.eventPositions.push(new p.default(d.EventType.BOOST, 4 * this.config.length - 1, 50, 30, !0, !0)), this.config.eventPositions.push(new p.default(d.EventType.BOOST, 4 * this.config.length - 1, 50, 180, !0, !0)), this.config.eventPositions.push(new p.default(d.EventType.BOOST, 4 * this.config.length - 1, 50, 330, !0, !0));
                var i = 0;
                if (LEVEL_INDEX > 1 && (i = Math.floor(9 * Math.random() + 4), this.config.eventPositions.push(new p.default(d.EventType.SPRING, 4 * this.config.length + i, 0, 350, !0, !0))), LEVEL_INDEX > 6) {
                    var s = Math.floor(7 * Math.random() + 2);
                    this.config.eventPositions.push(new p.default(d.EventType.SPRING, 4 * this.config.length + i + Math.floor(7 * Math.random() + 2), 0, 350, !0, !0)), this.config.eventPositions.push(new p.default(d.EventType.SPRING, 4 * this.config.length + i + s + Math.floor(10 * Math.random() + 2), 0, 350, !0, !0))
                }
                this.events = new u.default(this.game, this.config.eventPositions, this.frontLayer, this.backLayer, this.config);
                for (var n = 0; n < this.blockCount; n++) {
                    e += this.blockSize;
                    var h = r.Atlases.SpritesheetsMain.Frames.Block1;
                    GROUNDPATTERNS || (h = r.Atlases.SpritesheetsMain.Frames.BlockNoPattern), (g = this.game.add.sprite(e, this.blockMin + this.config.getTopBlockPos(), r.Atlases.SpritesheetsMain.getName(), h)).height = 700, g.width = 256, t.physics.box2d.enable(g), g.body.static = !0, g.tint = this.config.levelColor, g.body.level = !0, g.autoCull = !0, g.body.setCollisionCategory(2), this.topBlocks.push(g), this.levelLayer.addChild(g), g.body.setCollisionCategory(HangerCollisionGroups.level), 1 === n && (g.body.y = -120)
                }
                e = this.startPos;
                for (var f = 0; f < this.blockCount; f++) {
                    e += this.blockSize;
                    var g;
                    h = r.Atlases.SpritesheetsMain.Frames.Block1;
                    GROUNDPATTERNS || (h = r.Atlases.SpritesheetsMain.Frames.BlockNoPattern), (g = this.game.add.sprite(e, this.blockMax + this.config.getBottomBlockPos(), r.Atlases.SpritesheetsMain.getName(), h)).height = 768, g.width = 256, g.autoCull = !0, t.physics.box2d.enable(g), g.body.static = !0, g.body.level = !0, g.tint = this.config.levelColor, g.body.setCollisionCategory(HangerCollisionGroups.level), this.bottomBlocks.push(g), this.levelLayer.addChild(g)
                }
                for (var m = 0; m < this.bottomBlocks.length; m++) {
                    var y = this.bottomBlocks[m],
                        v = this.game.make.sprite(y.x - y.width / 2, y.y - y.height / 2 - 6, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Grass);
                    y.topBlock = v, v.tint = this.config.grassColor, this.levelLayer.addChild(v), v.visible = !1, GRASS && (v.visible = !0), this.maxBlockSeen = Math.max(Math.floor(m), this.maxBlockSeen), this.events.update(this.startPos, this.maxBlockSeen)
                }
                this.scoreGates = [];
                for (var x = 0; x < 2; x++) {
                    this.scoreGate = new o.default(this.game), this.scoreGate.x = 4 * this.blockSize * (this.scoreGatesPassed + 1 + x);
                    var b = 500 + this.config.getBottomBlockPosAt(this.scoreGate.x / this.blockSize) - 40;
                    b > this.game.height && (b = this.game.height / 2);
                    var _ = -500 + this.config.getTopBlockPosAt(this.scoreGate.x / this.blockSize) + 20;
                    this.scoreGate.place((_ + b) / 2), this.addChild(this.scoreGate), this.sendToBack(this.scoreGate), this.scoreGate.setNumberAtFloor(), this.scoreGates.push(this.scoreGate)
                }
                this.scoreGate = this.scoreGates[0], this.goal = new c.default(this.game, 4 * this.blockSize * this.config.length), this.game.add.existing(this.goal), this.backLayer.addChild(this.goal), this.backLayer.sendToBack(this.goal), this.coin = new a.default(this.game, 500, 300), this.placeCoin(300 * Math.random() + 2e3, this.coin), this.frontLayer.addChild(this.coin), this.frontLayer.sendToBack(this.coin), CANVAS_RENDERING || (this.scoreEffect = new l.default(this.game, 5, Math.PI + .1, .5 * Math.PI, 300, !0, Colors.white, 8), this.frontLayer.addChild(this.scoreEffect)), this.maxX = this.blockSize * this.blockCount + this.startPos
            }, e.prototype.makeSafe = function(t) {}, e.prototype.updateColor = function() {
                if (0 != OVERRIDE_COLORS.level) {
                    this.config.levelColor = OVERRIDE_COLORS.level;
                    for (var t = 0, e = this.topBlocks; t < e.length; t++) {
                        e[t].tint = OVERRIDE_COLORS.level
                    }
                    for (var i = 0, s = this.bottomBlocks; i < s.length; i++) {
                        s[i].tint = OVERRIDE_COLORS.level
                    }
                }
            }, e.prototype.addBall = function(t) {
                var e = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Circle);
                e.width = 48, e.height = 48, e.anchor.set(.5), this.game.physics.box2d.enable(e), e.body.setCircle(24), e.body.collideWorldBounds = !1, e.body.x = t + 100 * Math.random() - 50 + 50, e.body.y = 500, e.body.friction = 1.5, e.body.mass = .02, this.addChild(e), e.tint = 16730843
            }, e.prototype.updateLevel = function(t) {
                if (this.maxX - t < 4 * this.blockSize) {
                    var e = this.wrapBlock(this.topBlocks);
                    e.body.y = this.blockMin + this.config.getTopBlockPos();
                    var i = this.wrapBlock(this.bottomBlocks);
                    if (i.body.y = this.blockMax + this.config.getBottomBlockPos(), this.maxX = this.maxX + this.blockSize, i.body.y > this.game.height + 350 && (i.body.y = 2500), i.body.x >= this.goal.x && (i.body.y = this.blockMax - 110, i.body.restitution = .2, i.body.friction = 1.5, this.goalCount++, this.addGoalNumberToBlock(i.body.x, i.body.y - 240), this.initedEndZone || this.initEndZone(i.body.x), this.addDecorationToBlock(i)), i.body.x >= this.goal.x - 248 && (i.body.y = Math.min(this.blockMax - 110, i.body.y)), e.body.x >= this.goal.x && (e.body.y = this.blockMin - 1e3), null != i.topBlock) {
                        var s = i.topBlock;
                        s.x = i.body.x - i.width / 2, s.y = i.body.y - i.height / 2 - 5 - 2 * Math.random()
                    }
                }
                if (t > this.scoreGate.x && !1 === this.scoreGate.passed) {
                    h.default.Instance.fx(FxEvent.SCORE);
                    var n = Math.abs(this.scoreGate.y + this.game.world.height / 2 - this.hanger.getTorsoY()),
                        r = Colors.white,
                        o = void 0;
                    if (this.scoreGate.x != this.goal.x)
                        if (n <= 175) h.default.Instance.showMessage(g.default.Instance.getText("lbl_perfect"), 190 + SAFE_TOP, !1, 1), r = Colors.perfectGreen, o = !0, this.hanger.onFire || this.comboScore <= 3 && this.comboScore++;
                        else {
                            var a = [g.default.Instance.getText("lbl_great"), g.default.Instance.getText("lbl_ok"), g.default.Instance.getText("lbl_nice")];
                            h.default.Instance.showMessage(a[Math.floor(Math.random() * a.length)], 190 + SAFE_TOP, !1, 1), this.comboScore = 0
                        } this.scoreGate.hit(o), this.scoreGate.passed = !0, this.scoreGatesPassed++, this.scoreEffect && (this.scoreEffect.x = this.scoreGate.x, this.scoreEffect.y = this.hanger.lowerArmL.y, this.scoreEffect.setTint(r), this.scoreEffect.play()), this.game.camera.flash(16777215, 500, !1, .5), this.hanger.score = this.scoreGatesPassed
                }
                if (t > this.scoreGate.x + 800 / 4) {
                    this.scoreGate = this.scoreGates[this.scoreGatesPassed % this.scoreGates.length], this.scoreGate.x = 4 * this.blockSize * (this.scoreGatesPassed + 1), TweenMax.killTweensOf(this.scoreGate), this.scoreGate.line.alpha = 1, this.scoreGate.passed = !1;
                    this.scoreGatesPassed;
                    var l = 500 + this.config.getBottomBlockPosAt(this.scoreGate.x / this.blockSize) - 40;
                    l > 500 && (l = 500 / 2);
                    var c = -500 + this.config.getTopBlockPosAt(this.scoreGate.x / this.blockSize) + 20;
                    this.scoreGate.place((c + l) / 2), this.scoreGate.x > this.goal.x && (this.scoreGate.passed = !0, this.scoreGate.visible = !1)
                }
                if (Math.floor(t / this.blockSize) > this.maxBlockSeen && 100 * Math.random() > 25 - this.scoreGatesPassed && this.coin.x - t < -700 && this.placeCoin(t, this.coin), this.scoreGatesPassed >= 30)
                    for (var u = 0, d = this.bottomBlocks; u < d.length; u++) {
                        var p = d[u];
                        p.body.y = p.body.y + 4 * Math.sin(p.body.x % 500 + .004 * this.game.time.time), p.topBlock && (p.topBlock.y = p.body.y - p.height / 2 - 6)
                    }
                this.maxBlockSeen = Math.max(Math.round(t / this.blockSize + (this.blockCount - 1)), this.maxBlockSeen), this.events.update(t, this.maxBlockSeen), this.coin.update()
            }, e.prototype.initEndZone = function(t) {
                this.initedEndZone = !0;
                for (var e = 0; e < 3; e++) {
                    var i = new f.default(this.game, t + 2 * e * 248 + 248, this.game.height / 2 - 150 - 400 * Math.random());
                    this.game.add.existing(i), this.game.world.sendToBack(i)
                }
            }, e.prototype.addDecorationToBlock = function(t) {
                this.endBlockCount++;
                var e = Math.min(3, Math.floor(this.endBlockCount / 13)),
                    i = ENDCOLORS[e];
                if (t.tint = i.ground, t.topBlock && (-1 != i.grass ? (t.topBlock.visible = !0, t.topBlock.tint = i.grass, t.topBlock.alpha = 0, TweenMax.to(t.topBlock, .1, {
                        alpha: 1,
                        delay: .2
                    })) : t.topBlock.visible = !1), t.tint = i.ground, this.endBlockCount > 1 && this.endBlockCount % 3 == 1 && i.sprite) {
                    var s = this.game.make.sprite(t.body.x, 0, r.Atlases.SpritesheetsMain.getName(), i.sprite);
                    s.alpha = 0, s.anchor.set(.5, 1), s.y = t.body.y - t.height / 2, TweenMax.to(s, .1, {
                        alpha: .5,
                        delay: .2
                    }), this.backLayer.add(s), this.backLayer.sendToBack(s)
                }
                if (this.endBlockCount == BEST_SCORE) {
                    var n = this.game.make.sprite(t.body.x, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Bestsign);
                    n.anchor.set(.5, 1), n.y = t.body.y - t.height / 2 + 2, TweenMax.to(n, .1, {
                        alpha: 1,
                        delay: .2
                    });
                    var o = g.default.Instance.getBitmapText("lbl_best", 40, 135);
                    o.anchor.set(.5), o.x = t.body.x - 4, o.y = n.y - 90, o.alpha = 0, TweenMax.to(o, .1, {
                        alpha: 1,
                        delay: .2
                    }), this.backLayer.add(n), this.backLayer.add(o)
                }
            }, e.prototype.addGoalNumberToBlock = function(t, e) {
                var i = Math.ceil((t - this.goal.x + 248) / 248 * 5);
                i % 5 != 0 && (i -= i % 5), e -= 20;
                var s = g.default.Instance.getBitmapText("unit_meter", 52, -1, null, !1);
                s.y = e - 6, s.x = t, s.alpha = 0, TweenMax.to(s, .5, {
                    alpha: 1
                }), s.anchor.set(.5, 1), this.addChild(s);
                var n = this.game.make.bitmapText(t - 20, e, Fonts.bitmapMain, "" + i, 75);
                n.alpha = 0, TweenMax.to(n, .5, {
                    alpha: 1
                }), n.anchor.set(.5, 1), this.addChild(n), s.x = n.x + n.width / 2 + 20, s.width > 40 && (n.x = n.x - (s.width - 40) / 2), n.text.length
            }, e.prototype.wrapBlock = function(t) {
                var e = t.shift();
                return e.body.x = this.maxX + this.blockSize, t.push(e), e
            }, e.prototype.placeCoin = function(t, e) {
                this.hanger && this.hanger.coinsTaken > 0 || (e.place(t + 600 + 500 * Math.random(), this.game.world.centerY + 300 * Math.random() - 150), e.visible = !0, e.body.x > this.goal.x + 20 && (e.body.y = -1e3, e.visible = !1), this.goal.x - e.body.x > 0 && this.goal.x - e.body.x < 400 && (this.coin.body.x = this.coin.body.x - 410), LEVEL_INDEX < 2 && (e.visible = !1, e.body.y = -1e3))
            }, e.prototype.destroy = function() {
                t.prototype.destroy.call(this)
            }, e.prototype.update = function() {}, e
        }(Phaser.Group);
    e.default = m
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    e.default = {
        AUTO_DETECT_THRESHOLD: 8
    }
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var s = e[i];
                    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(t, s.key, s)
                }
            }
            return function(e, i, s) {
                return i && t(e.prototype, i), s && t(e, s), e
            }
        }(),
        n = a(i(20)),
        r = a(i(21)),
        o = i(9);

    function a(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    var h = {
            direction: "y",
            autocull: !0,
            momentum: !0,
            bouncing: !0,
            snapping: !1,
            overflow: 100,
            padding: 10,
            searchForClicks: !1
        },
        l = function(t) {
            function e(t, i, s) {
                var n = arguments.length <= 3 || void 0 === arguments[3] ? {} : arguments[3];
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, e);
                var a = function(t, e) {
                    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !e || "object" != typeof e && "function" != typeof e ? t : e
                }(this, Object.getPrototypeOf(e).call(this, t, i, (0, o.parseBounds)(s), Object.assign({}, h, n)));
                return a.scroller = new r.default(a.game, a._addMask(s), Object.assign({
                    from: 0,
                    to: 0
                }, a.options)), a.scroller.events.onUpdate.add(function(t) {
                    a._setPosition(t.total)
                }), a.events.onAdded.add(function(t) {
                    var e = Math.min(-t, 0);
                    a.scroller.setFromTo(0, e), a.options.searchForClicks && a.scroller.registerClickables(a.items)
                }), a
            }
            return function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }(e, n.default), s(e, [{
                key: "destroy",
                value: function() {
                    this.scroller.destroy(), this.scroller = null,
                        function t(e, i, s) {
                            null === e && (e = Function.prototype);
                            var n = Object.getOwnPropertyDescriptor(e, i);
                            if (void 0 === n) {
                                var r = Object.getPrototypeOf(e);
                                return null === r ? void 0 : t(r, i, s)
                            }
                            if ("value" in n) return n.value;
                            var o = n.get;
                            return void 0 !== o ? o.call(s) : void 0
                        }(Object.getPrototypeOf(e.prototype), "destroy", this).call(this)
                }
            }, {
                key: "reset",
                value: function() {
                    this._setPosition(0), this.scroller.reset()
                }
            }]), e
        }();
    e.default = l
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var s = e[i];
                    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(t, s.key, s)
                }
            }
            return function(e, i, s) {
                return i && t(e.prototype, i), s && t(e, s), e
            }
        }(),
        n = i(9);
    var r = {
            direction: "y",
            autocull: !0,
            padding: 10
        },
        o = function() {
            function t(e, i, s) {
                var n = arguments.length <= 3 || void 0 === arguments[3] ? {} : arguments[3];
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.game = e, this.parent = i, this.bounds = s, this.o = this.options = Object.assign({}, r, n), this.items = [], "y" == this.o.direction ? this.p = {
                    xy: "y",
                    wh: "height"
                } : this.p = {
                    xy: "x",
                    wh: "width"
                }, this.grp = this.game.add.group(i), this.grp.position.set(s.x, s.y), this.events = {
                    onAdded: new Phaser.Signal
                }, this.position = 0, this.grp.mask = this._addMask(s)
            }
            return s(t, [{
                key: "add",
                value: function(t) {
                    this.items.push(t);
                    var e = 0;
                    if (this.grp.children.length > 0) {
                        var i = this.grp.getChildAt(this.grp.children.length - 1);
                        e = i[this.p.xy] + (0, n.getWidthOrHeight)(i, this.p.wh) + this.o.padding
                    }
                    return t[this.p.xy] = e, this.grp.addChild(t), this.length = e + t[this.p.wh], this.events.onAdded.dispatch(this.length - this.bounds[this.p.wh]), t
                }
            }, {
                key: "addMultiple",
                value: function() {
                    for (var t = arguments.length, e = Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                    e.forEach(this.add, this)
                }
            }, {
                key: "remove",
                value: function(t) {
                    this.grp.removeChild(t);
                    var e = this.items.indexOf(t);
                    if (-1 != e) return this.items.splice(e, 1), t
                }
            }, {
                key: "destroy",
                value: function() {
                    this.events.onAdded.dispose(), this.events = null, this.grp.destroy(), this.grp = null, this.game = null, this.parent = null, this.items = null
                }
            }, {
                key: "removeAll",
                value: function() {
                    this.grp.removeAll(), this.items = []
                }
            }, {
                key: "cull",
                value: function() {
                    for (var t = 0; t < this.items.length; t++) {
                        var e = this.items[t];
                        e.visible = !0, e[this.p.xy] + (0, n.getWidthOrHeight)(e, this.p.wh) + this.grp[this.p.xy] < this.bounds[this.p.xy] ? e.visible = !1 : e[this.p.xy] + this.grp[this.p.xy] > this.bounds[this.p.xy] + this.bounds[this.p.wh] && (e.visible = !1)
                    }
                }
            }, {
                key: "getPositionByItemIndex",
                value: function(t) {
                    return -this.items[t][this.p.xy]
                }
            }, {
                key: "setPosition",
                value: function(t) {
                    this.moveToPosition(t)
                }
            }, {
                key: "moveToPosition",
                value: function(t) {
                    this.scroller.setTo(t)
                }
            }, {
                key: "moveToItem",
                value: function(t) {
                    this.scroller.setTo(this.getPositionByItemIndex(t))
                }
            }, {
                key: "tweenToPosition",
                value: function(t) {
                    var e = arguments.length <= 1 || void 0 === arguments[1] ? 1 : arguments[1];
                    this.scroller.tweenTo(e, t)
                }
            }, {
                key: "tweenToItem",
                value: function(t) {
                    var e = arguments.length <= 1 || void 0 === arguments[1] ? 1 : arguments[1];
                    this.scroller.tweenTo(e, this.getPositionByItemIndex(t))
                }
            }, {
                key: "_setPosition",
                value: function(t) {
                    this.position = t, this.grp[this.p.xy] = this.bounds[this.p.xy] + t, this.o.autocull && this.cull()
                }
            }, {
                key: "_addMask",
                value: function(t) {
                    var e = this.game.add.graphics(0, 0, this.parent);
                    return e.beginFill(16711680).drawRect(t.x, t.y, t.width, t.height), e.alpha = 0, e
                }
            }]), t
        }();
    e.default = o
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var s = e[i];
                    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(t, s.key, s)
                }
            }
            return function(e, i, s) {
                return i && t(e.prototype, i), s && t(e, s), e
            }
        }(),
        n = function t(e, i, s) {
            null === e && (e = Function.prototype);
            var n = Object.getOwnPropertyDescriptor(e, i);
            if (void 0 === n) {
                var r = Object.getPrototypeOf(e);
                return null === r ? void 0 : t(r, i, s)
            }
            if ("value" in n) return n.value;
            var o = n.get;
            return void 0 !== o ? o.call(s) : void 0
        },
        r = (o(i(8)), o(i(12)));

    function o(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    var a = function(t) {
        function e(t, i) {
            var s = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2];
            return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, e),
                function(t, e) {
                    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !e || "object" != typeof e && "function" != typeof e ? t : e
                }(this, Object.getPrototypeOf(e).call(this, t, i, {
                    x: i.width,
                    y: i.height
                }, s))
        }
        return function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
        }(e, r.default), s(e, [{
            key: "handleDown",
            value: function(t, i) {
                this.old = this.down = i[this.o.direction], n(Object.getPrototypeOf(e.prototype), "handleDown", this).call(this, t, i)
            }
        }, {
            key: "handleUp",
            value: function(t, i) {
                this.current = i[this.o.direction], n(Object.getPrototypeOf(e.prototype), "handleUp", this).call(this, t, i)
            }
        }]), e
    }();
    e.default = a
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s = i(11),
        n = i(5),
        r = function() {
            function t() {
                this.length = 2, this.index = 0, this.holes = 0, this.islands = 0, this.tightness = .3, this.tightnessVariation = 0, this.autoEvents = 0, this.buzzSaw = .2, this.crateStack = 0, this.propeller = .5, this.spring = 0, this.backColor = 2614525, this.shadowColor = 3787229, this.levelColor = 16711935, this.grassColor = 65280, this.topBlockPositionIndex = 0, this.bottomBlockPositionIndex = 0, this.blockDiff = 300
            }
            return t.prototype.cacheRandomBlockPositions = function() {
                var t = new Random.Random(Random.MersenneTwister19937.seed(BASE_SEED + this.index));
                this.bottomBlockPositions = [], this.topBlockPositions = [], this.bottomBlockPositionIndex = 0, this.topBlockPositionIndex = 0;
                for (var e = 0; e < 4 * this.length; e++) {
                    var i = 0;
                    i = this.tightness * this.blockDiff, i += t.integer(0, this.tightnessVariation * this.blockDiff), t.bool(this.holes) && (i = -1e3), t.bool(this.islands) && (i = this.blockDiff + 10), this.bottomBlockPositions.push(-1 * i)
                }
                for (e = 0; e < 4 * this.length; e++) {
                    i = 0;
                    i = this.tightness * this.blockDiff, i += t.integer(0, this.tightnessVariation * (this.blockDiff - 10)), this.topBlockPositions.push(i)
                }
            }, t.prototype.cacheEventPositions = function() {
                this.eventPositions = [];
                for (var t = this.buzzSaw + this.crateStack + this.propeller, e = new Random.Random(Random.MersenneTwister19937.seed(BASE_SEED + this.index)), i = [], r = 0; r < this.buzzSaw / t * 52; r++) i.push(n.EventType.BUZZ_SAW);
                for (r = 0; r < this.crateStack / t * 52; r++) i.push(n.EventType.CRATE_STACK);
                for (r = 0; r < this.propeller / t * 52; r++) i.push(n.EventType.PROPELLER);
                for (r = 3; r < this.bottomBlockPositions.length; r++)
                    if (e.bool(this.autoEvents)) {
                        var o = e.integer(0, 51);
                        this.eventPositions.push(new s.default(i[o], r, 0, e.integer(-500, -200)))
                    }
            }, t.prototype.getBottomBlockPosAt = function(t) {
                return this.bottomBlockPositions[t % this.bottomBlockPositions.length]
            }, t.prototype.getBottomBlockPos = function() {
                return this.bottomBlockPositions[this.bottomBlockPositionIndex++ % this.bottomBlockPositions.length]
            }, t.prototype.getTopBlockPos = function() {
                return this.topBlockPositions[this.topBlockPositionIndex++ % this.topBlockPositions.length]
            }, t.prototype.getTopBlockPosAt = function(t) {
                return this.topBlockPositions[t % this.topBlockPositions.length]
            }, t.GenerateRandomLevelBasedOnIndex = function(e) {
                var i = new t;
                i.index = e;
                var s = new Random.Random(Random.MersenneTwister19937.seed(BASE_SEED + e));
                if (i.length = this.generateLength(s, e), i.tightness = s.integer(0, .9 * e) / 120, i.tightness = i.tightness - s.integer(0, e) / 120, i.tightnessVariation = s.integer(0, 70) / 100, i.holes = e < 50 ? s.integer(0, e + 30) / 100 : s.integer(0, 50) / 100, i.islands = e < 50 ? s.integer(0, e + 10) / 300 : s.integer(0, 3) / 100 - 1, s.integer(0, 10) > 7 && (i.islands = 2 * i.islands), s.integer(0, 10) > 7 && (i.holes = 2 * i.holes), e >= 3 && (i.autoEvents = s.integer(0, 1.5 * e + 12 + 15) / 120), e > 20 && (i.autoEvents = s.integer(0, 1.25 * e + 12 + 15) / 120), e > 30 && (i.autoEvents = s.integer(0, 1 * e + 12 + 15) / 120), e > 45 && (i.autoEvents = s.integer(.15, .7 * e + 10 + 10) / 120), e > 100 && (i.autoEvents = (s.integer(2, 12) + 1) / 12, i.autoEvents = i.autoEvents - s.integer(0, 5) / 12, i.autoEvents > .85 && (i.autoEvents = .85), i.autoEvents < 0 && (i.autoEvents = 0)), i.tightnessVariation + i.tightness > .7 && i.autoEvents > .3 && (i.autoEvents = .6 * i.autoEvents), 50 == e && (i.autoEvents = .24), i.buzzSaw = s.integer(0, 3 * e) / 100, i.propeller = .55, i.crateStack = .5, i.autoEvents = Math.min(1, i.autoEvents), i.tightness = Math.min(.6, i.tightness), i.tightness = Math.max(0, i.tightness), i.tightnessVariation = Math.min(.52, i.tightnessVariation), i.tightness > .5 && (i.tightnessVariation = Math.min(.5, i.tightnessVariation)), i.buzzSaw = Math.min(1, i.buzzSaw), i.crateStack = Math.min(1, i.crateStack), LEVELS[e]) {
                    i.isCustom = !0;
                    for (var n in LEVELS[e]) i[n] = LEVELS[e][n]
                }
                return i.cacheRandomBlockPositions(), i.cacheEventPositions(), i
            }, t.generateLength = function(t, e) {
                var i = 3;
                if (i = Math.ceil(.4 * e + 2), e > 10 && (i = 5 + Math.floor(e / 5)), e > 30 && (i = 6 + Math.floor(e / 11)), e > 60 && (i = 7 + Math.floor(e / 16)), e > 100 && (i = 11 + Math.ceil(e / 100)), e > 10) {
                    var s = i / 6;
                    i = i + t.integer(0, s) - s / 2
                }
                return t.integer(0, 100) > 75 ? i *= 1 + t.integer(0, 40) / 100 : e > 20 && t.integer(0, 100) > 75 && (i *= 1 - t.integer(0, 50) / 100), Math.floor(1 * i)
            }, t
        }();
    e.default = r
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(24), i(1);
    var r = i(28),
        o = i(29),
        a = i(81),
        h = i(10),
        l = i(121),
        c = i(0),
        u = i(3),
        d = function(t) {
            function e(e) {
                var i = t.call(this, e) || this;
                if (i.state.add("boot", o.default), i.state.add("preloader", a.default), EDITOR_MODE) {
                    i.state.add("title", l.default);
                    var s = document.createElement("script");
                    s.setAttribute("src", "https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"), document.body.appendChild(s)
                } else i.state.add("title", h.default);
                return i.state.start("boot"), i
            }
            return n(e, t), e
        }(Phaser.Game);

    function p() {
        var t = new URL(window.location.href);
        t.searchParams.get("editor") && (EDITOR_MODE = !0), t.searchParams.get("level") && (LEVEL_INDEX = parseInt(t.searchParams.get("level")));
        var e = {
            width: window.innerWidth / 2,
            height: window.innerHeight / 2,
            renderer: Phaser.AUTO,
            parent: "",
            antialias: !1,
            resolution: 1,
            mspointer: !1,
            transparent: !1,
            enableDebug: !1,
            multiTexture: !0
        };
        new d(e)
    }
    window.onload = function() {
        u.default.Instance.init(),
            function() {
                var t = null,
                    e = [];
                e.length > 0 && ((t = t || {}).google = {
                    families: e
                });
                if (Object.keys(c.CustomWebFonts).length > 0) {
                    (t = t || {}).custom = {
                        families: [],
                        urls: []
                    };
                    for (var i in c.CustomWebFonts) t.custom.families.push(c.CustomWebFonts[i].getFamily()), t.custom.urls.push(c.CustomWebFonts[i].getCSS())
                }
                null === t ? p() : (t.active = p, r.load(t))
            }()
    }
}, function(t, e, i) {
    (function(e) {
        t.exports = e.PIXI = i(25)
    }).call(e, i(13))
}, function(t, e, i) {
    (function() {
        var i = i || {};
        i.DisplayObject = function() {
            this.position = new i.Point(0, 0), this.scale = new i.Point(1, 1), this.pivot = new i.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new Phaser.Matrix, this.worldPosition = new i.Point(0, 0), this.worldScale = new i.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new i.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1
        }, i.DisplayObject.prototype = {
            constructor: i.DisplayObject,
            destroy: function() {
                if (this.children) {
                    for (var t = this.children.length; t--;) this.children[t].destroy();
                    this.children = []
                }
                this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), this._destroyTintedTexture()
            },
            updateTransform: function(t) {
                if (!t && !this.parent && !this.game) return this;
                var e = this.parent;
                t ? e = t : this.parent || (e = this.game.world);
                var i, s, n, r, o, a, h = e.worldTransform,
                    l = this.worldTransform;
                this.rotation % Phaser.Math.PI2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), i = this._cr * this.scale.x, s = this._sr * this.scale.x, n = -this._sr * this.scale.y, r = this._cr * this.scale.y, o = this.position.x, a = this.position.y, (this.pivot.x || this.pivot.y) && (o -= this.pivot.x * i + this.pivot.y * n, a -= this.pivot.x * s + this.pivot.y * r), l.a = i * h.a + s * h.c, l.b = i * h.b + s * h.d, l.c = n * h.a + r * h.c, l.d = n * h.b + r * h.d, l.tx = o * h.a + a * h.c + h.tx, l.ty = o * h.b + a * h.d + h.ty) : (i = this.scale.x, s = 0, n = 0, r = this.scale.y, o = this.position.x - this.pivot.x * i, a = this.position.y - this.pivot.y * r, l.a = i * h.a, l.b = i * h.b, l.c = r * h.c, l.d = r * h.d, l.tx = o * h.a + a * h.c + h.tx, l.ty = o * h.b + a * h.d + h.ty), i = l.a, s = l.b, n = l.c;
                var c = i * (r = l.d) - s * n;
                if (i || s) {
                    var u = Math.sqrt(i * i + s * s);
                    this.worldRotation = s > 0 ? Math.acos(i / u) : -Math.acos(i / u), this.worldScale.x = u, this.worldScale.y = c / u
                } else if (n || r) {
                    var d = Math.sqrt(n * n + r * r);
                    this.worldRotation = Phaser.Math.HALF_PI - (r > 0 ? Math.acos(-n / d) : -Math.acos(n / d)), this.worldScale.x = c / d, this.worldScale.y = d
                } else this.worldScale.x = 0, this.worldScale.y = 0;
                return this.worldAlpha = this.alpha * e.worldAlpha, this.worldPosition.x = l.tx, this.worldPosition.y = l.ty, this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, l, h), this
            },
            preUpdate: function() {},
            generateTexture: function(t, e, s) {
                var n = this.getLocalBounds(),
                    r = new Phaser.RenderTexture(this.game, 0 | n.width, 0 | n.height, s, e, t);
                return i.DisplayObject._tempMatrix.tx = -n.x, i.DisplayObject._tempMatrix.ty = -n.y, r.render(this, i.DisplayObject._tempMatrix), r
            },
            updateCache: function() {
                return this._generateCachedSprite(), this
            },
            toGlobal: function(t) {
                return this.updateTransform(), this.worldTransform.apply(t)
            },
            toLocal: function(t, e) {
                return e && (t = e.toGlobal(t)), this.updateTransform(), this.worldTransform.applyInverse(t)
            },
            _renderCachedSprite: function(t) {
                this._cachedSprite.worldAlpha = this.worldAlpha, t.gl ? i.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : i.Sprite.prototype._renderCanvas.call(this._cachedSprite, t)
            },
            _generateCachedSprite: function() {
                this._cacheAsBitmap = !1;
                var t = this.getLocalBounds();
                if (t.width = Math.max(1, Math.ceil(t.width)), t.height = Math.max(1, Math.ceil(t.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(t.width, t.height);
                else {
                    var e = 0;
                    this.texture && this.texture.baseTexture && i._enableMultiTextureToggle && (e = this.texture.baseTexture.textureIndex);
                    var s = new Phaser.RenderTexture(this.game, t.width, t.height, void 0, void 0, void 0, void 0, e);
                    this._cachedSprite = new i.Sprite(s), this._cachedSprite.worldTransform = this.worldTransform
                }
                var n = this._filters;
                this._filters = null, this._cachedSprite.filters = n, i.DisplayObject._tempMatrix.tx = -t.x, i.DisplayObject._tempMatrix.ty = -t.y, this._cachedSprite.texture.render(this, i.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._filters = n, this._cacheAsBitmap = !0
            },
            _destroyCachedSprite: function() {
                this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
            },
            _destroyTintedTexture: function() {
                this.tintedTexture && (Phaser.CanvasPool.removeByCanvas(this.tintedTexture), this.tintedTexture = null)
            }
        }, i.DisplayObject.prototype.displayObjectUpdateTransform = i.DisplayObject.prototype.updateTransform, Object.defineProperties(i.DisplayObject.prototype, {
            x: {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t
                }
            },
            y: {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t
                }
            },
            worldVisible: {
                get: function() {
                    if (this.visible) {
                        var t = this.parent;
                        if (!t) return this.visible;
                        do {
                            if (!t.visible) return !1;
                            t = t.parent
                        } while (t);
                        return !0
                    }
                    return !1
                }
            },
            mask: {
                get: function() {
                    return this._mask
                },
                set: function(t) {
                    this._mask && (this._mask.isMask = !1), this._mask = t, t && (this._mask.isMask = !0)
                }
            },
            filters: {
                get: function() {
                    return this._filters
                },
                set: function(t) {
                    if (Array.isArray(t)) {
                        for (var e = [], s = 0; s < t.length; s++)
                            for (var n = t[s].passes, r = 0; r < n.length; r++) e.push(n[r]);
                        this._filterBlock = {
                            target: this,
                            filterPasses: e
                        }
                    }
                    this._filters = t, this.blendMode && this.blendMode === i.blendModes.MULTIPLY && (this.blendMode = i.blendModes.NORMAL)
                }
            },
            cacheAsBitmap: {
                get: function() {
                    return this._cacheAsBitmap
                },
                set: function(t) {
                    this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t)
                }
            }
        }), i.DisplayObjectContainer = function() {
            i.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1
        }, i.DisplayObjectContainer.prototype = Object.create(i.DisplayObject.prototype), i.DisplayObjectContainer.prototype.constructor = i.DisplayObjectContainer, i.DisplayObjectContainer.prototype.addChild = function(t) {
            return this.addChildAt(t, this.children.length)
        }, i.DisplayObjectContainer.prototype.addChildAt = function(t, e) {
            if (e >= 0 && e <= this.children.length) return t.parent && t.parent.removeChild(t), t.parent = this, this.children.splice(e, 0, t), t;
            throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length)
        }, i.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
            if (t !== e) {
                var i = this.getChildIndex(t),
                    s = this.getChildIndex(e);
                if (i < 0 || s < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
                this.children[i] = e, this.children[s] = t
            }
        }, i.DisplayObjectContainer.prototype.getChildIndex = function(t) {
            var e = this.children.indexOf(t);
            if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller");
            return e
        }, i.DisplayObjectContainer.prototype.setChildIndex = function(t, e) {
            if (e < 0 || e >= this.children.length) throw new Error("The supplied index is out of bounds");
            var i = this.getChildIndex(t);
            this.children.splice(i, 1), this.children.splice(e, 0, t)
        }, i.DisplayObjectContainer.prototype.getChildAt = function(t) {
            if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
            return this.children[t]
        }, i.DisplayObjectContainer.prototype.removeChild = function(t) {
            var e = this.children.indexOf(t);
            if (-1 !== e) return this.removeChildAt(e)
        }, i.DisplayObjectContainer.prototype.removeChildAt = function(t) {
            var e = this.getChildAt(t);
            return e && (e.parent = void 0, this.children.splice(t, 1)), e
        }, i.DisplayObjectContainer.prototype.bringChildToTop = function(t) {
            if (t.parent === this) return this.setChildIndex(t, this.children.length - 1)
        }, i.DisplayObjectContainer.prototype.sendChildToBack = function(t) {
            if (t.parent === this) return this.setChildIndex(t, 0)
        }, i.DisplayObjectContainer.prototype.removeChildren = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
            var i = e - t;
            if (i > 0 && i <= e) {
                for (var s = this.children.splice(t, i), n = 0; n < s.length; n++) {
                    s[n].parent = void 0
                }
                return s
            }
            if (0 === i && 0 === this.children.length) return [];
            throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
        }, i.DisplayObjectContainer.prototype.updateTransform = function() {
            if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap))
                for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
        }, i.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = i.DisplayObjectContainer.prototype.updateTransform, i.DisplayObjectContainer.prototype.getBounds = function(t) {
            var e, s = t && t instanceof i.DisplayObject,
                n = !0;
            if (s ? n = t instanceof i.DisplayObjectContainer && t.contains(this) : t = this, s) {
                var r = t.worldTransform;
                for (t.worldTransform = Phaser.identityMatrix, e = 0; e < t.children.length; e++) t.children[e].updateTransform()
            }
            var o, a, h, l = 1 / 0,
                c = 1 / 0,
                u = -1 / 0,
                d = -1 / 0,
                p = !1;
            for (e = 0; e < this.children.length; e++) {
                this.children[e].visible && (p = !0, l = l < (o = this.children[e].getBounds()).x ? l : o.x, c = c < o.y ? c : o.y, a = o.width + o.x, h = o.height + o.y, u = u > a ? u : a, d = d > h ? d : h)
            }
            var f = this._bounds;
            if (!p) {
                var g = (f = new i.Rectangle).x,
                    m = f.width + f.x,
                    y = f.y,
                    v = f.height + f.y,
                    x = this.worldTransform,
                    b = x.a,
                    _ = x.b,
                    T = x.c,
                    w = x.d,
                    S = x.tx,
                    C = x.ty,
                    E = b * m + T * v + S,
                    P = w * v + _ * m + C,
                    A = b * g + T * v + S,
                    M = w * v + _ * g + C,
                    k = b * g + T * y + S,
                    R = w * y + _ * g + C,
                    O = b * m + T * y + S,
                    I = w * y + _ * m + C;
                u = E, d = P, c = P, l = O < (l = k < (l = A < (l = E) ? A : l) ? k : l) ? O : l, c = I < (c = R < (c = M < c ? M : c) ? R : c) ? I : c, u = O > (u = k > (u = A > u ? A : u) ? k : u) ? O : u, d = I > (d = R > (d = M > d ? M : d) ? R : d) ? I : d
            }
            if (f.x = l, f.y = c, f.width = u - l, f.height = d - c, s)
                for (t.worldTransform = r, e = 0; e < t.children.length; e++) t.children[e].updateTransform();
            if (!n) {
                var L = t.getBounds();
                f.x -= L.x, f.y -= L.y
            }
            return f
        }, i.DisplayObjectContainer.prototype.getLocalBounds = function() {
            return this.getBounds(this)
        }, i.DisplayObjectContainer.prototype.contains = function(t) {
            return !!t && (t === this || this.contains(t.parent))
        }, i.DisplayObjectContainer.prototype._renderWebGL = function(t) {
            var e;
            if (this.visible && !(this.alpha <= 0))
                if (this._cacheAsBitmap) this._renderCachedSprite(t);
                else if (this._mask || this._filters) {
                for (this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                t.spriteBatch.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), t.spriteBatch.start()
            } else
                for (e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t)
        }, i.DisplayObjectContainer.prototype._renderCanvas = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha)
                if (this._cacheAsBitmap) this._renderCachedSprite(t);
                else {
                    this._mask && t.maskManager.pushMask(this._mask, t);
                    for (var e = 0; e < this.children.length; e++) this.children[e]._renderCanvas(t);
                    this._mask && t.maskManager.popMask(t)
                }
        }, Object.defineProperty(i.DisplayObjectContainer.prototype, "width", {
            get: function() {
                return this.getLocalBounds().width * this.scale.x
            },
            set: function(t) {
                var e = this.getLocalBounds().width;
                this.scale.x = 0 !== e ? t / e : 1, this._width = t
            }
        }), Object.defineProperty(i.DisplayObjectContainer.prototype, "height", {
            get: function() {
                return this.getLocalBounds().height * this.scale.y
            },
            set: function(t) {
                var e = this.getLocalBounds().height;
                this.scale.y = 0 !== e ? t / e : 1, this._height = t
            }
        }), i.Sprite = function(t) {
            i.DisplayObjectContainer.call(this), this.anchor = new i.Point(i.Sprite.defaultAnchor.x, i.Sprite.defaultAnchor.y), this.texture = t || i.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = i.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0
        }, i.Sprite.defaultAnchor = {
            x: 0,
            y: 0
        }, i.Sprite.prototype = Object.create(i.DisplayObjectContainer.prototype), i.Sprite.prototype.constructor = i.Sprite, Object.defineProperty(i.Sprite.prototype, "width", {
            get: function() {
                return this.scale.x * this.texture.frame.width
            },
            set: function(t) {
                this.scale.x = t / this.texture.frame.width, this._width = t
            }
        }), Object.defineProperty(i.Sprite.prototype, "height", {
            get: function() {
                return this.scale.y * this.texture.frame.height
            },
            set: function(t) {
                this.scale.y = t / this.texture.frame.height, this._height = t
            }
        }), i.Sprite.prototype.setTexture = function(t, e) {
            e && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = t, this.texture.valid = !0, this.cachedTint = -1
        }, i.Sprite.prototype.onTextureUpdate = function() {
            this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height)
        }, i.Sprite.prototype.getBounds = function(t) {
            var e = this.texture.frame.width,
                i = this.texture.frame.height,
                s = e * (1 - this.anchor.x),
                n = e * -this.anchor.x,
                r = i * (1 - this.anchor.y),
                o = i * -this.anchor.y,
                a = t || this.worldTransform,
                h = a.a,
                l = a.b,
                c = a.c,
                u = a.d,
                d = a.tx,
                p = a.ty,
                f = -1 / 0,
                g = -1 / 0,
                m = 1 / 0,
                y = 1 / 0;
            if (0 === l && 0 === c) {
                if (h < 0) {
                    h *= -1;
                    var v = s;
                    s = -n, n = -v
                }
                if (u < 0) {
                    u *= -1;
                    v = r;
                    r = -o, o = -v
                }
                m = h * n + d, f = h * s + d, y = u * o + p, g = u * r + p
            } else {
                var x = h * n + c * o + d,
                    b = u * o + l * n + p,
                    _ = h * s + c * o + d,
                    T = u * o + l * s + p,
                    w = h * s + c * r + d,
                    S = u * r + l * s + p,
                    C = h * n + c * r + d,
                    E = u * r + l * n + p;
                m = C < (m = w < (m = _ < (m = x < m ? x : m) ? _ : m) ? w : m) ? C : m, y = E < (y = S < (y = T < (y = b < y ? b : y) ? T : y) ? S : y) ? E : y, f = C > (f = w > (f = _ > (f = x > f ? x : f) ? _ : f) ? w : f) ? C : f, g = E > (g = S > (g = T > (g = b > g ? b : g) ? T : g) ? S : g) ? E : g
            }
            var P = this._bounds;
            return P.x = m, P.width = f - m, P.y = y, P.height = g - y, this._currentBounds = P, P
        }, i.Sprite.prototype.getLocalBounds = function() {
            var t = this.worldTransform;
            this.worldTransform = Phaser.identityMatrix;
            for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
            var i = this.getBounds();
            for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
            return i
        }, i.Sprite.prototype._renderWebGL = function(t, e) {
            if (this.visible && !(this.alpha <= 0) && this.renderable) {
                var i = this.worldTransform;
                if (e && (i = e), this._mask || this._filters) {
                    var s = t.spriteBatch;
                    this._filters && (s.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (s.stop(), t.maskManager.pushMask(this.mask, t), s.start()), s.render(this);
                    for (var n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t);
                    s.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), s.start()
                } else {
                    t.spriteBatch.render(this);
                    for (n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t, i)
                }
            }
        }, i.Sprite.prototype._renderCanvas = function(t, e) {
            if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width < 1 || this.texture.crop.height < 1)) {
                var s = this.worldTransform;
                if (e && (s = e), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = i.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t), this.texture.valid) {
                    var n = this.texture.baseTexture.resolution / t.resolution;
                    t.context.globalAlpha = this.worldAlpha, t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === i.scaleModes.LINEAR);
                    var r = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                        o = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
                        a = s.tx * t.resolution + t.shakeX,
                        h = s.ty * t.resolution + t.shakeY,
                        l = this.texture.crop.width,
                        c = this.texture.crop.height;
                    if (this.texture.rotated) {
                        var u = s.a,
                            d = s.b,
                            p = s.c,
                            f = s.d,
                            g = l;
                        a = s.c * c + a, h = s.d * c + h, s.a = 6.123233995736766e-17 * u - p, s.b = 6.123233995736766e-17 * d - f, s.c = u + 6.123233995736766e-17 * p, s.d = d + 6.123233995736766e-17 * f, l = c, c = g
                    }
                    if (t.roundPixels ? (t.context.setTransform(s.a, s.b, s.c, s.d, 0 | a, 0 | h), r |= 0, o |= 0) : t.context.setTransform(s.a, s.b, s.c, s.d, a, h), r /= n, o /= n, c |= 0, (l |= 0) && c) {
                        if (16777215 !== this.tint)(this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = i.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), t.context.drawImage(this.tintedTexture, 0, 0, l, c, r, o, l / n, c / n);
                        else {
                            var m = this.texture.crop.x,
                                y = this.texture.crop.y;
                            t.context.drawImage(this.texture.baseTexture.source, m, y, l, c, r, o, l / n, c / n)
                        }
                        for (v = 0; v < this.children.length; v++) this.children[v]._renderCanvas(t);
                        this._mask && t.maskManager.popMask(t)
                    }
                } else {
                    for (var v = 0; v < this.children.length; v++) this.children[v]._renderCanvas(t);
                    this._mask && t.maskManager.popMask(t)
                }
            }
        }, i.initDefaultShaders = function() {}, i.CompileVertexShader = function(t, e) {
            return i._CompileShader(t, e, t.VERTEX_SHADER)
        }, i.CompileFragmentShader = function(t, e) {
            return i._CompileShader(t, e, t.FRAGMENT_SHADER)
        }, i._CompileShader = function(t, e, i) {
            var s = e;
            Array.isArray(e) && (s = e.join("\n"));
            var n = t.createShader(i);
            return t.shaderSource(n, s), t.compileShader(n), t.getShaderParameter(n, t.COMPILE_STATUS) ? n : (window.console.log(t.getShaderInfoLog(n)), null)
        }, i.compileProgram = function(t, e, s) {
            var n = i.CompileFragmentShader(t, s),
                r = i.CompileVertexShader(t, e),
                o = t.createProgram();
            return t.attachShader(o, r), t.attachShader(o, n), t.linkProgram(o), t.getProgramParameter(o, t.LINK_STATUS) || (window.console.log(t.getProgramInfoLog(o)), window.console.log("Could not initialise shaders")), o
        }, i.PixiShader = function(t) {
            this._UID = Phaser._UID++, this.gl = t, this.program = null, this.fragmentSrc = null, this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init()
        }, i.PixiShader.prototype.constructor = i.PixiShader, i.PixiShader.prototype.initMultitexShader = function() {
            var t = this.gl;
            this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
            for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", s = 1; s < this.MAX_TEXTURES; ++s) e += "\tif (vTextureIndex == " + s + ".0) {gl_FragColor = texture2D(uSamplerArray[" + s + "], vTextureCoord) * vColor;return;}\n";
            this.fragmentSrc = ["// PixiShader Fragment Shader.", "precision lowp float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) { gl_FragColor = RED;return;}", "}"];
            var n = i.compileProgram(t, this.vertexSrc || i.PixiShader.defaultVertexSrc, this.fragmentSrc);
            t.useProgram(n), this.uSamplerArray = t.getUniformLocation(n, "uSamplerArray[0]"), this.projectionVector = t.getUniformLocation(n, "projectionVector"), this.offsetVector = t.getUniformLocation(n, "offsetVector"), this.dimensions = t.getUniformLocation(n, "dimensions"), this.aVertexPosition = t.getAttribLocation(n, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(n, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(n, "aColor"), this.aTextureIndex = t.getAttribLocation(n, "aTextureIndex");
            var r = [],
                o = t.createTexture();
            t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, o), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
            for (var a = 0; a < this.MAX_TEXTURES; ++a) t.activeTexture(t.TEXTURE0 + a), t.bindTexture(t.TEXTURE_2D, o), r.push(a);
            t.activeTexture(t.TEXTURE0), t.uniform1iv(this.uSamplerArray, r), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex];
            for (var h in this.uniforms) this.uniforms[h].uniformLocation = t.getUniformLocation(n, h);
            this.initUniforms(), this.program = n
        }, i.PixiShader.prototype.initDefaultShader = function() {
            null === this.fragmentSrc && (this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"]);
            var t = this.gl,
                e = i.compileProgram(t, this.vertexSrc || i.PixiShader.defaultVertexSrc, this.fragmentSrc);
            t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex];
            for (var s in this.uniforms) this.uniforms[s].uniformLocation = t.getUniformLocation(e, s);
            this.initUniforms(), this.program = e
        }, i.PixiShader.prototype.init = function(t) {
            i._enableMultiTextureToggle && !t ? this.initMultitexShader() : this.initDefaultShader()
        }, i.PixiShader.prototype.initUniforms = function() {
            this.textureCount = 1;
            var t, e = this.gl;
            for (var i in this.uniforms) {
                var s = (t = this.uniforms[i]).type;
                "sampler2D" === s ? (t._init = !1, null !== t.value && this.initSampler2D(t)) : "mat2" === s || "mat3" === s || "mat4" === s ? (t.glMatrix = !0, t.glValueLength = 1, "mat2" === s ? t.glFunc = e.uniformMatrix2fv : "mat3" === s ? t.glFunc = e.uniformMatrix3fv : "mat4" === s && (t.glFunc = e.uniformMatrix4fv)) : (t.glFunc = e["uniform" + s], t.glValueLength = "2f" === s || "2i" === s ? 2 : "3f" === s || "3i" === s ? 3 : "4f" === s || "4i" === s ? 4 : 1)
            }
        }, i.PixiShader.prototype.initSampler2D = function(t) {
            if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) {
                var e = this.gl;
                if (e.activeTexture(e.TEXTURE0 + this.textureCount), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), t.textureData) {
                    var i = t.textureData,
                        s = i.magFilter ? i.magFilter : e.LINEAR,
                        n = i.minFilter ? i.minFilter : e.LINEAR,
                        r = i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE,
                        o = i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE,
                        a = i.luminance ? e.LUMINANCE : e.RGBA;
                    if (i.repeat && (r = e.REPEAT, o = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width) {
                        var h = i.width ? i.width : 512,
                            l = i.height ? i.height : 2,
                            c = i.border ? i.border : 0;
                        e.texImage2D(e.TEXTURE_2D, 0, a, h, l, c, a, e.UNSIGNED_BYTE, null)
                    } else e.texImage2D(e.TEXTURE_2D, 0, a, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, r), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, o)
                }
                e.uniform1i(t.uniformLocation, this.textureCount), t._init = !0, this.textureCount++
            }
        }, i.PixiShader.prototype.syncUniforms = function() {
            var t;
            this.textureCount = 1;
            var e = this.gl;
            for (var s in this.uniforms) 1 === (t = this.uniforms[s]).glValueLength ? !0 === t.glMatrix ? t.glFunc.call(e, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(e, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (e.activeTexture(e["TEXTURE" + this.textureCount]), t.value.baseTexture._dirty[e.id] ? i.instances[e.id].updateTexture(t.value.baseTexture) : e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), e.uniform1i(t.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(t))
        }, i.PixiShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, i.PixiShader.defaultVertexSrc = ["// PixiShader Vertex Shader", "// With multi-texture rendering", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "attribute float aTextureIndex;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   if (aTextureIndex > 0.0) gl_Position = vec4(0.0);", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "   vTextureIndex = aTextureIndex;", "}"], i.PixiFastShader = function(t) {
            if (this._UID = Phaser._UID++, this.gl = t, this.program = null, i._enableMultiTextureToggle) {
                t = this.gl;
                this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
                for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", s = 1; s < this.MAX_TEXTURES; ++s) e += "\tif (vTextureIndex == " + s + ".0) { gl_FragColor = texture2D(uSamplerArray[" + s + "], vTextureCoord) * vColor;return;}\n";
                this.fragmentSrc = ["// PixiFastShader Fragment Shader.", "precision lowp float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}", "}"]
            } else this.fragmentSrc = ["// PixiFastShader Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;", "}"];
            this.vertexSrc = ["// PixiFastShader Vertex Shader.", "attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "attribute float aTextureIndex;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vTextureIndex = aTextureIndex;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init()
        }, i.PixiFastShader.prototype.constructor = i.PixiFastShader, i.PixiFastShader.prototype.init = function() {
            var t = this.gl,
                e = i.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            if (t.useProgram(e), this.uSampler = i._enableMultiTextureToggle ? t.getUniformLocation(e, "uSamplerArray[0]") : t.getUniformLocation(e, "uSampler"), i._enableMultiTextureToggle) {
                var s = [],
                    n = t.createTexture();
                t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
                for (var r = 0; r < this.MAX_TEXTURES; ++r) t.activeTexture(t.TEXTURE0 + r), t.bindTexture(t.TEXTURE_2D, n), s.push(r);
                t.activeTexture(t.TEXTURE0), t.uniform1iv(this.uSampler, s)
            }
            this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.uMatrix = t.getUniformLocation(e, "uMatrix"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aPositionCoord = t.getAttribLocation(e, "aPositionCoord"), this.aScale = t.getAttribLocation(e, "aScale"), this.aRotation = t.getAttribLocation(e, "aRotation"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute, this.aTextureIndex], this.program = e
        }, i.PixiFastShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, i.StripShader = function(t) {
            if (this._UID = Phaser._UID++, this.gl = t, this.program = null, i._enableMultiTextureToggle) {
                t = this.gl;
                this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
                for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord);return;}\n", s = 1; s < this.MAX_TEXTURES; ++s) e += "\tif (vTextureIndex == " + s + ".0) { gl_FragColor = texture2D(uSamplerArray[" + s + "], vTextureCoord) ;return;}\n";
                this.fragmentSrc = ["//StripShader Fragment Shader.", "precision mediump float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "uniform float alpha;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}", "}"]
            } else this.fragmentSrc = ["//StripShader Fragment Shader.", "precision mediump float;", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "}"];
            this.vertexSrc = ["//StripShader Vertex Shader.", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute float aTextureIndex;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vTextureIndex = aTextureIndex;", "}"], this.init()
        }, i.StripShader.prototype.constructor = i.StripShader, i.StripShader.prototype.init = function() {
            var t = this.gl,
                e = i.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            if (t.useProgram(e), this.uSampler = i._enableMultiTextureToggle ? t.getUniformLocation(e, "uSamplerArray[0]") : t.getUniformLocation(e, "uSampler"), i._enableMultiTextureToggle) {
                var s = [],
                    n = t.createTexture();
                t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
                for (var r = 0; r < this.MAX_TEXTURES; ++r) t.activeTexture(t.TEXTURE0 + r), t.bindTexture(t.TEXTURE_2D, n), s.push(r);
                t.activeTexture(t.TEXTURE0), t.uniform1iv(this.uSampler, s)
            }
            this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.aTextureIndex], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
        }, i.StripShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
        }, i.PrimitiveShader = function(t) {
            this._UID = Phaser._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init()
        }, i.PrimitiveShader.prototype.constructor = i.PrimitiveShader, i.PrimitiveShader.prototype.init = function() {
            var t = this.gl,
                e = i.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
        }, i.PrimitiveShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, i.ComplexPrimitiveShader = function(t) {
            this._UID = Phaser._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init()
        }, i.ComplexPrimitiveShader.prototype.constructor = i.ComplexPrimitiveShader, i.ComplexPrimitiveShader.prototype.init = function() {
            var t = this.gl,
                e = i.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.color = t.getUniformLocation(e, "color"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
        }, i.ComplexPrimitiveShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
        }, i.glContexts = [], i.instances = [], i._enableMultiTextureToggle = !1, i.WebGLRenderer = function(t, e) {
            this.game = t, i.defaultRenderer || (i.defaultRenderer = this), this.extensions = {}, this.type = Phaser.WEBGL, this.resolution = t.resolution, this.transparent = t.transparent, this.autoResize = !1, this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.clearBeforeRender = t.clearBeforeRender, this.powerPreference = t.powerPreference, this.width = t.width, this.height = t.height, this.view = t.canvas, this._contextOptions = {
                alpha: this.transparent,
                antialias: t.antialias,
                failIfMajorPerformanceCaveat: e.failIfMajorPerformanceCaveat,
                premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
                stencil: !0,
                preserveDrawingBuffer: this.preserveDrawingBuffer,
                powerPreference: t.powerPreference
            }, this.projection = new i.Point, this.offset = new i.Point, this.shaderManager = new i.WebGLShaderManager, this.spriteBatch = new i.WebGLSpriteBatch(t), this.maskManager = new i.WebGLMaskManager, this.filterManager = new i.WebGLFilterManager, this.stencilManager = new i.WebGLStencilManager, this.blendModeManager = new i.WebGLBlendModeManager, this.renderSession = {}, this.currentBatchedTextures = [], this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, this.renderSession.resolution = this.resolution, this.renderSession.roundPixels = e.roundPixels || !1, this.renderSession.maxTextureAvailableSpace = null, this.initContext(), this.mapBlendModes()
        }, i.WebGLRenderer.prototype.constructor = i.WebGLRenderer, i.WebGLRenderer.prototype.initContext = function() {
            var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
            if (this.gl = t, !t) throw new Error("This browser does not support webGL. Try using the canvas renderer");
            this.maxTextures = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.maxTextureSize = this.gl.getParameter(t.MAX_TEXTURE_SIZE), this.glContextId = t.id = i.WebGLRenderer.glContextId++, i.glContexts[this.glContextId] = t, i.instances[this.glContextId] = this, t.disable(t.DEPTH_TEST), t.disable(t.CULL_FACE), t.enable(t.BLEND), this.shaderManager.setContext(t), this.spriteBatch.setContext(t), this.maskManager.setContext(t), this.filterManager.setContext(t), this.blendModeManager.setContext(t), this.stencilManager.setContext(t), this.renderSession.gl = this.gl, this.resize(this.width, this.height), this.extensions.compression = {};
            var e = t.getExtension("WEBGL_compressed_texture_etc1") || t.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
                s = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            e && (this.extensions.compression.ETC1 = e), s && (this.extensions.compression.PVRTC = s), n && (this.extensions.compression.S3TC = n)
        }, i.WebGLRenderer.prototype.setTexturePriority = function(t) {
            if (i._enableMultiTextureToggle) {
                for (var e = function(t) {
                        return --t, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, ++t
                    }, s = this.gl, n = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), r = s.getParameter(s.MAX_TEXTURE_SIZE), o = this.game.cache._cache.image, a = null, h = 0; h < this.currentBatchedTextures.length; h++)(a = this.currentBatchedTextures[h]) in o ? o[a].base.textureIndex = 0 : console.warn('setTexturePriority: There is no image "%s" in the image cache.', a);
                var l = r - e(Math.max(this.width, this.height));
                this.currentBatchedTextures.length = 0;
                for (var c = 0; c < t.length; ++c)
                    if ((a = t[c]) in o) {
                        var u = o[a].base;
                        (l -= e(Math.max(u.width, u.height))) <= 0 ? (u.textureIndex = 0, console.warn('setTexturePriority: Image "%s" was given textureIndex=0 because there is no available texture space (%s).', a, l)) : u.textureIndex = 1 + c % (n - 1), this.currentBatchedTextures.push(a)
                    } else console.warn('setTexturePriority: There is no image "%s" in the image cache.', a);
                return this.renderSession.maxTextureAvailableSpace = l, this.currentBatchedTextures
            }
            console.warn("setTexturePriority error: Multi Texture support hasn't been enabled in the Phaser Game Config.")
        }, i.WebGLRenderer.prototype.render = function(t) {
            if (!this.contextLost) {
                var e = this.gl;
                e.viewport(0, 0, this.width, this.height), e.bindFramebuffer(e.FRAMEBUFFER, null), this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a), e.clear(e.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(t, this.projection)
            }
        }, i.WebGLRenderer.prototype.renderDisplayObject = function(t, e, s, n) {
            this.renderSession.blendModeManager.setBlendMode(i.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flipY = s ? -1 : 1, this.renderSession.projection = e, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, s), t._renderWebGL(this.renderSession, n), this.spriteBatch.end()
        }, i.WebGLRenderer.prototype.resize = function(t, e) {
            this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution
        }, i.WebGLRenderer.prototype.updateCompressedTexture = function(t) {
            if (!t.hasLoaded) return !1;
            var e = this.gl,
                s = t.source;
            return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()), e.activeTexture(e.TEXTURE0 + t.textureIndex), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.compressedTexImage2D(e.TEXTURE_2D, 0, s.glExtensionFormat, s.width, s.height, 0, s.textureData), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t.mipmap && Phaser.Math.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), t._dirty[e.id] = !1, !0
        }, i.WebGLRenderer.prototype.updateTexture = function(t) {
            if (!t.hasLoaded || !t.source) return !1;
            if (t.source.compressionAlgorithm) return this.updateCompressedTexture(t);
            var e = this.gl;
            return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()), e.activeTexture(e.TEXTURE0 + t.textureIndex), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t.source), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t.mipmap && Phaser.Math.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), t._dirty[e.id] = !1, !0
        }, i.WebGLRenderer.prototype.destroy = function() {
            i.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, Phaser.CanvasPool.remove(this), i.instances[this.glContextId] = null, i.WebGLRenderer.glContextId--
        }, i.WebGLRenderer.prototype.mapBlendModes = function() {
            var t = this.gl;
            if (!i.blendModesWebGL) {
                var e = [],
                    s = i.blendModes;
                e[s.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.ADD] = [t.SRC_ALPHA, t.DST_ALPHA], e[s.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA], e[s.SCREEN] = [t.SRC_ALPHA, t.ONE], e[s.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i.blendModesWebGL = e
            }
        }, i.WebGLRenderer.prototype.getMaxTextureUnit = function() {
            var t = this.gl;
            return t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
        }, i.enableMultiTexture = function() {
            i._enableMultiTextureToggle = !0
        }, i.WebGLRenderer.glContextId = 0, i.WebGLRenderer.textureArray = [], i.WebGLBlendModeManager = function() {
            this.currentBlendMode = 99999
        }, i.WebGLBlendModeManager.prototype.constructor = i.WebGLBlendModeManager, i.WebGLBlendModeManager.prototype.setContext = function(t) {
            this.gl = t
        }, i.WebGLBlendModeManager.prototype.setBlendMode = function(t) {
            if (this.currentBlendMode === t) return !1;
            this.currentBlendMode = t;
            var e = i.blendModesWebGL[this.currentBlendMode];
            return e && this.gl.blendFunc(e[0], e[1]), !0
        }, i.WebGLBlendModeManager.prototype.destroy = function() {
            this.gl = null
        }, i.WebGLMaskManager = function() {}, i.WebGLMaskManager.prototype.constructor = i.WebGLMaskManager, i.WebGLMaskManager.prototype.setContext = function(t) {
            this.gl = t
        }, i.WebGLMaskManager.prototype.pushMask = function(t, e) {
            var s = e.gl;
            t.dirty && i.WebGLGraphics.updateGraphics(t, s), void 0 !== t._webGL[s.id] && void 0 !== t._webGL[s.id].data && 0 !== t._webGL[s.id].data.length && e.stencilManager.pushStencil(t, t._webGL[s.id].data[0], e)
        }, i.WebGLMaskManager.prototype.popMask = function(t, e) {
            var i = this.gl;
            void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
        }, i.WebGLMaskManager.prototype.destroy = function() {
            this.gl = null
        }, i.WebGLStencilManager = function() {
            this.stencilStack = [], this.reverse = !0, this.count = 0
        }, i.WebGLStencilManager.prototype.setContext = function(t) {
            this.gl = t
        }, i.WebGLStencilManager.prototype.pushStencil = function(t, e, i) {
            var s = this.gl;
            this.bindGraphics(t, e, i), 0 === this.stencilStack.length && (s.enable(s.STENCIL_TEST), s.clear(s.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(e);
            var n = this.count;
            s.colorMask(!1, !1, !1, !1), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), 1 === e.mode ? (s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), this.reverse ? s.stencilFunc(s.EQUAL, 255 - (n + 1), 255) : s.stencilFunc(s.EQUAL, n + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n + 1, 255) : s.stencilFunc(s.EQUAL, 255 - (n + 1), 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), this.count++
        }, i.WebGLStencilManager.prototype.bindGraphics = function(t, e, i) {
            this._currentGraphics = t;
            var s, n = this.gl,
                r = i.projection,
                o = i.offset;
            1 === e.mode ? (s = i.shaderManager.complexPrimitiveShader, i.shaderManager.setShader(s), n.uniform1f(s.flipY, i.flipY), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform2f(s.projectionVector, r.x, -r.y), n.uniform2f(s.offsetVector, -o.x, -o.y), n.uniform3fv(s.tintColor, Phaser.Color.hexToRGBArray(t.tint)), n.uniform3fv(s.color, e.color), n.uniform1f(s.alpha, t.worldAlpha * e.alpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 8, 0), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer)) : (s = i.shaderManager.primitiveShader, i.shaderManager.setShader(s), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform1f(s.flipY, i.flipY), n.uniform2f(s.projectionVector, r.x, -r.y), n.uniform2f(s.offsetVector, -o.x, -o.y), n.uniform3fv(s.tintColor, Phaser.Color.hexToRGBArray(t.tint)), n.uniform1f(s.alpha, t.worldAlpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 24, 0), n.vertexAttribPointer(s.colorAttribute, 4, n.FLOAT, !1, 24, 8), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer))
        }, i.WebGLStencilManager.prototype.popStencil = function(t, e, i) {
            var s = this.gl;
            if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) s.disable(s.STENCIL_TEST);
            else {
                var n = this.count;
                this.bindGraphics(t, e, i), s.colorMask(!1, !1, !1, !1), 1 === e.mode ? (this.reverse = !this.reverse, this.reverse ? (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255)) : (this.reverse ? (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP)
            }
        }, i.WebGLStencilManager.prototype.destroy = function() {
            this.stencilStack = null, this.gl = null
        }, i.WebGLShaderManager = function() {
            this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
            for (var t = 0; t < this.maxAttibs; t++) this.attribState[t] = !1;
            this.stack = []
        }, i.WebGLShaderManager.prototype.constructor = i.WebGLShaderManager, i.WebGLShaderManager.prototype.setContext = function(t) {
            this.gl = t, this.primitiveShader = new i.PrimitiveShader(t), this.complexPrimitiveShader = new i.ComplexPrimitiveShader(t), this.defaultShader = new i.PixiShader(t), this.fastShader = new i.PixiFastShader(t), this.stripShader = new i.StripShader(t), this.creatureShader = i.CreatureShader ? new i.CreatureShader(t) : null, this.setShader(this.defaultShader)
        }, i.WebGLShaderManager.prototype.setAttribs = function(t) {
            var e;
            for (e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1;
            for (e = 0; e < t.length; e++) {
                var i = t[e];
                this.tempAttribState[i] = !0
            }
            var s = this.gl;
            for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.tempAttribState[e] ? s.enableVertexAttribArray(e) : s.disableVertexAttribArray(e))
        }, i.WebGLShaderManager.prototype.setShader = function(t) {
            return this._currentId !== t._UID && (this._currentId = t._UID, this.currentShader = t, this.gl.useProgram(t.program), this.setAttribs(t.attributes), !0)
        }, i.WebGLShaderManager.prototype.destroy = function() {
            this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.creatureShader && this.creatureShader.destroy(), this.gl = null
        }, i.WebGLSpriteBatch = function(t) {
            this.game = t, this.vertSize = 5, this.size = 2e3, this.vertexSize = 24;
            var e = this.vertexSize * this.size * 4,
                i = 6 * this.size;
            this.vertices = new ArrayBuffer(e), this.positions = new Float32Array(this.vertices), this.colors = new Uint32Array(this.vertices), this.indices = new Uint16Array(i), this.lastIndexCount = 0;
            for (var s = 0, n = 0; s < i; s += 6, n += 4) this.indices[s + 0] = n + 0, this.indices[s + 1] = n + 1, this.indices[s + 2] = n + 2, this.indices[s + 3] = n + 0, this.indices[s + 4] = n + 2, this.indices[s + 5] = n + 3;
            this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = null
        }, i.WebGLSpriteBatch.prototype.setContext = function(t) {
            if (this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.gl = t, i._enableMultiTextureToggle) {
                for (var e = "\tif (vTextureIndex == 0.0) {gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", s = 1; s < this.MAX_TEXTURES; ++s) e += "\tif (vTextureIndex == " + s + ".0) {gl_FragColor = texture2D(uSamplerArray[" + s + "], vTextureCoord) * vColor;return;}\n";
                this.defaultShader = new Phaser.Filter(this.game, void 0, ["//WebGLSpriteBatch Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "void main(void) {", e, "\tgl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;", "}"])
            } else this.defaultShader = new Phaser.Filter(this.game, void 0, ["//WebGLSpriteBatch Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;", "}"]);
            this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), this.currentBlendMode = 99999;
            var n = new i.PixiShader(t);
            n.fragmentSrc = this.defaultShader.fragmentSrc, n.uniforms = {}, n.init(), this.defaultShader.shaders[t.id] = n
        }, i.WebGLSpriteBatch.prototype.begin = function(t) {
            this.renderSession = t, this.shader = this.renderSession.shaderManager.defaultShader, this.start()
        }, i.WebGLSpriteBatch.prototype.end = function() {
            this.flush()
        }, i.WebGLSpriteBatch.prototype.render = function(t, e) {
            var i = t.texture,
                s = t.worldTransform;
            e && (s = e), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture);
            var n = i._uvs;
            if (n) {
                var r, o, a, h, l = t.anchor.x,
                    c = t.anchor.y;
                if (i.trim) {
                    var u = i.trim;
                    r = (o = u.x - l * u.width) + i.crop.width, a = (h = u.y - c * u.height) + i.crop.height
                } else r = i.frame.width * (1 - l), o = i.frame.width * -l, a = i.frame.height * (1 - c), h = i.frame.height * -c;
                var d = this.currentBatchSize * this.vertexSize,
                    p = i.baseTexture.resolution,
                    f = i.baseTexture.textureIndex,
                    g = s.a / p,
                    m = s.b / p,
                    y = s.c / p,
                    v = s.d / p,
                    x = s.tx,
                    b = s.ty,
                    _ = i.crop.height;
                if (i.rotated) {
                    var T = s.a,
                        w = s.b,
                        S = s.c,
                        C = s.d,
                        E = o,
                        P = r;
                    x = s.c * _ + x, b = s.d * _ + b, g = 6.123233995736766e-17 * T - S, m = 6.123233995736766e-17 * w - C, y = T + 6.123233995736766e-17 * S, v = w + 6.123233995736766e-17 * C, i._updateUvsInverted(), r = a, o = h, a = P, h = E
                }
                var A = this.colors,
                    M = this.positions,
                    k = t.tint,
                    R = (k >> 16) + (65280 & k) + ((255 & k) << 16) + (255 * t.worldAlpha << 24);
                this.renderSession.roundPixels ? (M[d++] = g * o + y * h + x | 0, M[d++] = v * h + m * o + b | 0, M[d++] = n.x0, M[d++] = n.y0, A[d++] = R, M[d++] = f, M[d++] = g * r + y * h + x | 0, M[d++] = v * h + m * r + b | 0, M[d++] = n.x1, M[d++] = n.y1, A[d++] = R, M[d++] = f, M[d++] = g * r + y * a + x | 0, M[d++] = v * a + m * r + b | 0, M[d++] = n.x2, M[d++] = n.y2, A[d++] = R, M[d++] = f, M[d++] = g * o + y * a + x | 0, M[d++] = v * a + m * o + b | 0, M[d++] = n.x3, M[d++] = n.y3, A[d++] = R, M[d++] = f) : (M[d++] = g * o + y * h + x, M[d++] = v * h + m * o + b, M[d++] = n.x0, M[d++] = n.y0, A[d++] = R, M[d++] = f, M[d++] = g * r + y * h + x, M[d++] = v * h + m * r + b, M[d++] = n.x1, M[d++] = n.y1, A[d++] = R, M[d++] = f, M[d++] = g * r + y * a + x, M[d++] = v * a + m * r + b, M[d++] = n.x2, M[d++] = n.y2, A[d++] = R, M[d++] = f, M[d++] = g * o + y * a + x, M[d++] = v * a + m * o + b, M[d++] = n.x3, M[d++] = n.y3, A[d++] = R, M[d++] = f), this.sprites[this.currentBatchSize++] = t
            }
        }, i.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) {
            var e = t.tilingTexture,
                s = t.texture.baseTexture.textureIndex;
            this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = e.baseTexture), t._uvs || (t._uvs = new i.TextureUvs);
            var n = t._uvs,
                r = e.baseTexture.width,
                o = e.baseTexture.height;
            t.tilePosition.x %= r * t.tileScaleOffset.x, t.tilePosition.y %= o * t.tileScaleOffset.y;
            var a = t.tilePosition.x / (r * t.tileScaleOffset.x),
                h = t.tilePosition.y / (o * t.tileScaleOffset.y),
                l = t.width / r / (t.tileScale.x * t.tileScaleOffset.x),
                c = t.height / o / (t.tileScale.y * t.tileScaleOffset.y);
            n.x0 = 0 - a, n.y0 = 0 - h, n.x1 = 1 * l - a, n.y1 = 0 - h, n.x2 = 1 * l - a, n.y2 = 1 * c - h, n.x3 = 0 - a, n.y3 = 1 * c - h;
            var u = t.tint,
                d = (u >> 16) + (65280 & u) + ((255 & u) << 16) + (255 * t.worldAlpha << 24),
                p = this.positions,
                f = this.colors,
                g = t.width,
                m = t.height,
                y = t.anchor.x,
                v = t.anchor.y,
                x = g * (1 - y),
                b = g * -y,
                _ = m * (1 - v),
                T = m * -v,
                w = this.currentBatchSize * this.vertexSize,
                S = e.baseTexture.resolution,
                C = t.worldTransform,
                E = C.a / S,
                P = C.b / S,
                A = C.c / S,
                M = C.d / S,
                k = C.tx,
                R = C.ty;
            p[w++] = E * b + A * T + k, p[w++] = M * T + P * b + R, p[w++] = n.x0, p[w++] = n.y0, f[w++] = d, p[w++] = s, p[w++] = E * x + A * T + k, p[w++] = M * T + P * x + R, p[w++] = n.x1, p[w++] = n.y1, f[w++] = d, p[w++] = s, p[w++] = E * x + A * _ + k, p[w++] = M * _ + P * x + R, p[w++] = n.x2, p[w++] = n.y2, f[w++] = d, p[w++] = s, p[w++] = E * b + A * _ + k, p[w++] = M * _ + P * b + R, p[w++] = n.x3, p[w++] = n.y3, f[w++] = d, p[w++] = s, this.sprites[this.currentBatchSize++] = t
        }, i.WebGLSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var t, e, s, n, r = this.gl;
                if (this.dirty) {
                    this.dirty = !1, t = this.defaultShader.shaders[r.id], r.activeTexture(r.TEXTURE0), r.bindBuffer(r.ARRAY_BUFFER, this.vertexBuffer), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                    var o = this.vertexSize;
                    r.vertexAttribPointer(t.aVertexPosition, 2, r.FLOAT, !1, o, 0), r.vertexAttribPointer(t.aTextureCoord, 2, r.FLOAT, !1, o, 8), r.vertexAttribPointer(t.colorAttribute, 4, r.UNSIGNED_BYTE, !0, o, 16), r.vertexAttribPointer(t.aTextureIndex, 1, r.FLOAT, !1, o, 20)
                }
                if (this.currentBatchSize > .5 * this.size) r.bufferSubData(r.ARRAY_BUFFER, 0, this.vertices);
                else {
                    r.bindBuffer(r.ARRAY_BUFFER, this.vertexBuffer);
                    var a = this.positions.subarray(0, this.currentBatchSize * this.vertexSize);
                    r.bufferSubData(r.ARRAY_BUFFER, 0, a)
                }
                for (var h, l = 0, c = 0, u = null, d = this.renderSession.blendModeManager.currentBlendMode, p = null, f = !1, g = !1, m = 0, y = this.currentBatchSize; m < y; m++) {
                    e = (h = this.sprites[m]).tilingTexture ? h.tilingTexture.baseTexture : h.texture.baseTexture, f = d !== (s = h.blendMode), g = p !== (n = h.shader || this.defaultShader);
                    var v = e.skipRender;
                    if (v && h.children.length > 0 && (v = !1), (u !== e && !v || f || g) && (this.renderBatch(u, l, c), c = m, l = 0, u = e, f && (d = s, this.renderSession.blendModeManager.setBlendMode(d)), g)) {
                        (t = (p = n).shaders[r.id]) || ((t = new i.PixiShader(r)).fragmentSrc = p.fragmentSrc, t.uniforms = p.uniforms, t.init(), p.shaders[r.id] = t), this.renderSession.shaderManager.setShader(t), t.dirty && t.syncUniforms();
                        var x = this.renderSession.projection;
                        r.uniform2f(t.projectionVector, x.x, x.y);
                        var b = this.renderSession.offset;
                        r.uniform2f(t.offsetVector, b.x, b.y)
                    }
                    l++
                }
                this.renderBatch(u, l, c), this.currentBatchSize = 0
            }
        }, i.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) {
            if (0 !== e) {
                var s = this.gl;
                if (t._dirty[s.id]) {
                    if (!this.renderSession.renderer.updateTexture(t)) return
                } else s.bindTexture(s.TEXTURE_2D, t._glTextures[s.id]);
                s.drawElements(s.TRIANGLES, 6 * e, s.UNSIGNED_SHORT, 6 * i * 2), this.renderSession.drawCount++
            }
        }, i.WebGLSpriteBatch.prototype.stop = function() {
            this.flush(), this.dirty = !0
        }, i.WebGLSpriteBatch.prototype.start = function() {
            this.dirty = !0
        }, i.WebGLSpriteBatch.prototype.destroy = function() {
            this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null
        }, i.WebGLFastSpriteBatch = function(t) {
            this.vertSize = 11, this.maxSize = 6e3, this.size = this.maxSize;
            var e = 4 * this.size * this.vertSize,
                i = 6 * this.maxSize;
            this.vertices = new Float32Array(e), this.indices = new Uint16Array(i), this.vertexBuffer = null, this.indexBuffer = null, this.lastIndexCount = 0;
            for (var s = 0, n = 0; s < i; s += 6, n += 4) this.indices[s + 0] = n + 0, this.indices[s + 1] = n + 1, this.indices[s + 2] = n + 2, this.indices[s + 3] = n + 0, this.indices[s + 4] = n + 2, this.indices[s + 5] = n + 3;
            this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(t)
        }, i.WebGLFastSpriteBatch.prototype.constructor = i.WebGLFastSpriteBatch, i.WebGLFastSpriteBatch.prototype.setContext = function(t) {
            this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW)
        }, i.WebGLFastSpriteBatch.prototype.begin = function(t, e) {
            this.renderSession = e, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = t.worldTransform.toArray(!0), this.start()
        }, i.WebGLFastSpriteBatch.prototype.end = function() {
            this.flush()
        }, i.WebGLFastSpriteBatch.prototype.render = function(t) {
            var e = t.children,
                s = e[0];
            if (s.texture._uvs) {
                this.currentBaseTexture = s.texture.baseTexture, s.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(s.blendMode));
                var n = this.currentBaseTexture.textureIndex,
                    r = this.gl;
                r.activeTexture(r.TEXTURE0 + n), r.bindTexture(r.TEXTURE_2D, this.currentBaseTexture._glTextures[r.id]), i.WebGLRenderer.textureArray[n] = this.currentBaseTexture;
                for (var o = 0, a = e.length; o < a; o++) this.renderSprite(e[o]);
                this.flush()
            }
        }, i.WebGLFastSpriteBatch.prototype.renderSprite = function(t) {
            var e = t.texture.baseTexture,
                s = this.gl,
                n = t.texture.baseTexture.textureIndex;
            if ((i.WebGLRenderer.textureArray[n] == e || !e._glTextures[s.id] || t.texture.baseTexture.skipRender || (this.flush(), s.activeTexture(s.TEXTURE0 + n), s.bindTexture(s.TEXTURE_2D, e._glTextures[s.id]), i.WebGLRenderer.textureArray[n] = e, t.texture._uvs)) && t.visible) {
                var r, o, a, h, l, c, u, d, p = this.vertices;
                if (r = t.texture._uvs, o = t.texture.frame.width, a = t.texture.frame.height, t.texture.trim) {
                    var f = t.texture.trim;
                    h = (l = f.x - t.anchor.x * f.width) + t.texture.crop.width, c = (u = f.y - t.anchor.y * f.height) + t.texture.crop.height
                } else h = o * (1 - t.anchor.x), l = o * -t.anchor.x, c = a * (1 - t.anchor.y), u = a * -t.anchor.y;
                d = 4 * this.currentBatchSize * this.vertSize, p[d++] = l, p[d++] = u, p[d++] = t.position.x, p[d++] = t.position.y, p[d++] = t.scale.x, p[d++] = t.scale.y, p[d++] = t.rotation, p[d++] = r.x0, p[d++] = r.y1, p[d++] = t.alpha, p[d++] = n, p[d++] = h, p[d++] = u, p[d++] = t.position.x, p[d++] = t.position.y, p[d++] = t.scale.x, p[d++] = t.scale.y, p[d++] = t.rotation, p[d++] = r.x1, p[d++] = r.y1, p[d++] = t.alpha, p[d++] = n, p[d++] = h, p[d++] = c, p[d++] = t.position.x, p[d++] = t.position.y, p[d++] = t.scale.x, p[d++] = t.scale.y, p[d++] = t.rotation, p[d++] = r.x2, p[d++] = r.y2, p[d++] = t.alpha, p[d++] = n, p[d++] = l, p[d++] = c, p[d++] = t.position.x, p[d++] = t.position.y, p[d++] = t.scale.x, p[d++] = t.scale.y, p[d++] = t.rotation, p[d++] = r.x3, p[d++] = r.y3, p[d++] = t.alpha, p[d++] = n, this.currentBatchSize++, this.currentBatchSize >= this.size && this.flush()
            }
        }, i.WebGLFastSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var t = this.gl;
                if (this.currentBaseTexture._glTextures[t.id]) {
                    if (this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
                    else {
                        var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                        t.bufferSubData(t.ARRAY_BUFFER, 0, e)
                    }
                    t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++
                } else this.renderSession.renderer.updateTexture(this.currentBaseTexture, t)
            }
        }, i.WebGLFastSpriteBatch.prototype.stop = function() {
            this.flush()
        }, i.WebGLFastSpriteBatch.prototype.start = function() {
            var t = this.gl;
            t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            var e = this.renderSession.projection;
            t.uniform2f(this.shader.projectionVector, e.x, e.y), t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
            var i = 4 * this.vertSize;
            t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0), t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8), t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16), t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24), t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28), t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36), t.vertexAttribPointer(this.shader.aTextureIndex, 1, t.FLOAT, !1, i, 40)
        }, i.WebGLFilterManager = function() {
            this.filterStack = [], this.offsetX = 0, this.offsetY = 0
        }, i.WebGLFilterManager.prototype.constructor = i.WebGLFilterManager, i.WebGLFilterManager.prototype.setContext = function(t) {
            this.gl = t, this.texturePool = [], this.initShaderBuffers()
        }, i.WebGLFilterManager.prototype.begin = function(t, e) {
            this.renderSession = t, this.defaultShader = t.shaderManager.defaultShader;
            var i = this.renderSession.projection;
            this.width = 2 * i.x, this.height = 2 * -i.y, this.buffer = e
        }, i.WebGLFilterManager.prototype.pushFilter = function(t) {
            var e = this.gl,
                s = this.renderSession.projection,
                n = this.renderSession.offset;
            t._filterArea = t.target.filterArea || t.target.getBounds(), t._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new i.WebGLStencilManager, this.renderSession.stencilManager.setContext(e), e.disable(e.STENCIL_TEST), this.filterStack.push(t);
            var r = t.filterPasses[0];
            this.offsetX += t._filterArea.x, this.offsetY += t._filterArea.y;
            var o = this.texturePool.pop();
            o ? o.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : o = new i.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), e.bindTexture(e.TEXTURE_2D, o.texture);
            var a = t._filterArea,
                h = r.padding;
            a.x -= h, a.y -= h, a.width += 2 * h, a.height += 2 * h, a.x < 0 && (a.x = 0), a.width > this.width && (a.width = this.width), a.y < 0 && (a.y = 0), a.height > this.height && (a.height = this.height), e.bindFramebuffer(e.FRAMEBUFFER, o.frameBuffer), e.viewport(0, 0, a.width * this.renderSession.resolution, a.height * this.renderSession.resolution), s.x = a.width / 2, s.y = -a.height / 2, n.x = -a.x, n.y = -a.y, e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), t._glFilterTexture = o
        }, i.WebGLFilterManager.prototype.popFilter = function() {
            var t = this.gl,
                e = this.filterStack.pop(),
                s = e._filterArea,
                n = e._glFilterTexture,
                r = this.renderSession.projection,
                o = this.renderSession.offset;
            if (e.filterPasses.length > 1) {
                t.viewport(0, 0, s.width * this.renderSession.resolution, s.height * this.renderSession.resolution), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = s.height, this.vertexArray[2] = s.width, this.vertexArray[3] = s.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = s.width, this.vertexArray[7] = 0, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = s.width / this.width, this.uvArray[5] = s.height / this.height, this.uvArray[6] = s.width / this.width, this.uvArray[7] = s.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
                var a = n,
                    h = this.texturePool.pop();
                h || (h = new i.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)), h.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.clear(t.COLOR_BUFFER_BIT), t.disable(t.BLEND);
                for (var l = 0; l < e.filterPasses.length - 1; l++) {
                    var c = e.filterPasses[l];
                    t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, a.texture), this.applyFilterPass(c, s, s.width, s.height);
                    var u = a;
                    a = h, h = u
                }
                t.enable(t.BLEND), n = a, this.texturePool.push(h)
            }
            var d = e.filterPasses[e.filterPasses.length - 1];
            this.offsetX -= s.x, this.offsetY -= s.y;
            var p = this.width,
                f = this.height,
                g = 0,
                m = 0,
                y = this.buffer;
            if (0 === this.filterStack.length) t.colorMask(!0, !0, !0, !0);
            else {
                var v = this.filterStack[this.filterStack.length - 1];
                p = (s = v._filterArea).width, f = s.height, g = s.x, m = s.y, y = v._glFilterTexture.frameBuffer
            }
            r.x = p / 2, r.y = -f / 2, o.x = g, o.y = m;
            var x = (s = e._filterArea).x - g,
                b = s.y - m;
            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = x, this.vertexArray[1] = b + s.height, this.vertexArray[2] = x + s.width, this.vertexArray[3] = b + s.height, this.vertexArray[4] = x, this.vertexArray[5] = b, this.vertexArray[6] = x + s.width, this.vertexArray[7] = b, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = s.width / this.width, this.uvArray[5] = s.height / this.height, this.uvArray[6] = s.width / this.width, this.uvArray[7] = s.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray), t.viewport(0, 0, p * this.renderSession.resolution, f * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, y), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = e._previous_stencil_mgr, e._previous_stencil_mgr = null, this.renderSession.stencilManager.count > 0 ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.applyFilterPass(d, s, p, f), this.texturePool.push(n), e._glFilterTexture = null
        }, i.WebGLFilterManager.prototype.applyFilterPass = function(t, e, s, n) {
            var r = this.gl,
                o = t.shaders[r.id];
            o || ((o = new i.PixiShader(r)).fragmentSrc = t.fragmentSrc, o.uniforms = t.uniforms, o.init(!0), t.shaders[r.id] = o), this.renderSession.shaderManager.setShader(o), r.uniform2f(o.projectionVector, s / 2, -n / 2), r.uniform2f(o.offsetVector, 0, 0), t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width, t.uniforms.dimensions.value[1] = this.height, t.uniforms.dimensions.value[2] = this.vertexArray[0], t.uniforms.dimensions.value[3] = this.vertexArray[5]), o.syncUniforms(), r.bindBuffer(r.ARRAY_BUFFER, this.vertexBuffer), r.vertexAttribPointer(o.aVertexPosition, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, this.uvBuffer), r.vertexAttribPointer(o.aTextureCoord, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, this.colorBuffer), r.vertexAttribPointer(o.colorAttribute, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this.indexBuffer), r.drawElements(r.TRIANGLES, 6, r.UNSIGNED_SHORT, 0), this.renderSession.drawCount++
        }, i.WebGLFilterManager.prototype.initShaderBuffers = function() {
            var t = this.gl;
            this.vertexBuffer = t.createBuffer(), this.uvBuffer = t.createBuffer(), this.colorBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.vertexArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW), this.uvArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW), this.colorArray = new Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer), t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
        }, i.WebGLFilterManager.prototype.destroy = function() {
            var t = this.gl;
            this.filterStack = null, this.offsetX = 0, this.offsetY = 0;
            for (var e = 0; e < this.texturePool.length; e++) this.texturePool[e].destroy();
            this.texturePool = null, t.deleteBuffer(this.vertexBuffer), t.deleteBuffer(this.uvBuffer), t.deleteBuffer(this.colorBuffer), t.deleteBuffer(this.indexBuffer)
        };
        var s = {
            36054: "Incomplete attachment",
            36055: "Missing attachment",
            36057: "Incomplete dimensions",
            36061: "Framebuffer unsupported"
        };

        function n(t, e, n, r, o) {
            var a, h, l, c, u, d, p = t.createFramebuffer(),
                f = t.createRenderbuffer(),
                g = null;
            return t.activeTexture(t.TEXTURE0 + o), t.bindFramebuffer(t.FRAMEBUFFER, p), t.bindRenderbuffer(t.RENDERBUFFER, f), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.renderBuffer), l = e, c = n, u = r, d = (h = t).createTexture(), h.bindTexture(h.TEXTURE_2D, d), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, u === i.scaleModes.LINEAR ? h.LINEAR : h.NEAREST), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, u === i.scaleModes.LINEAR ? h.LINEAR : h.NEAREST), h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, l, c, 0, h.RGBA, h.UNSIGNED_BYTE, null), g = d, t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, g, 0), (a = t.checkFramebufferStatus(t.FRAMEBUFFER)) !== t.FRAMEBUFFER_COMPLETE && console.error("Incomplete GL framebuffer. ", s[a]), p.width = e, p.height = n, p.targetTexture = g, p.renderBuffer = f, p
        }
        return i.FilterTexture = function(t, e, s, r, o) {
            o = "number" == typeof o ? o : 0, this.gl = t, this.frameBuffer = n(t, e, s, r || i.scaleModes.DEFAULT, o), this.texture = this.frameBuffer.targetTexture, this.width = e, this.height = s, this.renderBuffer = this.frameBuffer.renderBuffer
        }, i.FilterTexture.prototype.constructor = i.FilterTexture, i.FilterTexture.prototype.clear = function() {
            var t = this.gl;
            t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT)
        }, i.FilterTexture.prototype.resize = function(t, e) {
            if (this.width !== t || this.height !== e) {
                this.width = t, this.height = e;
                var i = this.gl;
                i.bindTexture(i.TEXTURE_2D, this.texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e)
            }
        }, i.FilterTexture.prototype.destroy = function() {
            var t = this.gl;
            t.deleteFramebuffer(this.frameBuffer), t.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
        }, i.CanvasBuffer = function(t, e) {
            this.width = t, this.height = e, this.canvas = Phaser.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = e
        }, i.CanvasBuffer.prototype.constructor = i.CanvasBuffer, i.CanvasBuffer.prototype.clear = function() {
            this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height)
        }, i.CanvasBuffer.prototype.resize = function(t, e) {
            this.width = this.canvas.width = t, this.height = this.canvas.height = e
        }, i.CanvasBuffer.prototype.destroy = function() {
            Phaser.CanvasPool.remove(this)
        }, i.CanvasMaskManager = function() {}, i.CanvasMaskManager.prototype.constructor = i.CanvasMaskManager, i.CanvasMaskManager.prototype.pushMask = function(t, e) {
            var s = e.context;
            s.save();
            var n = t.alpha,
                r = t.worldTransform,
                o = e.resolution;
            s.setTransform(r.a * o, r.b * o, r.c * o, r.d * o, r.tx * o, r.ty * o), i.CanvasGraphics.renderGraphicsMask(t, s), s.clip(), t.worldAlpha = n
        }, i.CanvasMaskManager.prototype.popMask = function(t) {
            t.context.restore()
        }, i.CanvasTinter = function() {}, i.CanvasTinter.getTintedTexture = function(t, e) {
            var s = t.tintedTexture || Phaser.CanvasPool.create(this);
            return i.CanvasTinter.tintMethod(t.texture, e, s), s
        }, i.CanvasTinter.tintWithMultiply = function(t, e, i) {
            var s = i.getContext("2d"),
                n = t.crop,
                r = n.width,
                o = n.height;
            t.rotated && (r = o, o = n.width), i.width === r && i.height === o || (i.width = r, i.height = o), s.clearRect(0, 0, r, o), s.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), s.fillRect(0, 0, r, o), s.globalCompositeOperation = "multiply", s.drawImage(t.baseTexture.source, n.x, n.y, r, o, 0, 0, r, o), s.globalCompositeOperation = "destination-atop", s.drawImage(t.baseTexture.source, n.x, n.y, r, o, 0, 0, r, o)
        }, i.CanvasTinter.tintWithPerPixel = function(t, e, s) {
            var n = s.getContext("2d"),
                r = t.crop,
                o = r.width,
                a = r.height;
            t.rotated && (o = a, a = r.width), s.width === o && s.height === a || (s.width = o, s.height = a), n.globalCompositeOperation = "copy", n.drawImage(t.baseTexture.source, r.x, r.y, o, a, 0, 0, o, a);
            for (var h = Phaser.Color.hexToRGBArray(e), l = h[0], c = h[1], u = h[2], d = n.getImageData(0, 0, o, a), p = d.data, f = 0; f < p.length; f += 4)
                if (p[f + 0] *= l, p[f + 1] *= c, p[f + 2] *= u, !i.CanvasTinter.canHandleAlpha) {
                    var g = p[f + 3];
                    p[f + 0] /= 255 / g, p[f + 1] /= 255 / g, p[f + 2] /= 255 / g
                } n.putImageData(d, 0, 0)
        }, i.CanvasRenderer = function(t, e) {
            if (this.game = t, i.defaultRenderer || (i.defaultRenderer = this), this.type = Phaser.CANVAS, this.resolution = t.resolution, this.clearBeforeRender = t.clearBeforeRender, this.transparent = t.transparent, this.autoResize = !1, this.width = t.width * this.resolution, this.height = t.height * this.resolution, this.view = t.canvas, this.context = this.view.getContext("2d", {
                    alpha: this.transparent
                }), !this.context) throw new Error("Failed to create a Canvas 2d context.");
            this.refresh = !0, this.count = 0, this.maskManager = new i.CanvasMaskManager, this.renderSession = {
                context: this.context,
                maskManager: this.maskManager,
                scaleMode: null,
                smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
                roundPixels: e.roundPixels || !1
            }, this.mapBlendModes(), this.resize(this.width, this.height)
        }, i.CanvasRenderer.prototype.constructor = i.CanvasRenderer, i.CanvasRenderer.prototype.render = function(t) {
            this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(t)
        }, i.CanvasRenderer.prototype.setTexturePriority = function() {}, i.CanvasRenderer.prototype.destroy = function(t) {
            void 0 === t && (t = !0), t && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null
        }, i.CanvasRenderer.prototype.resize = function(t, e) {
            this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === i.scaleModes.LINEAR)
        }, i.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) {
            this.renderSession.context = e || this.context, this.renderSession.resolution = this.resolution, t._renderCanvas(this.renderSession, i)
        }, i.CanvasRenderer.prototype.mapBlendModes = function() {
            if (!i.blendModesCanvas) {
                var t = [],
                    e = i.blendModes,
                    s = this.game.device.canUseMultiply;
                t[e.NORMAL] = "source-over", t[e.ADD] = "lighter", t[e.MULTIPLY] = s ? "multiply" : "source-over", t[e.SCREEN] = s ? "screen" : "source-over", t[e.OVERLAY] = s ? "overlay" : "source-over", t[e.DARKEN] = s ? "darken" : "source-over", t[e.LIGHTEN] = s ? "lighten" : "source-over", t[e.COLOR_DODGE] = s ? "color-dodge" : "source-over", t[e.COLOR_BURN] = s ? "color-burn" : "source-over", t[e.HARD_LIGHT] = s ? "hard-light" : "source-over", t[e.SOFT_LIGHT] = s ? "soft-light" : "source-over", t[e.DIFFERENCE] = s ? "difference" : "source-over", t[e.EXCLUSION] = s ? "exclusion" : "source-over", t[e.HUE] = s ? "hue" : "source-over", t[e.SATURATION] = s ? "saturation" : "source-over", t[e.COLOR] = s ? "color" : "source-over", t[e.LUMINOSITY] = s ? "luminosity" : "source-over", i.blendModesCanvas = t
            }
        }, i.BaseTexture = function(t, e, s) {
            this.resolution = s || 1, this.width = 100, this.height = 100, this.scaleMode = e || i.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = t, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this.textureIndex = 0, this._dirty = [!0, !0, !0, !0], t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1)
        }, i.BaseTexture.prototype.constructor = i.BaseTexture, i.BaseTexture.prototype.forceLoaded = function(t, e) {
            this.hasLoaded = !0, this.width = t, this.height = e, this.dirty()
        }, i.BaseTexture.prototype.destroy = function() {
            this.source && Phaser.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU()
        }, i.BaseTexture.prototype.dirty = function() {
            for (var t = 0; t < this._glTextures.length; t++) this._dirty[t] = !0
        }, i.BaseTexture.prototype.unloadFromGPU = function() {
            this.dirty();
            for (var t = this._glTextures.length - 1; t >= 0; t--) {
                var e = this._glTextures[t],
                    s = i.glContexts[t];
                s && e && s.deleteTexture(e)
            }
            this._glTextures.length = 0, this.dirty()
        }, i.BaseTexture.fromCanvas = function(t, e, s) {
            return 0 === t.width && (t.width = 1), 0 === t.height && (t.height = 1), s = s || 1, new i.BaseTexture(t, e, s)
        }, i.TextureSilentFail = !1, i.Texture = function(t, e, s, n) {
            this.noFrame = !1, e || (this.noFrame = !0, e = new i.Rectangle(0, 0, 1, 1)), t instanceof i.Texture && (t = t.baseTexture), this.baseTexture = t, this.frame = e, this.trim = n, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = s || new i.Rectangle(0, 0, 1, 1), this.rotated = !1, t.hasLoaded && (this.noFrame && (e = new i.Rectangle(0, 0, t.width, t.height)), this.setFrame(e))
        }, i.Texture.prototype.constructor = i.Texture, i.Texture.prototype.onBaseTextureLoaded = function() {
            var t = this.baseTexture;
            this.noFrame && (this.frame = new i.Rectangle(0, 0, t.width, t.height)), this.setFrame(this.frame)
        }, i.Texture.prototype.destroy = function(t) {
            t && this.baseTexture.destroy(), this.valid = !1
        }, i.Texture.prototype.setFrame = function(t) {
            if (this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, this.trim || !(t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs();
            else {
                if (!i.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
                this.valid = !1
            }
        }, i.Texture.prototype._updateUvs = function() {
            this._uvs || (this._uvs = new i.TextureUvs);
            var t = this.crop,
                e = this.baseTexture.width,
                s = this.baseTexture.height;
            this._uvs.x0 = t.x / e, this._uvs.y0 = t.y / s, this._uvs.x1 = (t.x + t.width) / e, this._uvs.y1 = t.y / s, this._uvs.x2 = (t.x + t.width) / e, this._uvs.y2 = (t.y + t.height) / s, this._uvs.x3 = t.x / e, this._uvs.y3 = (t.y + t.height) / s
        }, i.Texture.prototype._updateUvsInverted = function() {
            this._uvs || (this._uvs = new i.TextureUvs);
            var t = this.crop,
                e = this.baseTexture.width,
                s = this.baseTexture.height;
            this._uvs.x0 = t.x / e, this._uvs.y0 = t.y / s, this._uvs.x1 = (t.x + t.height) / e, this._uvs.y1 = t.y / s, this._uvs.x2 = (t.x + t.height) / e, this._uvs.y2 = (t.y + t.width) / s, this._uvs.x3 = t.x / e, this._uvs.y3 = (t.y + t.width) / s
        }, i.Texture.fromCanvas = function(t, e) {
            var s = i.BaseTexture.fromCanvas(t, e);
            return new i.Texture(s)
        }, i.TextureUvs = function() {
            this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0
        }, void 0 !== t && t.exports && (e = t.exports = i), e.PIXI = i, i
    }).call(this)
}, function(t, e, i) {
    (function(i) {
        (function() {
            var i = i || {};
            i.DisplayObject = function() {
                this.position = new i.Point(0, 0), this.scale = new i.Point(1, 1), this.pivot = new i.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new Phaser.Matrix, this.worldPosition = new i.Point(0, 0), this.worldScale = new i.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new i.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1
            }, i.DisplayObject.prototype = {
                constructor: i.DisplayObject,
                destroy: function() {
                    if (this.children) {
                        for (var t = this.children.length; t--;) this.children[t].destroy();
                        this.children = []
                    }
                    this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), this._destroyTintedTexture()
                },
                updateTransform: function(t) {
                    if (!t && !this.parent && !this.game) return this;
                    var e = this.parent;
                    t ? e = t : this.parent || (e = this.game.world);
                    var i, s, n, r, o, a, h = e.worldTransform,
                        l = this.worldTransform;
                    this.rotation % Phaser.Math.PI2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), i = this._cr * this.scale.x, s = this._sr * this.scale.x, n = -this._sr * this.scale.y, r = this._cr * this.scale.y, o = this.position.x, a = this.position.y, (this.pivot.x || this.pivot.y) && (o -= this.pivot.x * i + this.pivot.y * n, a -= this.pivot.x * s + this.pivot.y * r), l.a = i * h.a + s * h.c, l.b = i * h.b + s * h.d, l.c = n * h.a + r * h.c, l.d = n * h.b + r * h.d, l.tx = o * h.a + a * h.c + h.tx, l.ty = o * h.b + a * h.d + h.ty) : (i = this.scale.x, s = 0, n = 0, r = this.scale.y, o = this.position.x - this.pivot.x * i, a = this.position.y - this.pivot.y * r, l.a = i * h.a, l.b = i * h.b, l.c = r * h.c, l.d = r * h.d, l.tx = o * h.a + a * h.c + h.tx, l.ty = o * h.b + a * h.d + h.ty), i = l.a, s = l.b, n = l.c;
                    var c = i * (r = l.d) - s * n;
                    if (i || s) {
                        var u = Math.sqrt(i * i + s * s);
                        this.worldRotation = s > 0 ? Math.acos(i / u) : -Math.acos(i / u), this.worldScale.x = u, this.worldScale.y = c / u
                    } else if (n || r) {
                        var d = Math.sqrt(n * n + r * r);
                        this.worldRotation = Phaser.Math.HALF_PI - (r > 0 ? Math.acos(-n / d) : -Math.acos(n / d)), this.worldScale.x = c / d, this.worldScale.y = d
                    } else this.worldScale.x = 0, this.worldScale.y = 0;
                    return this.worldAlpha = this.alpha * e.worldAlpha, this.worldPosition.x = l.tx, this.worldPosition.y = l.ty, this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, l, h), this
                },
                preUpdate: function() {},
                generateTexture: function(t, e, s) {
                    var n = this.getLocalBounds(),
                        r = new Phaser.RenderTexture(this.game, 0 | n.width, 0 | n.height, s, e, t);
                    return i.DisplayObject._tempMatrix.tx = -n.x, i.DisplayObject._tempMatrix.ty = -n.y, r.render(this, i.DisplayObject._tempMatrix), r
                },
                updateCache: function() {
                    return this._generateCachedSprite(), this
                },
                toGlobal: function(t) {
                    return this.updateTransform(), this.worldTransform.apply(t)
                },
                toLocal: function(t, e) {
                    return e && (t = e.toGlobal(t)), this.updateTransform(), this.worldTransform.applyInverse(t)
                },
                _renderCachedSprite: function(t) {
                    this._cachedSprite.worldAlpha = this.worldAlpha, t.gl ? i.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : i.Sprite.prototype._renderCanvas.call(this._cachedSprite, t)
                },
                _generateCachedSprite: function() {
                    this._cacheAsBitmap = !1;
                    var t = this.getLocalBounds();
                    if (t.width = Math.max(1, Math.ceil(t.width)), t.height = Math.max(1, Math.ceil(t.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(t.width, t.height);
                    else {
                        var e = 0;
                        this.texture && this.texture.baseTexture && i._enableMultiTextureToggle && (e = this.texture.baseTexture.textureIndex);
                        var s = new Phaser.RenderTexture(this.game, t.width, t.height, void 0, void 0, void 0, void 0, e);
                        this._cachedSprite = new i.Sprite(s), this._cachedSprite.worldTransform = this.worldTransform
                    }
                    var n = this._filters;
                    this._filters = null, this._cachedSprite.filters = n, i.DisplayObject._tempMatrix.tx = -t.x, i.DisplayObject._tempMatrix.ty = -t.y, this._cachedSprite.texture.render(this, i.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._filters = n, this._cacheAsBitmap = !0
                },
                _destroyCachedSprite: function() {
                    this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
                },
                _destroyTintedTexture: function() {
                    this.tintedTexture && (Phaser.CanvasPool.removeByCanvas(this.tintedTexture), this.tintedTexture = null)
                }
            }, i.DisplayObject.prototype.displayObjectUpdateTransform = i.DisplayObject.prototype.updateTransform, Object.defineProperties(i.DisplayObject.prototype, {
                x: {
                    get: function() {
                        return this.position.x
                    },
                    set: function(t) {
                        this.position.x = t
                    }
                },
                y: {
                    get: function() {
                        return this.position.y
                    },
                    set: function(t) {
                        this.position.y = t
                    }
                },
                worldVisible: {
                    get: function() {
                        if (this.visible) {
                            var t = this.parent;
                            if (!t) return this.visible;
                            do {
                                if (!t.visible) return !1;
                                t = t.parent
                            } while (t);
                            return !0
                        }
                        return !1
                    }
                },
                mask: {
                    get: function() {
                        return this._mask
                    },
                    set: function(t) {
                        this._mask && (this._mask.isMask = !1), this._mask = t, t && (this._mask.isMask = !0)
                    }
                },
                filters: {
                    get: function() {
                        return this._filters
                    },
                    set: function(t) {
                        if (Array.isArray(t)) {
                            for (var e = [], s = 0; s < t.length; s++)
                                for (var n = t[s].passes, r = 0; r < n.length; r++) e.push(n[r]);
                            this._filterBlock = {
                                target: this,
                                filterPasses: e
                            }
                        }
                        this._filters = t, this.blendMode && this.blendMode === i.blendModes.MULTIPLY && (this.blendMode = i.blendModes.NORMAL)
                    }
                },
                cacheAsBitmap: {
                    get: function() {
                        return this._cacheAsBitmap
                    },
                    set: function(t) {
                        this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t)
                    }
                }
            }), i.DisplayObjectContainer = function() {
                i.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1
            }, i.DisplayObjectContainer.prototype = Object.create(i.DisplayObject.prototype), i.DisplayObjectContainer.prototype.constructor = i.DisplayObjectContainer, i.DisplayObjectContainer.prototype.addChild = function(t) {
                return this.addChildAt(t, this.children.length)
            }, i.DisplayObjectContainer.prototype.addChildAt = function(t, e) {
                if (e >= 0 && e <= this.children.length) return t.parent && t.parent.removeChild(t), t.parent = this, this.children.splice(e, 0, t), t;
                throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length)
            }, i.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
                if (t !== e) {
                    var i = this.getChildIndex(t),
                        s = this.getChildIndex(e);
                    if (i < 0 || s < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
                    this.children[i] = e, this.children[s] = t
                }
            }, i.DisplayObjectContainer.prototype.getChildIndex = function(t) {
                var e = this.children.indexOf(t);
                if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller");
                return e
            }, i.DisplayObjectContainer.prototype.setChildIndex = function(t, e) {
                if (e < 0 || e >= this.children.length) throw new Error("The supplied index is out of bounds");
                var i = this.getChildIndex(t);
                this.children.splice(i, 1), this.children.splice(e, 0, t)
            }, i.DisplayObjectContainer.prototype.getChildAt = function(t) {
                if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
                return this.children[t]
            }, i.DisplayObjectContainer.prototype.removeChild = function(t) {
                var e = this.children.indexOf(t);
                if (-1 !== e) return this.removeChildAt(e)
            }, i.DisplayObjectContainer.prototype.removeChildAt = function(t) {
                var e = this.getChildAt(t);
                return e && (e.parent = void 0, this.children.splice(t, 1)), e
            }, i.DisplayObjectContainer.prototype.bringChildToTop = function(t) {
                if (t.parent === this) return this.setChildIndex(t, this.children.length - 1)
            }, i.DisplayObjectContainer.prototype.sendChildToBack = function(t) {
                if (t.parent === this) return this.setChildIndex(t, 0)
            }, i.DisplayObjectContainer.prototype.removeChildren = function(t, e) {
                void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
                var i = e - t;
                if (i > 0 && i <= e) {
                    for (var s = this.children.splice(t, i), n = 0; n < s.length; n++) {
                        s[n].parent = void 0
                    }
                    return s
                }
                if (0 === i && 0 === this.children.length) return [];
                throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
            }, i.DisplayObjectContainer.prototype.updateTransform = function() {
                if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap))
                    for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
            }, i.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = i.DisplayObjectContainer.prototype.updateTransform, i.DisplayObjectContainer.prototype.getBounds = function(t) {
                var e, s = t && t instanceof i.DisplayObject,
                    n = !0;
                if (s ? n = t instanceof i.DisplayObjectContainer && t.contains(this) : t = this, s) {
                    var r = t.worldTransform;
                    for (t.worldTransform = Phaser.identityMatrix, e = 0; e < t.children.length; e++) t.children[e].updateTransform()
                }
                var o, a, h, l = 1 / 0,
                    c = 1 / 0,
                    u = -1 / 0,
                    d = -1 / 0,
                    p = !1;
                for (e = 0; e < this.children.length; e++) {
                    this.children[e].visible && (p = !0, l = l < (o = this.children[e].getBounds()).x ? l : o.x, c = c < o.y ? c : o.y, a = o.width + o.x, h = o.height + o.y, u = u > a ? u : a, d = d > h ? d : h)
                }
                var f = this._bounds;
                if (!p) {
                    var g = (f = new i.Rectangle).x,
                        m = f.width + f.x,
                        y = f.y,
                        v = f.height + f.y,
                        x = this.worldTransform,
                        b = x.a,
                        _ = x.b,
                        T = x.c,
                        w = x.d,
                        S = x.tx,
                        C = x.ty,
                        E = b * m + T * v + S,
                        P = w * v + _ * m + C,
                        A = b * g + T * v + S,
                        M = w * v + _ * g + C,
                        k = b * g + T * y + S,
                        R = w * y + _ * g + C,
                        O = b * m + T * y + S,
                        I = w * y + _ * m + C;
                    u = E, d = P, c = P, l = O < (l = k < (l = A < (l = E) ? A : l) ? k : l) ? O : l, c = I < (c = R < (c = M < c ? M : c) ? R : c) ? I : c, u = O > (u = k > (u = A > u ? A : u) ? k : u) ? O : u, d = I > (d = R > (d = M > d ? M : d) ? R : d) ? I : d
                }
                if (f.x = l, f.y = c, f.width = u - l, f.height = d - c, s)
                    for (t.worldTransform = r, e = 0; e < t.children.length; e++) t.children[e].updateTransform();
                if (!n) {
                    var L = t.getBounds();
                    f.x -= L.x, f.y -= L.y
                }
                return f
            }, i.DisplayObjectContainer.prototype.getLocalBounds = function() {
                return this.getBounds(this)
            }, i.DisplayObjectContainer.prototype.contains = function(t) {
                return !!t && (t === this || this.contains(t.parent))
            }, i.DisplayObjectContainer.prototype._renderWebGL = function(t) {
                var e;
                if (this.visible && !(this.alpha <= 0))
                    if (this._cacheAsBitmap) this._renderCachedSprite(t);
                    else if (this._mask || this._filters) {
                    for (this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                    t.spriteBatch.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), t.spriteBatch.start()
                } else
                    for (e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t)
            }, i.DisplayObjectContainer.prototype._renderCanvas = function(t) {
                if (!1 !== this.visible && 0 !== this.alpha)
                    if (this._cacheAsBitmap) this._renderCachedSprite(t);
                    else {
                        this._mask && t.maskManager.pushMask(this._mask, t);
                        for (var e = 0; e < this.children.length; e++) this.children[e]._renderCanvas(t);
                        this._mask && t.maskManager.popMask(t)
                    }
            }, Object.defineProperty(i.DisplayObjectContainer.prototype, "width", {
                get: function() {
                    return this.getLocalBounds().width * this.scale.x
                },
                set: function(t) {
                    var e = this.getLocalBounds().width;
                    this.scale.x = 0 !== e ? t / e : 1, this._width = t
                }
            }), Object.defineProperty(i.DisplayObjectContainer.prototype, "height", {
                get: function() {
                    return this.getLocalBounds().height * this.scale.y
                },
                set: function(t) {
                    var e = this.getLocalBounds().height;
                    this.scale.y = 0 !== e ? t / e : 1, this._height = t
                }
            }), i.Sprite = function(t) {
                i.DisplayObjectContainer.call(this), this.anchor = new i.Point(i.Sprite.defaultAnchor.x, i.Sprite.defaultAnchor.y), this.texture = t || i.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = i.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0
            }, i.Sprite.defaultAnchor = {
                x: 0,
                y: 0
            }, i.Sprite.prototype = Object.create(i.DisplayObjectContainer.prototype), i.Sprite.prototype.constructor = i.Sprite, Object.defineProperty(i.Sprite.prototype, "width", {
                get: function() {
                    return this.scale.x * this.texture.frame.width
                },
                set: function(t) {
                    this.scale.x = t / this.texture.frame.width, this._width = t
                }
            }), Object.defineProperty(i.Sprite.prototype, "height", {
                get: function() {
                    return this.scale.y * this.texture.frame.height
                },
                set: function(t) {
                    this.scale.y = t / this.texture.frame.height, this._height = t
                }
            }), i.Sprite.prototype.setTexture = function(t, e) {
                e && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = t, this.texture.valid = !0, this.cachedTint = -1
            }, i.Sprite.prototype.onTextureUpdate = function() {
                this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height)
            }, i.Sprite.prototype.getBounds = function(t) {
                var e = this.texture.frame.width,
                    i = this.texture.frame.height,
                    s = e * (1 - this.anchor.x),
                    n = e * -this.anchor.x,
                    r = i * (1 - this.anchor.y),
                    o = i * -this.anchor.y,
                    a = t || this.worldTransform,
                    h = a.a,
                    l = a.b,
                    c = a.c,
                    u = a.d,
                    d = a.tx,
                    p = a.ty,
                    f = -1 / 0,
                    g = -1 / 0,
                    m = 1 / 0,
                    y = 1 / 0;
                if (0 === l && 0 === c) {
                    if (h < 0) {
                        h *= -1;
                        var v = s;
                        s = -n, n = -v
                    }
                    if (u < 0) {
                        u *= -1;
                        v = r;
                        r = -o, o = -v
                    }
                    m = h * n + d, f = h * s + d, y = u * o + p, g = u * r + p
                } else {
                    var x = h * n + c * o + d,
                        b = u * o + l * n + p,
                        _ = h * s + c * o + d,
                        T = u * o + l * s + p,
                        w = h * s + c * r + d,
                        S = u * r + l * s + p,
                        C = h * n + c * r + d,
                        E = u * r + l * n + p;
                    m = C < (m = w < (m = _ < (m = x < m ? x : m) ? _ : m) ? w : m) ? C : m, y = E < (y = S < (y = T < (y = b < y ? b : y) ? T : y) ? S : y) ? E : y, f = C > (f = w > (f = _ > (f = x > f ? x : f) ? _ : f) ? w : f) ? C : f, g = E > (g = S > (g = T > (g = b > g ? b : g) ? T : g) ? S : g) ? E : g
                }
                var P = this._bounds;
                return P.x = m, P.width = f - m, P.y = y, P.height = g - y, this._currentBounds = P, P
            }, i.Sprite.prototype.getLocalBounds = function() {
                var t = this.worldTransform;
                this.worldTransform = Phaser.identityMatrix;
                for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
                var i = this.getBounds();
                for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
                return i
            }, i.Sprite.prototype._renderWebGL = function(t, e) {
                if (this.visible && !(this.alpha <= 0) && this.renderable) {
                    var i = this.worldTransform;
                    if (e && (i = e), this._mask || this._filters) {
                        var s = t.spriteBatch;
                        this._filters && (s.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (s.stop(), t.maskManager.pushMask(this.mask, t), s.start()), s.render(this);
                        for (var n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t);
                        s.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), s.start()
                    } else {
                        t.spriteBatch.render(this);
                        for (n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t, i)
                    }
                }
            }, i.Sprite.prototype._renderCanvas = function(t, e) {
                if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width < 1 || this.texture.crop.height < 1)) {
                    var s = this.worldTransform;
                    if (e && (s = e), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = i.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t), this.texture.valid) {
                        var n = this.texture.baseTexture.resolution / t.resolution;
                        t.context.globalAlpha = this.worldAlpha, t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === i.scaleModes.LINEAR);
                        var r = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                            o = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
                            a = s.tx * t.resolution + t.shakeX,
                            h = s.ty * t.resolution + t.shakeY,
                            l = this.texture.crop.width,
                            c = this.texture.crop.height;
                        if (this.texture.rotated) {
                            var u = s.a,
                                d = s.b,
                                p = s.c,
                                f = s.d,
                                g = l;
                            a = s.c * c + a, h = s.d * c + h, s.a = 6.123233995736766e-17 * u - p, s.b = 6.123233995736766e-17 * d - f, s.c = u + 6.123233995736766e-17 * p, s.d = d + 6.123233995736766e-17 * f, l = c, c = g
                        }
                        if (t.roundPixels ? (t.context.setTransform(s.a, s.b, s.c, s.d, 0 | a, 0 | h), r |= 0, o |= 0) : t.context.setTransform(s.a, s.b, s.c, s.d, a, h), r /= n, o /= n, c |= 0, (l |= 0) && c) {
                            if (16777215 !== this.tint)(this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = i.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), t.context.drawImage(this.tintedTexture, 0, 0, l, c, r, o, l / n, c / n);
                            else {
                                var m = this.texture.crop.x,
                                    y = this.texture.crop.y;
                                t.context.drawImage(this.texture.baseTexture.source, m, y, l, c, r, o, l / n, c / n)
                            }
                            for (v = 0; v < this.children.length; v++) this.children[v]._renderCanvas(t);
                            this._mask && t.maskManager.popMask(t)
                        }
                    } else {
                        for (var v = 0; v < this.children.length; v++) this.children[v]._renderCanvas(t);
                        this._mask && t.maskManager.popMask(t)
                    }
                }
            }, i.initDefaultShaders = function() {}, i.CompileVertexShader = function(t, e) {
                return i._CompileShader(t, e, t.VERTEX_SHADER)
            }, i.CompileFragmentShader = function(t, e) {
                return i._CompileShader(t, e, t.FRAGMENT_SHADER)
            }, i._CompileShader = function(t, e, i) {
                var s = e;
                Array.isArray(e) && (s = e.join("\n"));
                var n = t.createShader(i);
                return t.shaderSource(n, s), t.compileShader(n), t.getShaderParameter(n, t.COMPILE_STATUS) ? n : (window.console.log(t.getShaderInfoLog(n)), null)
            }, i.compileProgram = function(t, e, s) {
                var n = i.CompileFragmentShader(t, s),
                    r = i.CompileVertexShader(t, e),
                    o = t.createProgram();
                return t.attachShader(o, r), t.attachShader(o, n), t.linkProgram(o), t.getProgramParameter(o, t.LINK_STATUS) || (window.console.log(t.getProgramInfoLog(o)), window.console.log("Could not initialise shaders")), o
            }, i.PixiShader = function(t) {
                this._UID = Phaser._UID++, this.gl = t, this.program = null, this.fragmentSrc = null, this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init()
            }, i.PixiShader.prototype.constructor = i.PixiShader, i.PixiShader.prototype.initMultitexShader = function() {
                var t = this.gl;
                this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
                for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", s = 1; s < this.MAX_TEXTURES; ++s) e += "\tif (vTextureIndex == " + s + ".0) {gl_FragColor = texture2D(uSamplerArray[" + s + "], vTextureCoord) * vColor;return;}\n";
                this.fragmentSrc = ["// PixiShader Fragment Shader.", "precision lowp float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) { gl_FragColor = RED;return;}", "}"];
                var n = i.compileProgram(t, this.vertexSrc || i.PixiShader.defaultVertexSrc, this.fragmentSrc);
                t.useProgram(n), this.uSamplerArray = t.getUniformLocation(n, "uSamplerArray[0]"), this.projectionVector = t.getUniformLocation(n, "projectionVector"), this.offsetVector = t.getUniformLocation(n, "offsetVector"), this.dimensions = t.getUniformLocation(n, "dimensions"), this.aVertexPosition = t.getAttribLocation(n, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(n, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(n, "aColor"), this.aTextureIndex = t.getAttribLocation(n, "aTextureIndex");
                var r = [],
                    o = t.createTexture();
                t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, o), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
                for (var a = 0; a < this.MAX_TEXTURES; ++a) t.activeTexture(t.TEXTURE0 + a), t.bindTexture(t.TEXTURE_2D, o), r.push(a);
                t.activeTexture(t.TEXTURE0), t.uniform1iv(this.uSamplerArray, r), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex];
                for (var h in this.uniforms) this.uniforms[h].uniformLocation = t.getUniformLocation(n, h);
                this.initUniforms(), this.program = n
            }, i.PixiShader.prototype.initDefaultShader = function() {
                null === this.fragmentSrc && (this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"]);
                var t = this.gl,
                    e = i.compileProgram(t, this.vertexSrc || i.PixiShader.defaultVertexSrc, this.fragmentSrc);
                t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex];
                for (var s in this.uniforms) this.uniforms[s].uniformLocation = t.getUniformLocation(e, s);
                this.initUniforms(), this.program = e
            }, i.PixiShader.prototype.init = function(t) {
                i._enableMultiTextureToggle && !t ? this.initMultitexShader() : this.initDefaultShader()
            }, i.PixiShader.prototype.initUniforms = function() {
                this.textureCount = 1;
                var t, e = this.gl;
                for (var i in this.uniforms) {
                    var s = (t = this.uniforms[i]).type;
                    "sampler2D" === s ? (t._init = !1, null !== t.value && this.initSampler2D(t)) : "mat2" === s || "mat3" === s || "mat4" === s ? (t.glMatrix = !0, t.glValueLength = 1, "mat2" === s ? t.glFunc = e.uniformMatrix2fv : "mat3" === s ? t.glFunc = e.uniformMatrix3fv : "mat4" === s && (t.glFunc = e.uniformMatrix4fv)) : (t.glFunc = e["uniform" + s], t.glValueLength = "2f" === s || "2i" === s ? 2 : "3f" === s || "3i" === s ? 3 : "4f" === s || "4i" === s ? 4 : 1)
                }
            }, i.PixiShader.prototype.initSampler2D = function(t) {
                if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) {
                    var e = this.gl;
                    if (e.activeTexture(e.TEXTURE0 + this.textureCount), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), t.textureData) {
                        var i = t.textureData,
                            s = i.magFilter ? i.magFilter : e.LINEAR,
                            n = i.minFilter ? i.minFilter : e.LINEAR,
                            r = i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE,
                            o = i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE,
                            a = i.luminance ? e.LUMINANCE : e.RGBA;
                        if (i.repeat && (r = e.REPEAT, o = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width) {
                            var h = i.width ? i.width : 512,
                                l = i.height ? i.height : 2,
                                c = i.border ? i.border : 0;
                            e.texImage2D(e.TEXTURE_2D, 0, a, h, l, c, a, e.UNSIGNED_BYTE, null)
                        } else e.texImage2D(e.TEXTURE_2D, 0, a, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, r), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, o)
                    }
                    e.uniform1i(t.uniformLocation, this.textureCount), t._init = !0, this.textureCount++
                }
            }, i.PixiShader.prototype.syncUniforms = function() {
                var t;
                this.textureCount = 1;
                var e = this.gl;
                for (var s in this.uniforms) 1 === (t = this.uniforms[s]).glValueLength ? !0 === t.glMatrix ? t.glFunc.call(e, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(e, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (e.activeTexture(e["TEXTURE" + this.textureCount]), t.value.baseTexture._dirty[e.id] ? i.instances[e.id].updateTexture(t.value.baseTexture) : e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), e.uniform1i(t.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(t))
            }, i.PixiShader.prototype.destroy = function() {
                this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
            }, i.PixiShader.defaultVertexSrc = ["// PixiShader Vertex Shader", "// With multi-texture rendering", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "attribute float aTextureIndex;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   if (aTextureIndex > 0.0) gl_Position = vec4(0.0);", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "   vTextureIndex = aTextureIndex;", "}"], i.PixiFastShader = function(t) {
                if (this._UID = Phaser._UID++, this.gl = t, this.program = null, i._enableMultiTextureToggle) {
                    t = this.gl;
                    this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
                    for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", s = 1; s < this.MAX_TEXTURES; ++s) e += "\tif (vTextureIndex == " + s + ".0) { gl_FragColor = texture2D(uSamplerArray[" + s + "], vTextureCoord) * vColor;return;}\n";
                    this.fragmentSrc = ["// PixiFastShader Fragment Shader.", "precision lowp float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}", "}"]
                } else this.fragmentSrc = ["// PixiFastShader Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;", "}"];
                this.vertexSrc = ["// PixiFastShader Vertex Shader.", "attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "attribute float aTextureIndex;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vTextureIndex = aTextureIndex;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init()
            }, i.PixiFastShader.prototype.constructor = i.PixiFastShader, i.PixiFastShader.prototype.init = function() {
                var t = this.gl,
                    e = i.compileProgram(t, this.vertexSrc, this.fragmentSrc);
                if (t.useProgram(e), this.uSampler = i._enableMultiTextureToggle ? t.getUniformLocation(e, "uSamplerArray[0]") : t.getUniformLocation(e, "uSampler"), i._enableMultiTextureToggle) {
                    var s = [],
                        n = t.createTexture();
                    t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
                    for (var r = 0; r < this.MAX_TEXTURES; ++r) t.activeTexture(t.TEXTURE0 + r), t.bindTexture(t.TEXTURE_2D, n), s.push(r);
                    t.activeTexture(t.TEXTURE0), t.uniform1iv(this.uSampler, s)
                }
                this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.uMatrix = t.getUniformLocation(e, "uMatrix"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aPositionCoord = t.getAttribLocation(e, "aPositionCoord"), this.aScale = t.getAttribLocation(e, "aScale"), this.aRotation = t.getAttribLocation(e, "aRotation"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute, this.aTextureIndex], this.program = e
            }, i.PixiFastShader.prototype.destroy = function() {
                this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
            }, i.StripShader = function(t) {
                if (this._UID = Phaser._UID++, this.gl = t, this.program = null, i._enableMultiTextureToggle) {
                    t = this.gl;
                    this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
                    for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord);return;}\n", s = 1; s < this.MAX_TEXTURES; ++s) e += "\tif (vTextureIndex == " + s + ".0) { gl_FragColor = texture2D(uSamplerArray[" + s + "], vTextureCoord) ;return;}\n";
                    this.fragmentSrc = ["//StripShader Fragment Shader.", "precision mediump float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "uniform float alpha;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}", "}"]
                } else this.fragmentSrc = ["//StripShader Fragment Shader.", "precision mediump float;", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "}"];
                this.vertexSrc = ["//StripShader Vertex Shader.", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute float aTextureIndex;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vTextureIndex = aTextureIndex;", "}"], this.init()
            }, i.StripShader.prototype.constructor = i.StripShader, i.StripShader.prototype.init = function() {
                var t = this.gl,
                    e = i.compileProgram(t, this.vertexSrc, this.fragmentSrc);
                if (t.useProgram(e), this.uSampler = i._enableMultiTextureToggle ? t.getUniformLocation(e, "uSamplerArray[0]") : t.getUniformLocation(e, "uSampler"), i._enableMultiTextureToggle) {
                    var s = [],
                        n = t.createTexture();
                    t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
                    for (var r = 0; r < this.MAX_TEXTURES; ++r) t.activeTexture(t.TEXTURE0 + r), t.bindTexture(t.TEXTURE_2D, n), s.push(r);
                    t.activeTexture(t.TEXTURE0), t.uniform1iv(this.uSampler, s)
                }
                this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.aTextureIndex], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
            }, i.StripShader.prototype.destroy = function() {
                this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
            }, i.PrimitiveShader = function(t) {
                this._UID = Phaser._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init()
            }, i.PrimitiveShader.prototype.constructor = i.PrimitiveShader, i.PrimitiveShader.prototype.init = function() {
                var t = this.gl,
                    e = i.compileProgram(t, this.vertexSrc, this.fragmentSrc);
                t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
            }, i.PrimitiveShader.prototype.destroy = function() {
                this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
            }, i.ComplexPrimitiveShader = function(t) {
                this._UID = Phaser._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init()
            }, i.ComplexPrimitiveShader.prototype.constructor = i.ComplexPrimitiveShader, i.ComplexPrimitiveShader.prototype.init = function() {
                var t = this.gl,
                    e = i.compileProgram(t, this.vertexSrc, this.fragmentSrc);
                t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.color = t.getUniformLocation(e, "color"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
            }, i.ComplexPrimitiveShader.prototype.destroy = function() {
                this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
            }, i.glContexts = [], i.instances = [], i._enableMultiTextureToggle = !1, i.WebGLRenderer = function(t, e) {
                this.game = t, i.defaultRenderer || (i.defaultRenderer = this), this.extensions = {}, this.type = Phaser.WEBGL, this.resolution = t.resolution, this.transparent = t.transparent, this.autoResize = !1, this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.clearBeforeRender = t.clearBeforeRender, this.powerPreference = t.powerPreference, this.width = t.width, this.height = t.height, this.view = t.canvas, this._contextOptions = {
                    alpha: this.transparent,
                    antialias: t.antialias,
                    failIfMajorPerformanceCaveat: e.failIfMajorPerformanceCaveat,
                    premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
                    stencil: !0,
                    preserveDrawingBuffer: this.preserveDrawingBuffer,
                    powerPreference: t.powerPreference
                }, this.projection = new i.Point, this.offset = new i.Point, this.shaderManager = new i.WebGLShaderManager, this.spriteBatch = new i.WebGLSpriteBatch(t), this.maskManager = new i.WebGLMaskManager, this.filterManager = new i.WebGLFilterManager, this.stencilManager = new i.WebGLStencilManager, this.blendModeManager = new i.WebGLBlendModeManager, this.renderSession = {}, this.currentBatchedTextures = [], this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, this.renderSession.resolution = this.resolution, this.renderSession.roundPixels = e.roundPixels || !1, this.renderSession.maxTextureAvailableSpace = null, this.initContext(), this.mapBlendModes()
            }, i.WebGLRenderer.prototype.constructor = i.WebGLRenderer, i.WebGLRenderer.prototype.initContext = function() {
                var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
                if (this.gl = t, !t) throw new Error("This browser does not support webGL. Try using the canvas renderer");
                this.maxTextures = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.maxTextureSize = this.gl.getParameter(t.MAX_TEXTURE_SIZE), this.glContextId = t.id = i.WebGLRenderer.glContextId++, i.glContexts[this.glContextId] = t, i.instances[this.glContextId] = this, t.disable(t.DEPTH_TEST), t.disable(t.CULL_FACE), t.enable(t.BLEND), this.shaderManager.setContext(t), this.spriteBatch.setContext(t), this.maskManager.setContext(t), this.filterManager.setContext(t), this.blendModeManager.setContext(t), this.stencilManager.setContext(t), this.renderSession.gl = this.gl, this.resize(this.width, this.height), this.extensions.compression = {};
                var e = t.getExtension("WEBGL_compressed_texture_etc1") || t.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
                    s = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                    n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                e && (this.extensions.compression.ETC1 = e), s && (this.extensions.compression.PVRTC = s), n && (this.extensions.compression.S3TC = n)
            }, i.WebGLRenderer.prototype.setTexturePriority = function(t) {
                if (i._enableMultiTextureToggle) {
                    for (var e = function(t) {
                            return --t, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, ++t
                        }, s = this.gl, n = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), r = s.getParameter(s.MAX_TEXTURE_SIZE), o = this.game.cache._cache.image, a = null, h = 0; h < this.currentBatchedTextures.length; h++)(a = this.currentBatchedTextures[h]) in o ? o[a].base.textureIndex = 0 : console.warn('setTexturePriority: There is no image "%s" in the image cache.', a);
                    var l = r - e(Math.max(this.width, this.height));
                    this.currentBatchedTextures.length = 0;
                    for (var c = 0; c < t.length; ++c)
                        if ((a = t[c]) in o) {
                            var u = o[a].base;
                            (l -= e(Math.max(u.width, u.height))) <= 0 ? (u.textureIndex = 0, console.warn('setTexturePriority: Image "%s" was given textureIndex=0 because there is no available texture space (%s).', a, l)) : u.textureIndex = 1 + c % (n - 1), this.currentBatchedTextures.push(a)
                        } else console.warn('setTexturePriority: There is no image "%s" in the image cache.', a);
                    return this.renderSession.maxTextureAvailableSpace = l, this.currentBatchedTextures
                }
                console.warn("setTexturePriority error: Multi Texture support hasn't been enabled in the Phaser Game Config.")
            }, i.WebGLRenderer.prototype.render = function(t) {
                if (!this.contextLost) {
                    var e = this.gl;
                    e.viewport(0, 0, this.width, this.height), e.bindFramebuffer(e.FRAMEBUFFER, null), this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a), e.clear(e.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(t, this.projection)
                }
            }, i.WebGLRenderer.prototype.renderDisplayObject = function(t, e, s, n) {
                this.renderSession.blendModeManager.setBlendMode(i.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flipY = s ? -1 : 1, this.renderSession.projection = e, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, s), t._renderWebGL(this.renderSession, n), this.spriteBatch.end()
            }, i.WebGLRenderer.prototype.resize = function(t, e) {
                this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution
            }, i.WebGLRenderer.prototype.updateCompressedTexture = function(t) {
                if (!t.hasLoaded) return !1;
                var e = this.gl,
                    s = t.source;
                return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()), e.activeTexture(e.TEXTURE0 + t.textureIndex), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.compressedTexImage2D(e.TEXTURE_2D, 0, s.glExtensionFormat, s.width, s.height, 0, s.textureData), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t.mipmap && Phaser.Math.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), t._dirty[e.id] = !1, !0
            }, i.WebGLRenderer.prototype.updateTexture = function(t) {
                if (!t.hasLoaded || !t.source) return !1;
                if (t.source.compressionAlgorithm) return this.updateCompressedTexture(t);
                var e = this.gl;
                return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()), e.activeTexture(e.TEXTURE0 + t.textureIndex), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t.source), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t.mipmap && Phaser.Math.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), t._dirty[e.id] = !1, !0
            }, i.WebGLRenderer.prototype.destroy = function() {
                i.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, Phaser.CanvasPool.remove(this), i.instances[this.glContextId] = null, i.WebGLRenderer.glContextId--
            }, i.WebGLRenderer.prototype.mapBlendModes = function() {
                var t = this.gl;
                if (!i.blendModesWebGL) {
                    var e = [],
                        s = i.blendModes;
                    e[s.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.ADD] = [t.SRC_ALPHA, t.DST_ALPHA], e[s.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA], e[s.SCREEN] = [t.SRC_ALPHA, t.ONE], e[s.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i.blendModesWebGL = e
                }
            }, i.WebGLRenderer.prototype.getMaxTextureUnit = function() {
                var t = this.gl;
                return t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
            }, i.enableMultiTexture = function() {
                i._enableMultiTextureToggle = !0
            }, i.WebGLRenderer.glContextId = 0, i.WebGLRenderer.textureArray = [], i.WebGLBlendModeManager = function() {
                this.currentBlendMode = 99999
            }, i.WebGLBlendModeManager.prototype.constructor = i.WebGLBlendModeManager, i.WebGLBlendModeManager.prototype.setContext = function(t) {
                this.gl = t
            }, i.WebGLBlendModeManager.prototype.setBlendMode = function(t) {
                if (this.currentBlendMode === t) return !1;
                this.currentBlendMode = t;
                var e = i.blendModesWebGL[this.currentBlendMode];
                return e && this.gl.blendFunc(e[0], e[1]), !0
            }, i.WebGLBlendModeManager.prototype.destroy = function() {
                this.gl = null
            }, i.WebGLMaskManager = function() {}, i.WebGLMaskManager.prototype.constructor = i.WebGLMaskManager, i.WebGLMaskManager.prototype.setContext = function(t) {
                this.gl = t
            }, i.WebGLMaskManager.prototype.pushMask = function(t, e) {
                var s = e.gl;
                t.dirty && i.WebGLGraphics.updateGraphics(t, s), void 0 !== t._webGL[s.id] && void 0 !== t._webGL[s.id].data && 0 !== t._webGL[s.id].data.length && e.stencilManager.pushStencil(t, t._webGL[s.id].data[0], e)
            }, i.WebGLMaskManager.prototype.popMask = function(t, e) {
                var i = this.gl;
                void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
            }, i.WebGLMaskManager.prototype.destroy = function() {
                this.gl = null
            }, i.WebGLStencilManager = function() {
                this.stencilStack = [], this.reverse = !0, this.count = 0
            }, i.WebGLStencilManager.prototype.setContext = function(t) {
                this.gl = t
            }, i.WebGLStencilManager.prototype.pushStencil = function(t, e, i) {
                var s = this.gl;
                this.bindGraphics(t, e, i), 0 === this.stencilStack.length && (s.enable(s.STENCIL_TEST), s.clear(s.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(e);
                var n = this.count;
                s.colorMask(!1, !1, !1, !1), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), 1 === e.mode ? (s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), this.reverse ? s.stencilFunc(s.EQUAL, 255 - (n + 1), 255) : s.stencilFunc(s.EQUAL, n + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n + 1, 255) : s.stencilFunc(s.EQUAL, 255 - (n + 1), 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), this.count++
            }, i.WebGLStencilManager.prototype.bindGraphics = function(t, e, i) {
                this._currentGraphics = t;
                var s, n = this.gl,
                    r = i.projection,
                    o = i.offset;
                1 === e.mode ? (s = i.shaderManager.complexPrimitiveShader, i.shaderManager.setShader(s), n.uniform1f(s.flipY, i.flipY), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform2f(s.projectionVector, r.x, -r.y), n.uniform2f(s.offsetVector, -o.x, -o.y), n.uniform3fv(s.tintColor, Phaser.Color.hexToRGBArray(t.tint)), n.uniform3fv(s.color, e.color), n.uniform1f(s.alpha, t.worldAlpha * e.alpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 8, 0), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer)) : (s = i.shaderManager.primitiveShader, i.shaderManager.setShader(s), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform1f(s.flipY, i.flipY), n.uniform2f(s.projectionVector, r.x, -r.y), n.uniform2f(s.offsetVector, -o.x, -o.y), n.uniform3fv(s.tintColor, Phaser.Color.hexToRGBArray(t.tint)), n.uniform1f(s.alpha, t.worldAlpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 24, 0), n.vertexAttribPointer(s.colorAttribute, 4, n.FLOAT, !1, 24, 8), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer))
            }, i.WebGLStencilManager.prototype.popStencil = function(t, e, i) {
                var s = this.gl;
                if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) s.disable(s.STENCIL_TEST);
                else {
                    var n = this.count;
                    this.bindGraphics(t, e, i), s.colorMask(!1, !1, !1, !1), 1 === e.mode ? (this.reverse = !this.reverse, this.reverse ? (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255)) : (this.reverse ? (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP)
                }
            }, i.WebGLStencilManager.prototype.destroy = function() {
                this.stencilStack = null, this.gl = null
            }, i.WebGLShaderManager = function() {
                this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
                for (var t = 0; t < this.maxAttibs; t++) this.attribState[t] = !1;
                this.stack = []
            }, i.WebGLShaderManager.prototype.constructor = i.WebGLShaderManager, i.WebGLShaderManager.prototype.setContext = function(t) {
                this.gl = t, this.primitiveShader = new i.PrimitiveShader(t), this.complexPrimitiveShader = new i.ComplexPrimitiveShader(t), this.defaultShader = new i.PixiShader(t), this.fastShader = new i.PixiFastShader(t), this.stripShader = new i.StripShader(t), this.creatureShader = i.CreatureShader ? new i.CreatureShader(t) : null, this.setShader(this.defaultShader)
            }, i.WebGLShaderManager.prototype.setAttribs = function(t) {
                var e;
                for (e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1;
                for (e = 0; e < t.length; e++) {
                    var i = t[e];
                    this.tempAttribState[i] = !0
                }
                var s = this.gl;
                for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.tempAttribState[e] ? s.enableVertexAttribArray(e) : s.disableVertexAttribArray(e))
            }, i.WebGLShaderManager.prototype.setShader = function(t) {
                return this._currentId !== t._UID && (this._currentId = t._UID, this.currentShader = t, this.gl.useProgram(t.program), this.setAttribs(t.attributes), !0)
            }, i.WebGLShaderManager.prototype.destroy = function() {
                this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.creatureShader && this.creatureShader.destroy(), this.gl = null
            }, i.WebGLSpriteBatch = function(t) {
                this.game = t, this.vertSize = 5, this.size = 2e3, this.vertexSize = 24;
                var e = this.vertexSize * this.size * 4,
                    i = 6 * this.size;
                this.vertices = new ArrayBuffer(e), this.positions = new Float32Array(this.vertices), this.colors = new Uint32Array(this.vertices), this.indices = new Uint16Array(i), this.lastIndexCount = 0;
                for (var s = 0, n = 0; s < i; s += 6, n += 4) this.indices[s + 0] = n + 0, this.indices[s + 1] = n + 1, this.indices[s + 2] = n + 2, this.indices[s + 3] = n + 0, this.indices[s + 4] = n + 2, this.indices[s + 5] = n + 3;
                this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = null
            }, i.WebGLSpriteBatch.prototype.setContext = function(t) {
                if (this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.gl = t, i._enableMultiTextureToggle) {
                    for (var e = "\tif (vTextureIndex == 0.0) {gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", s = 1; s < this.MAX_TEXTURES; ++s) e += "\tif (vTextureIndex == " + s + ".0) {gl_FragColor = texture2D(uSamplerArray[" + s + "], vTextureCoord) * vColor;return;}\n";
                    this.defaultShader = new Phaser.Filter(this.game, void 0, ["//WebGLSpriteBatch Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "void main(void) {", e, "\tgl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;", "}"])
                } else this.defaultShader = new Phaser.Filter(this.game, void 0, ["//WebGLSpriteBatch Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;", "}"]);
                this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), this.currentBlendMode = 99999;
                var n = new i.PixiShader(t);
                n.fragmentSrc = this.defaultShader.fragmentSrc, n.uniforms = {}, n.init(), this.defaultShader.shaders[t.id] = n
            }, i.WebGLSpriteBatch.prototype.begin = function(t) {
                this.renderSession = t, this.shader = this.renderSession.shaderManager.defaultShader, this.start()
            }, i.WebGLSpriteBatch.prototype.end = function() {
                this.flush()
            }, i.WebGLSpriteBatch.prototype.render = function(t, e) {
                var i = t.texture,
                    s = t.worldTransform;
                e && (s = e), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture);
                var n = i._uvs;
                if (n) {
                    var r, o, a, h, l = t.anchor.x,
                        c = t.anchor.y;
                    if (i.trim) {
                        var u = i.trim;
                        r = (o = u.x - l * u.width) + i.crop.width, a = (h = u.y - c * u.height) + i.crop.height
                    } else r = i.frame.width * (1 - l), o = i.frame.width * -l, a = i.frame.height * (1 - c), h = i.frame.height * -c;
                    var d = this.currentBatchSize * this.vertexSize,
                        p = i.baseTexture.resolution,
                        f = i.baseTexture.textureIndex,
                        g = s.a / p,
                        m = s.b / p,
                        y = s.c / p,
                        v = s.d / p,
                        x = s.tx,
                        b = s.ty,
                        _ = i.crop.height;
                    if (i.rotated) {
                        var T = s.a,
                            w = s.b,
                            S = s.c,
                            C = s.d,
                            E = o,
                            P = r;
                        x = s.c * _ + x, b = s.d * _ + b, g = 6.123233995736766e-17 * T - S, m = 6.123233995736766e-17 * w - C, y = T + 6.123233995736766e-17 * S, v = w + 6.123233995736766e-17 * C, i._updateUvsInverted(), r = a, o = h, a = P, h = E
                    }
                    var A = this.colors,
                        M = this.positions,
                        k = t.tint,
                        R = (k >> 16) + (65280 & k) + ((255 & k) << 16) + (255 * t.worldAlpha << 24);
                    this.renderSession.roundPixels ? (M[d++] = g * o + y * h + x | 0, M[d++] = v * h + m * o + b | 0, M[d++] = n.x0, M[d++] = n.y0, A[d++] = R, M[d++] = f, M[d++] = g * r + y * h + x | 0, M[d++] = v * h + m * r + b | 0, M[d++] = n.x1, M[d++] = n.y1, A[d++] = R, M[d++] = f, M[d++] = g * r + y * a + x | 0, M[d++] = v * a + m * r + b | 0, M[d++] = n.x2, M[d++] = n.y2, A[d++] = R, M[d++] = f, M[d++] = g * o + y * a + x | 0, M[d++] = v * a + m * o + b | 0, M[d++] = n.x3, M[d++] = n.y3, A[d++] = R, M[d++] = f) : (M[d++] = g * o + y * h + x, M[d++] = v * h + m * o + b, M[d++] = n.x0, M[d++] = n.y0, A[d++] = R, M[d++] = f, M[d++] = g * r + y * h + x, M[d++] = v * h + m * r + b, M[d++] = n.x1, M[d++] = n.y1, A[d++] = R, M[d++] = f, M[d++] = g * r + y * a + x, M[d++] = v * a + m * r + b, M[d++] = n.x2, M[d++] = n.y2, A[d++] = R, M[d++] = f, M[d++] = g * o + y * a + x, M[d++] = v * a + m * o + b, M[d++] = n.x3, M[d++] = n.y3, A[d++] = R, M[d++] = f), this.sprites[this.currentBatchSize++] = t
                }
            }, i.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) {
                var e = t.tilingTexture,
                    s = t.texture.baseTexture.textureIndex;
                this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = e.baseTexture), t._uvs || (t._uvs = new i.TextureUvs);
                var n = t._uvs,
                    r = e.baseTexture.width,
                    o = e.baseTexture.height;
                t.tilePosition.x %= r * t.tileScaleOffset.x, t.tilePosition.y %= o * t.tileScaleOffset.y;
                var a = t.tilePosition.x / (r * t.tileScaleOffset.x),
                    h = t.tilePosition.y / (o * t.tileScaleOffset.y),
                    l = t.width / r / (t.tileScale.x * t.tileScaleOffset.x),
                    c = t.height / o / (t.tileScale.y * t.tileScaleOffset.y);
                n.x0 = 0 - a, n.y0 = 0 - h, n.x1 = 1 * l - a, n.y1 = 0 - h, n.x2 = 1 * l - a, n.y2 = 1 * c - h, n.x3 = 0 - a, n.y3 = 1 * c - h;
                var u = t.tint,
                    d = (u >> 16) + (65280 & u) + ((255 & u) << 16) + (255 * t.worldAlpha << 24),
                    p = this.positions,
                    f = this.colors,
                    g = t.width,
                    m = t.height,
                    y = t.anchor.x,
                    v = t.anchor.y,
                    x = g * (1 - y),
                    b = g * -y,
                    _ = m * (1 - v),
                    T = m * -v,
                    w = this.currentBatchSize * this.vertexSize,
                    S = e.baseTexture.resolution,
                    C = t.worldTransform,
                    E = C.a / S,
                    P = C.b / S,
                    A = C.c / S,
                    M = C.d / S,
                    k = C.tx,
                    R = C.ty;
                p[w++] = E * b + A * T + k, p[w++] = M * T + P * b + R, p[w++] = n.x0, p[w++] = n.y0, f[w++] = d, p[w++] = s, p[w++] = E * x + A * T + k, p[w++] = M * T + P * x + R, p[w++] = n.x1, p[w++] = n.y1, f[w++] = d, p[w++] = s, p[w++] = E * x + A * _ + k, p[w++] = M * _ + P * x + R, p[w++] = n.x2, p[w++] = n.y2, f[w++] = d, p[w++] = s, p[w++] = E * b + A * _ + k, p[w++] = M * _ + P * b + R, p[w++] = n.x3, p[w++] = n.y3, f[w++] = d, p[w++] = s, this.sprites[this.currentBatchSize++] = t
            }, i.WebGLSpriteBatch.prototype.flush = function() {
                if (0 !== this.currentBatchSize) {
                    var t, e, s, n, r = this.gl;
                    if (this.dirty) {
                        this.dirty = !1, t = this.defaultShader.shaders[r.id], r.activeTexture(r.TEXTURE0), r.bindBuffer(r.ARRAY_BUFFER, this.vertexBuffer), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                        var o = this.vertexSize;
                        r.vertexAttribPointer(t.aVertexPosition, 2, r.FLOAT, !1, o, 0), r.vertexAttribPointer(t.aTextureCoord, 2, r.FLOAT, !1, o, 8), r.vertexAttribPointer(t.colorAttribute, 4, r.UNSIGNED_BYTE, !0, o, 16), r.vertexAttribPointer(t.aTextureIndex, 1, r.FLOAT, !1, o, 20)
                    }
                    if (this.currentBatchSize > .5 * this.size) r.bufferSubData(r.ARRAY_BUFFER, 0, this.vertices);
                    else {
                        r.bindBuffer(r.ARRAY_BUFFER, this.vertexBuffer);
                        var a = this.positions.subarray(0, this.currentBatchSize * this.vertexSize);
                        r.bufferSubData(r.ARRAY_BUFFER, 0, a)
                    }
                    for (var h, l = 0, c = 0, u = null, d = this.renderSession.blendModeManager.currentBlendMode, p = null, f = !1, g = !1, m = 0, y = this.currentBatchSize; m < y; m++) {
                        e = (h = this.sprites[m]).tilingTexture ? h.tilingTexture.baseTexture : h.texture.baseTexture, f = d !== (s = h.blendMode), g = p !== (n = h.shader || this.defaultShader);
                        var v = e.skipRender;
                        if (v && h.children.length > 0 && (v = !1), (u !== e && !v || f || g) && (this.renderBatch(u, l, c), c = m, l = 0, u = e, f && (d = s, this.renderSession.blendModeManager.setBlendMode(d)), g)) {
                            (t = (p = n).shaders[r.id]) || ((t = new i.PixiShader(r)).fragmentSrc = p.fragmentSrc, t.uniforms = p.uniforms, t.init(), p.shaders[r.id] = t), this.renderSession.shaderManager.setShader(t), t.dirty && t.syncUniforms();
                            var x = this.renderSession.projection;
                            r.uniform2f(t.projectionVector, x.x, x.y);
                            var b = this.renderSession.offset;
                            r.uniform2f(t.offsetVector, b.x, b.y)
                        }
                        l++
                    }
                    this.renderBatch(u, l, c), this.currentBatchSize = 0
                }
            }, i.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) {
                if (0 !== e) {
                    var s = this.gl;
                    if (t._dirty[s.id]) {
                        if (!this.renderSession.renderer.updateTexture(t)) return
                    } else s.bindTexture(s.TEXTURE_2D, t._glTextures[s.id]);
                    s.drawElements(s.TRIANGLES, 6 * e, s.UNSIGNED_SHORT, 6 * i * 2), this.renderSession.drawCount++
                }
            }, i.WebGLSpriteBatch.prototype.stop = function() {
                this.flush(), this.dirty = !0
            }, i.WebGLSpriteBatch.prototype.start = function() {
                this.dirty = !0
            }, i.WebGLSpriteBatch.prototype.destroy = function() {
                this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null
            }, i.WebGLFastSpriteBatch = function(t) {
                this.vertSize = 11, this.maxSize = 6e3, this.size = this.maxSize;
                var e = 4 * this.size * this.vertSize,
                    i = 6 * this.maxSize;
                this.vertices = new Float32Array(e), this.indices = new Uint16Array(i), this.vertexBuffer = null, this.indexBuffer = null, this.lastIndexCount = 0;
                for (var s = 0, n = 0; s < i; s += 6, n += 4) this.indices[s + 0] = n + 0, this.indices[s + 1] = n + 1, this.indices[s + 2] = n + 2, this.indices[s + 3] = n + 0, this.indices[s + 4] = n + 2, this.indices[s + 5] = n + 3;
                this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(t)
            }, i.WebGLFastSpriteBatch.prototype.constructor = i.WebGLFastSpriteBatch, i.WebGLFastSpriteBatch.prototype.setContext = function(t) {
                this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW)
            }, i.WebGLFastSpriteBatch.prototype.begin = function(t, e) {
                this.renderSession = e, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = t.worldTransform.toArray(!0), this.start()
            }, i.WebGLFastSpriteBatch.prototype.end = function() {
                this.flush()
            }, i.WebGLFastSpriteBatch.prototype.render = function(t) {
                var e = t.children,
                    s = e[0];
                if (s.texture._uvs) {
                    this.currentBaseTexture = s.texture.baseTexture, s.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(s.blendMode));
                    var n = this.currentBaseTexture.textureIndex,
                        r = this.gl;
                    r.activeTexture(r.TEXTURE0 + n), r.bindTexture(r.TEXTURE_2D, this.currentBaseTexture._glTextures[r.id]), i.WebGLRenderer.textureArray[n] = this.currentBaseTexture;
                    for (var o = 0, a = e.length; o < a; o++) this.renderSprite(e[o]);
                    this.flush()
                }
            }, i.WebGLFastSpriteBatch.prototype.renderSprite = function(t) {
                var e = t.texture.baseTexture,
                    s = this.gl,
                    n = t.texture.baseTexture.textureIndex;
                if ((i.WebGLRenderer.textureArray[n] == e || !e._glTextures[s.id] || t.texture.baseTexture.skipRender || (this.flush(), s.activeTexture(s.TEXTURE0 + n), s.bindTexture(s.TEXTURE_2D, e._glTextures[s.id]), i.WebGLRenderer.textureArray[n] = e, t.texture._uvs)) && t.visible) {
                    var r, o, a, h, l, c, u, d, p = this.vertices;
                    if (r = t.texture._uvs, o = t.texture.frame.width, a = t.texture.frame.height, t.texture.trim) {
                        var f = t.texture.trim;
                        h = (l = f.x - t.anchor.x * f.width) + t.texture.crop.width, c = (u = f.y - t.anchor.y * f.height) + t.texture.crop.height
                    } else h = o * (1 - t.anchor.x), l = o * -t.anchor.x, c = a * (1 - t.anchor.y), u = a * -t.anchor.y;
                    d = 4 * this.currentBatchSize * this.vertSize, p[d++] = l, p[d++] = u, p[d++] = t.position.x, p[d++] = t.position.y, p[d++] = t.scale.x, p[d++] = t.scale.y, p[d++] = t.rotation, p[d++] = r.x0, p[d++] = r.y1, p[d++] = t.alpha, p[d++] = n, p[d++] = h, p[d++] = u, p[d++] = t.position.x, p[d++] = t.position.y, p[d++] = t.scale.x, p[d++] = t.scale.y, p[d++] = t.rotation, p[d++] = r.x1, p[d++] = r.y1, p[d++] = t.alpha, p[d++] = n, p[d++] = h, p[d++] = c, p[d++] = t.position.x, p[d++] = t.position.y, p[d++] = t.scale.x, p[d++] = t.scale.y, p[d++] = t.rotation, p[d++] = r.x2, p[d++] = r.y2, p[d++] = t.alpha, p[d++] = n, p[d++] = l, p[d++] = c, p[d++] = t.position.x, p[d++] = t.position.y, p[d++] = t.scale.x, p[d++] = t.scale.y, p[d++] = t.rotation, p[d++] = r.x3, p[d++] = r.y3, p[d++] = t.alpha, p[d++] = n, this.currentBatchSize++, this.currentBatchSize >= this.size && this.flush()
                }
            }, i.WebGLFastSpriteBatch.prototype.flush = function() {
                if (0 !== this.currentBatchSize) {
                    var t = this.gl;
                    if (this.currentBaseTexture._glTextures[t.id]) {
                        if (this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
                        else {
                            var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                            t.bufferSubData(t.ARRAY_BUFFER, 0, e)
                        }
                        t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++
                    } else this.renderSession.renderer.updateTexture(this.currentBaseTexture, t)
                }
            }, i.WebGLFastSpriteBatch.prototype.stop = function() {
                this.flush()
            }, i.WebGLFastSpriteBatch.prototype.start = function() {
                var t = this.gl;
                t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                var e = this.renderSession.projection;
                t.uniform2f(this.shader.projectionVector, e.x, e.y), t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
                var i = 4 * this.vertSize;
                t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0), t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8), t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16), t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24), t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28), t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36), t.vertexAttribPointer(this.shader.aTextureIndex, 1, t.FLOAT, !1, i, 40)
            }, i.WebGLFilterManager = function() {
                this.filterStack = [], this.offsetX = 0, this.offsetY = 0
            }, i.WebGLFilterManager.prototype.constructor = i.WebGLFilterManager, i.WebGLFilterManager.prototype.setContext = function(t) {
                this.gl = t, this.texturePool = [], this.initShaderBuffers()
            }, i.WebGLFilterManager.prototype.begin = function(t, e) {
                this.renderSession = t, this.defaultShader = t.shaderManager.defaultShader;
                var i = this.renderSession.projection;
                this.width = 2 * i.x, this.height = 2 * -i.y, this.buffer = e
            }, i.WebGLFilterManager.prototype.pushFilter = function(t) {
                var e = this.gl,
                    s = this.renderSession.projection,
                    n = this.renderSession.offset;
                t._filterArea = t.target.filterArea || t.target.getBounds(), t._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new i.WebGLStencilManager, this.renderSession.stencilManager.setContext(e), e.disable(e.STENCIL_TEST), this.filterStack.push(t);
                var r = t.filterPasses[0];
                this.offsetX += t._filterArea.x, this.offsetY += t._filterArea.y;
                var o = this.texturePool.pop();
                o ? o.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : o = new i.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), e.bindTexture(e.TEXTURE_2D, o.texture);
                var a = t._filterArea,
                    h = r.padding;
                a.x -= h, a.y -= h, a.width += 2 * h, a.height += 2 * h, a.x < 0 && (a.x = 0), a.width > this.width && (a.width = this.width), a.y < 0 && (a.y = 0), a.height > this.height && (a.height = this.height), e.bindFramebuffer(e.FRAMEBUFFER, o.frameBuffer), e.viewport(0, 0, a.width * this.renderSession.resolution, a.height * this.renderSession.resolution), s.x = a.width / 2, s.y = -a.height / 2, n.x = -a.x, n.y = -a.y, e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), t._glFilterTexture = o
            }, i.WebGLFilterManager.prototype.popFilter = function() {
                var t = this.gl,
                    e = this.filterStack.pop(),
                    s = e._filterArea,
                    n = e._glFilterTexture,
                    r = this.renderSession.projection,
                    o = this.renderSession.offset;
                if (e.filterPasses.length > 1) {
                    t.viewport(0, 0, s.width * this.renderSession.resolution, s.height * this.renderSession.resolution), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = s.height, this.vertexArray[2] = s.width, this.vertexArray[3] = s.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = s.width, this.vertexArray[7] = 0, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = s.width / this.width, this.uvArray[5] = s.height / this.height, this.uvArray[6] = s.width / this.width, this.uvArray[7] = s.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
                    var a = n,
                        h = this.texturePool.pop();
                    h || (h = new i.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)), h.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.clear(t.COLOR_BUFFER_BIT), t.disable(t.BLEND);
                    for (var l = 0; l < e.filterPasses.length - 1; l++) {
                        var c = e.filterPasses[l];
                        t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, a.texture), this.applyFilterPass(c, s, s.width, s.height);
                        var u = a;
                        a = h, h = u
                    }
                    t.enable(t.BLEND), n = a, this.texturePool.push(h)
                }
                var d = e.filterPasses[e.filterPasses.length - 1];
                this.offsetX -= s.x, this.offsetY -= s.y;
                var p = this.width,
                    f = this.height,
                    g = 0,
                    m = 0,
                    y = this.buffer;
                if (0 === this.filterStack.length) t.colorMask(!0, !0, !0, !0);
                else {
                    var v = this.filterStack[this.filterStack.length - 1];
                    p = (s = v._filterArea).width, f = s.height, g = s.x, m = s.y, y = v._glFilterTexture.frameBuffer
                }
                r.x = p / 2, r.y = -f / 2, o.x = g, o.y = m;
                var x = (s = e._filterArea).x - g,
                    b = s.y - m;
                t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = x, this.vertexArray[1] = b + s.height, this.vertexArray[2] = x + s.width, this.vertexArray[3] = b + s.height, this.vertexArray[4] = x, this.vertexArray[5] = b, this.vertexArray[6] = x + s.width, this.vertexArray[7] = b, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = s.width / this.width, this.uvArray[5] = s.height / this.height, this.uvArray[6] = s.width / this.width, this.uvArray[7] = s.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray), t.viewport(0, 0, p * this.renderSession.resolution, f * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, y), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = e._previous_stencil_mgr, e._previous_stencil_mgr = null, this.renderSession.stencilManager.count > 0 ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.applyFilterPass(d, s, p, f), this.texturePool.push(n), e._glFilterTexture = null
            }, i.WebGLFilterManager.prototype.applyFilterPass = function(t, e, s, n) {
                var r = this.gl,
                    o = t.shaders[r.id];
                o || ((o = new i.PixiShader(r)).fragmentSrc = t.fragmentSrc, o.uniforms = t.uniforms, o.init(!0), t.shaders[r.id] = o), this.renderSession.shaderManager.setShader(o), r.uniform2f(o.projectionVector, s / 2, -n / 2), r.uniform2f(o.offsetVector, 0, 0), t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width, t.uniforms.dimensions.value[1] = this.height, t.uniforms.dimensions.value[2] = this.vertexArray[0], t.uniforms.dimensions.value[3] = this.vertexArray[5]), o.syncUniforms(), r.bindBuffer(r.ARRAY_BUFFER, this.vertexBuffer), r.vertexAttribPointer(o.aVertexPosition, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, this.uvBuffer), r.vertexAttribPointer(o.aTextureCoord, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, this.colorBuffer), r.vertexAttribPointer(o.colorAttribute, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this.indexBuffer), r.drawElements(r.TRIANGLES, 6, r.UNSIGNED_SHORT, 0), this.renderSession.drawCount++
            }, i.WebGLFilterManager.prototype.initShaderBuffers = function() {
                var t = this.gl;
                this.vertexBuffer = t.createBuffer(), this.uvBuffer = t.createBuffer(), this.colorBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.vertexArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW), this.uvArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW), this.colorArray = new Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer), t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
            }, i.WebGLFilterManager.prototype.destroy = function() {
                var t = this.gl;
                this.filterStack = null, this.offsetX = 0, this.offsetY = 0;
                for (var e = 0; e < this.texturePool.length; e++) this.texturePool[e].destroy();
                this.texturePool = null, t.deleteBuffer(this.vertexBuffer), t.deleteBuffer(this.uvBuffer), t.deleteBuffer(this.colorBuffer), t.deleteBuffer(this.indexBuffer)
            };
            var s = {
                36054: "Incomplete attachment",
                36055: "Missing attachment",
                36057: "Incomplete dimensions",
                36061: "Framebuffer unsupported"
            };

            function n(t, e, n, r, o) {
                var a, h, l, c, u, d, p = t.createFramebuffer(),
                    f = t.createRenderbuffer(),
                    g = null;
                return t.activeTexture(t.TEXTURE0 + o), t.bindFramebuffer(t.FRAMEBUFFER, p), t.bindRenderbuffer(t.RENDERBUFFER, f), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.renderBuffer), l = e, c = n, u = r, d = (h = t).createTexture(), h.bindTexture(h.TEXTURE_2D, d), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, u === i.scaleModes.LINEAR ? h.LINEAR : h.NEAREST), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, u === i.scaleModes.LINEAR ? h.LINEAR : h.NEAREST), h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, l, c, 0, h.RGBA, h.UNSIGNED_BYTE, null), g = d, t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, g, 0), (a = t.checkFramebufferStatus(t.FRAMEBUFFER)) !== t.FRAMEBUFFER_COMPLETE && console.error("Incomplete GL framebuffer. ", s[a]), p.width = e, p.height = n, p.targetTexture = g, p.renderBuffer = f, p
            }
            return i.FilterTexture = function(t, e, s, r, o) {
                o = "number" == typeof o ? o : 0, this.gl = t, this.frameBuffer = n(t, e, s, r || i.scaleModes.DEFAULT, o), this.texture = this.frameBuffer.targetTexture, this.width = e, this.height = s, this.renderBuffer = this.frameBuffer.renderBuffer
            }, i.FilterTexture.prototype.constructor = i.FilterTexture, i.FilterTexture.prototype.clear = function() {
                var t = this.gl;
                t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT)
            }, i.FilterTexture.prototype.resize = function(t, e) {
                if (this.width !== t || this.height !== e) {
                    this.width = t, this.height = e;
                    var i = this.gl;
                    i.bindTexture(i.TEXTURE_2D, this.texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e)
                }
            }, i.FilterTexture.prototype.destroy = function() {
                var t = this.gl;
                t.deleteFramebuffer(this.frameBuffer), t.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
            }, i.CanvasBuffer = function(t, e) {
                this.width = t, this.height = e, this.canvas = Phaser.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = e
            }, i.CanvasBuffer.prototype.constructor = i.CanvasBuffer, i.CanvasBuffer.prototype.clear = function() {
                this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height)
            }, i.CanvasBuffer.prototype.resize = function(t, e) {
                this.width = this.canvas.width = t, this.height = this.canvas.height = e
            }, i.CanvasBuffer.prototype.destroy = function() {
                Phaser.CanvasPool.remove(this)
            }, i.CanvasMaskManager = function() {}, i.CanvasMaskManager.prototype.constructor = i.CanvasMaskManager, i.CanvasMaskManager.prototype.pushMask = function(t, e) {
                var s = e.context;
                s.save();
                var n = t.alpha,
                    r = t.worldTransform,
                    o = e.resolution;
                s.setTransform(r.a * o, r.b * o, r.c * o, r.d * o, r.tx * o, r.ty * o), i.CanvasGraphics.renderGraphicsMask(t, s), s.clip(), t.worldAlpha = n
            }, i.CanvasMaskManager.prototype.popMask = function(t) {
                t.context.restore()
            }, i.CanvasTinter = function() {}, i.CanvasTinter.getTintedTexture = function(t, e) {
                var s = t.tintedTexture || Phaser.CanvasPool.create(this);
                return i.CanvasTinter.tintMethod(t.texture, e, s), s
            }, i.CanvasTinter.tintWithMultiply = function(t, e, i) {
                var s = i.getContext("2d"),
                    n = t.crop,
                    r = n.width,
                    o = n.height;
                t.rotated && (r = o, o = n.width), i.width === r && i.height === o || (i.width = r, i.height = o), s.clearRect(0, 0, r, o), s.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), s.fillRect(0, 0, r, o), s.globalCompositeOperation = "multiply", s.drawImage(t.baseTexture.source, n.x, n.y, r, o, 0, 0, r, o), s.globalCompositeOperation = "destination-atop", s.drawImage(t.baseTexture.source, n.x, n.y, r, o, 0, 0, r, o)
            }, i.CanvasTinter.tintWithPerPixel = function(t, e, s) {
                var n = s.getContext("2d"),
                    r = t.crop,
                    o = r.width,
                    a = r.height;
                t.rotated && (o = a, a = r.width), s.width === o && s.height === a || (s.width = o, s.height = a), n.globalCompositeOperation = "copy", n.drawImage(t.baseTexture.source, r.x, r.y, o, a, 0, 0, o, a);
                for (var h = Phaser.Color.hexToRGBArray(e), l = h[0], c = h[1], u = h[2], d = n.getImageData(0, 0, o, a), p = d.data, f = 0; f < p.length; f += 4)
                    if (p[f + 0] *= l, p[f + 1] *= c, p[f + 2] *= u, !i.CanvasTinter.canHandleAlpha) {
                        var g = p[f + 3];
                        p[f + 0] /= 255 / g, p[f + 1] /= 255 / g, p[f + 2] /= 255 / g
                    } n.putImageData(d, 0, 0)
            }, i.CanvasRenderer = function(t, e) {
                if (this.game = t, i.defaultRenderer || (i.defaultRenderer = this), this.type = Phaser.CANVAS, this.resolution = t.resolution, this.clearBeforeRender = t.clearBeforeRender, this.transparent = t.transparent, this.autoResize = !1, this.width = t.width * this.resolution, this.height = t.height * this.resolution, this.view = t.canvas, this.context = this.view.getContext("2d", {
                        alpha: this.transparent
                    }), !this.context) throw new Error("Failed to create a Canvas 2d context.");
                this.refresh = !0, this.count = 0, this.maskManager = new i.CanvasMaskManager, this.renderSession = {
                    context: this.context,
                    maskManager: this.maskManager,
                    scaleMode: null,
                    smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
                    roundPixels: e.roundPixels || !1
                }, this.mapBlendModes(), this.resize(this.width, this.height)
            }, i.CanvasRenderer.prototype.constructor = i.CanvasRenderer, i.CanvasRenderer.prototype.render = function(t) {
                this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(t)
            }, i.CanvasRenderer.prototype.setTexturePriority = function() {}, i.CanvasRenderer.prototype.destroy = function(t) {
                void 0 === t && (t = !0), t && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null
            }, i.CanvasRenderer.prototype.resize = function(t, e) {
                this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === i.scaleModes.LINEAR)
            }, i.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) {
                this.renderSession.context = e || this.context, this.renderSession.resolution = this.resolution, t._renderCanvas(this.renderSession, i)
            }, i.CanvasRenderer.prototype.mapBlendModes = function() {
                if (!i.blendModesCanvas) {
                    var t = [],
                        e = i.blendModes,
                        s = this.game.device.canUseMultiply;
                    t[e.NORMAL] = "source-over", t[e.ADD] = "lighter", t[e.MULTIPLY] = s ? "multiply" : "source-over", t[e.SCREEN] = s ? "screen" : "source-over", t[e.OVERLAY] = s ? "overlay" : "source-over", t[e.DARKEN] = s ? "darken" : "source-over", t[e.LIGHTEN] = s ? "lighten" : "source-over", t[e.COLOR_DODGE] = s ? "color-dodge" : "source-over", t[e.COLOR_BURN] = s ? "color-burn" : "source-over", t[e.HARD_LIGHT] = s ? "hard-light" : "source-over", t[e.SOFT_LIGHT] = s ? "soft-light" : "source-over", t[e.DIFFERENCE] = s ? "difference" : "source-over", t[e.EXCLUSION] = s ? "exclusion" : "source-over", t[e.HUE] = s ? "hue" : "source-over", t[e.SATURATION] = s ? "saturation" : "source-over", t[e.COLOR] = s ? "color" : "source-over", t[e.LUMINOSITY] = s ? "luminosity" : "source-over", i.blendModesCanvas = t
                }
            }, i.BaseTexture = function(t, e, s) {
                this.resolution = s || 1, this.width = 100, this.height = 100, this.scaleMode = e || i.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = t, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this.textureIndex = 0, this._dirty = [!0, !0, !0, !0], t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1)
            }, i.BaseTexture.prototype.constructor = i.BaseTexture, i.BaseTexture.prototype.forceLoaded = function(t, e) {
                this.hasLoaded = !0, this.width = t, this.height = e, this.dirty()
            }, i.BaseTexture.prototype.destroy = function() {
                this.source && Phaser.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU()
            }, i.BaseTexture.prototype.dirty = function() {
                for (var t = 0; t < this._glTextures.length; t++) this._dirty[t] = !0
            }, i.BaseTexture.prototype.unloadFromGPU = function() {
                this.dirty();
                for (var t = this._glTextures.length - 1; t >= 0; t--) {
                    var e = this._glTextures[t],
                        s = i.glContexts[t];
                    s && e && s.deleteTexture(e)
                }
                this._glTextures.length = 0, this.dirty()
            }, i.BaseTexture.fromCanvas = function(t, e, s) {
                return 0 === t.width && (t.width = 1), 0 === t.height && (t.height = 1), s = s || 1, new i.BaseTexture(t, e, s)
            }, i.TextureSilentFail = !1, i.Texture = function(t, e, s, n) {
                this.noFrame = !1, e || (this.noFrame = !0, e = new i.Rectangle(0, 0, 1, 1)), t instanceof i.Texture && (t = t.baseTexture), this.baseTexture = t, this.frame = e, this.trim = n, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = s || new i.Rectangle(0, 0, 1, 1), this.rotated = !1, t.hasLoaded && (this.noFrame && (e = new i.Rectangle(0, 0, t.width, t.height)), this.setFrame(e))
            }, i.Texture.prototype.constructor = i.Texture, i.Texture.prototype.onBaseTextureLoaded = function() {
                var t = this.baseTexture;
                this.noFrame && (this.frame = new i.Rectangle(0, 0, t.width, t.height)), this.setFrame(this.frame)
            }, i.Texture.prototype.destroy = function(t) {
                t && this.baseTexture.destroy(), this.valid = !1
            }, i.Texture.prototype.setFrame = function(t) {
                if (this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, this.trim || !(t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs();
                else {
                    if (!i.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
                    this.valid = !1
                }
            }, i.Texture.prototype._updateUvs = function() {
                this._uvs || (this._uvs = new i.TextureUvs);
                var t = this.crop,
                    e = this.baseTexture.width,
                    s = this.baseTexture.height;
                this._uvs.x0 = t.x / e, this._uvs.y0 = t.y / s, this._uvs.x1 = (t.x + t.width) / e, this._uvs.y1 = t.y / s, this._uvs.x2 = (t.x + t.width) / e, this._uvs.y2 = (t.y + t.height) / s, this._uvs.x3 = t.x / e, this._uvs.y3 = (t.y + t.height) / s
            }, i.Texture.prototype._updateUvsInverted = function() {
                this._uvs || (this._uvs = new i.TextureUvs);
                var t = this.crop,
                    e = this.baseTexture.width,
                    s = this.baseTexture.height;
                this._uvs.x0 = t.x / e, this._uvs.y0 = t.y / s, this._uvs.x1 = (t.x + t.height) / e, this._uvs.y1 = t.y / s, this._uvs.x2 = (t.x + t.height) / e, this._uvs.y2 = (t.y + t.width) / s, this._uvs.x3 = t.x / e, this._uvs.y3 = (t.y + t.width) / s
            }, i.Texture.fromCanvas = function(t, e) {
                var s = i.BaseTexture.fromCanvas(t, e);
                return new i.Texture(s)
            }, i.TextureUvs = function() {
                this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0
            }, void 0 !== t && t.exports && (e = t.exports = i), e.PIXI = i, i
        }).call(this),
            function() {
                var s, n = n || {
                    VERSION: "2.14.0",
                    GAMES: [],
                    AUTO: 0,
                    CANVAS: 1,
                    WEBGL: 2,
                    HEADLESS: 3,
                    WEBGL_MULTI: 4,
                    NONE: 0,
                    LEFT: 1,
                    RIGHT: 2,
                    UP: 3,
                    DOWN: 4,
                    SPRITE: 0,
                    BUTTON: 1,
                    IMAGE: 2,
                    GRAPHICS: 3,
                    TEXT: 4,
                    TILESPRITE: 5,
                    BITMAPTEXT: 6,
                    GROUP: 7,
                    RENDERTEXTURE: 8,
                    TILEMAP: 9,
                    TILEMAPLAYER: 10,
                    EMITTER: 11,
                    POLYGON: 12,
                    BITMAPDATA: 13,
                    CANVAS_FILTER: 14,
                    WEBGL_FILTER: 15,
                    ELLIPSE: 16,
                    SPRITEBATCH: 17,
                    RETROFONT: 18,
                    POINTER: 19,
                    ROPE: 20,
                    CIRCLE: 21,
                    RECTANGLE: 22,
                    LINE: 23,
                    MATRIX: 24,
                    POINT: 25,
                    ROUNDEDRECTANGLE: 26,
                    CREATURE: 27,
                    VIDEO: 28,
                    PENDING_ATLAS: -1,
                    HORIZONTAL: 0,
                    VERTICAL: 1,
                    LANDSCAPE: 0,
                    PORTRAIT: 1,
                    ANGLE_UP: 270,
                    ANGLE_DOWN: 90,
                    ANGLE_LEFT: 180,
                    ANGLE_RIGHT: 0,
                    ANGLE_NORTH_EAST: 315,
                    ANGLE_NORTH_WEST: 225,
                    ANGLE_SOUTH_EAST: 45,
                    ANGLE_SOUTH_WEST: 135,
                    TOP_LEFT: 0,
                    TOP_CENTER: 1,
                    TOP_RIGHT: 2,
                    LEFT_TOP: 3,
                    LEFT_CENTER: 4,
                    LEFT_BOTTOM: 5,
                    CENTER: 6,
                    RIGHT_TOP: 7,
                    RIGHT_CENTER: 8,
                    RIGHT_BOTTOM: 9,
                    BOTTOM_LEFT: 10,
                    BOTTOM_CENTER: 11,
                    BOTTOM_RIGHT: 12,
                    blendModes: {
                        NORMAL: 0,
                        ADD: 1,
                        MULTIPLY: 2,
                        SCREEN: 3,
                        OVERLAY: 4,
                        DARKEN: 5,
                        LIGHTEN: 6,
                        COLOR_DODGE: 7,
                        COLOR_BURN: 8,
                        HARD_LIGHT: 9,
                        SOFT_LIGHT: 10,
                        DIFFERENCE: 11,
                        EXCLUSION: 12,
                        HUE: 13,
                        SATURATION: 14,
                        COLOR: 15,
                        LUMINOSITY: 16
                    },
                    scaleModes: {
                        DEFAULT: 0,
                        LINEAR: 0,
                        NEAREST: 1
                    },
                    PIXI: PIXI || {},
                    _UID: 0
                };
                if ("undefined" != typeof AudioBufferSourceNode && (AudioBufferSourceNode.prototype.start || (AudioBufferSourceNode.prototype.start = AudioBufferSourceNode.prototype.noteGrainOn), AudioBufferSourceNode.prototype.stop || (AudioBufferSourceNode.prototype.stop = AudioBufferSourceNode.prototype.noteOff)), Math.trunc || (Math.trunc = function(t) {
                        return t < 0 ? Math.ceil(t) : Math.floor(t)
                    }), Function.prototype.bind || (Function.prototype.bind = (s = Array.prototype.slice, function(t) {
                        var e = this,
                            i = s.call(arguments, 1);
                        if ("function" != typeof e) throw new TypeError;

                        function n() {
                            var r = i.concat(s.call(arguments));
                            e.apply(this instanceof n ? this : t, r)
                        }
                        return n.prototype = function t(e) {
                            if (e && (t.prototype = e), !(this instanceof t)) return new t
                        }(e.prototype), n
                    })), Array.isArray || (Array.isArray = function(t) {
                        return "[object Array]" === Object.prototype.toString.call(t)
                    }), Array.prototype.forEach || (Array.prototype.forEach = function(t) {
                        "use strict";
                        if (void 0 === this || null === this) throw new TypeError;
                        var e = Object(this),
                            i = e.length >>> 0;
                        if ("function" != typeof t) throw new TypeError;
                        for (var s = arguments.length >= 2 ? arguments[1] : void 0, n = 0; n < i; n++) n in e && t.call(s, e[n], n, e)
                    }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
                    var r = function(t) {
                        var e = new Array;
                        window[t] = function(t) {
                            if ("number" == typeof t) {
                                Array.call(this, t), this.length = t;
                                for (var e = 0; e < this.length; e++) this[e] = 0
                            } else {
                                Array.call(this, t.length), this.length = t.length;
                                for (e = 0; e < this.length; e++) this[e] = t[e]
                            }
                        }, window[t].prototype = e, window[t].constructor = window[t]
                    };
                    r("Float32Array"), r("Uint32Array"), r("Uint16Array"), r("Int16Array"), r("ArrayBuffer")
                }
                window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {}), Object.assign || (Object.assign = function(t, e) {
                    "use strict";
                    if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                    for (var i = Object(t), s = Object.prototype.hasOwnProperty, n = 1; n < arguments.length; n++) {
                        var r = arguments[n];
                        if (null != r)
                            for (var o in r) s.call(r, o) && (i[o] = r[o])
                    }
                    return i
                }), n.Utils = {
                    defaults: function(t, e) {
                        for (var i = Object.keys(e), s = 0, n = i.length; s < n; s++) {
                            var r = i[s];
                            void 0 === t[r] && (t[r] = e[r])
                        }
                        return t
                    },
                    reverseString: function(t) {
                        return t.split("").reverse().join("")
                    },
                    getProperty: function(t, e) {
                        var i = e.split(".");
                        switch (i.length) {
                            case 1:
                                return t[e];
                            case 2:
                                return t[i[0]][i[1]];
                            case 3:
                                return t[i[0]][i[1]][i[2]];
                            case 4:
                                return t[i[0]][i[1]][i[2]][i[3]];
                            default:
                                return this._getProperty(t, e)
                        }
                    },
                    setProperties: function(t, e) {
                        for (var i in e) this.setProperty(t, i, e[i]);
                        return t
                    },
                    setProperty: function(t, e, i) {
                        var s = e.split(".");
                        switch (s.length) {
                            case 1:
                                t[e] = i;
                                break;
                            case 2:
                                t[s[0]][s[1]] = i;
                                break;
                            case 3:
                                t[s[0]][s[1]][s[2]] = i;
                                break;
                            case 4:
                                t[s[0]][s[1]][s[2]][s[3]] = i;
                                break;
                            default:
                                this._setProperty(t, e, i)
                        }
                    },
                    _getProperty: function(t, e) {
                        for (var i = e.split("."), s = i.length, n = 0, r = t; n < s;) {
                            var o = i[n];
                            if (null == r) return;
                            r = r[o], n++
                        }
                        return r
                    },
                    _setProperty: function(t, e, i) {
                        var s = e.split("."),
                            n = s.length,
                            r = 0,
                            o = t,
                            a = s[0];
                        if (1 === n) t[e] = i;
                        else {
                            for (; r < n - 1;) o = o[a], a = s[++r];
                            o[a] = i
                        }
                        return t
                    },
                    chanceRoll: function(t) {
                        return void 0 === t && (t = 50), t > 0 && 100 * Math.random() <= t
                    },
                    randomChoice: function(t, e) {
                        return Math.random() < .5 ? t : e
                    },
                    parseDimension: function(t, e) {
                        var i = 0,
                            s = 0;
                        return "string" == typeof t ? "%" === t.substr(-1) ? (i = parseInt(t, 10) / 100, s = 0 === e ? window.innerWidth * i : window.innerHeight * i) : s = parseInt(t, 10) : s = t, s
                    },
                    pad: function(t, e, i, s) {
                        if (void 0 === e) e = 0;
                        if (void 0 === i) i = " ";
                        if (void 0 === s) s = 3;
                        var n = 0;
                        if (e + 1 >= (t = t.toString()).length) switch (s) {
                            case 1:
                                t = new Array(e + 1 - t.length).join(i) + t;
                                break;
                            case 3:
                                var r = Math.ceil((n = e - t.length) / 2);
                                t = new Array(n - r + 1).join(i) + t + new Array(r + 1).join(i);
                                break;
                            default:
                                t += new Array(e + 1 - t.length).join(i)
                        }
                        return t
                    },
                    isPlainObject: function(t) {
                        if ("object" != typeof t || t.nodeType || t === t.window) return !1;
                        try {
                            if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf")) return !1
                        } catch (t) {
                            return !1
                        }
                        return !0
                    },
                    extend: function() {
                        var t, e, i, s, r, o, a = arguments[0] || {},
                            h = 1,
                            l = arguments.length,
                            c = !1;
                        for ("boolean" == typeof a && (c = a, a = arguments[1] || {}, h = 2), l === h && (a = this, --h); h < l; h++)
                            if (null != (t = arguments[h]))
                                for (e in t) i = a[e], a !== (s = t[e]) && (c && s && (n.Utils.isPlainObject(s) || (r = Array.isArray(s))) ? (r ? (r = !1, o = i && Array.isArray(i) ? i : []) : o = i && n.Utils.isPlainObject(i) ? i : {}, a[e] = n.Utils.extend(c, o, s)) : void 0 !== s && (a[e] = s));
                        return a
                    },
                    mixinPrototype: function(t, e, i) {
                        void 0 === i && (i = !1);
                        for (var s = Object.keys(e), n = 0; n < s.length; n++) {
                            var r = s[n],
                                o = e[r];
                            !i && r in t || (!o || "function" != typeof o.get && "function" != typeof o.set ? t[r] = o : "function" == typeof o.clone ? t[r] = o.clone() : Object.defineProperty(t, r, o))
                        }
                    },
                    mixin: function(t, e) {
                        if (!t || "object" != typeof t) return e;
                        for (var i in t) {
                            var s = t[i];
                            if (!s.childNodes && !s.cloneNode) {
                                var r = typeof t[i];
                                t[i] && "object" === r ? typeof e[i] === r ? e[i] = n.Utils.mixin(t[i], e[i]) : e[i] = n.Utils.mixin(t[i], new s.constructor) : e[i] = t[i]
                            }
                        }
                        return e
                    }
                }, n.Circle = function(t, e, i) {
                    t = t || 0, e = e || 0, i = i || 0, this.x = t, this.y = e, this._diameter = i, this._radius = 0, i > 0 && (this._radius = .5 * i), this.type = n.CIRCLE
                }, n.Circle.prototype = {
                    circumference: function() {
                        return Math.PI * this._radius * 2
                    },
                    random: function(t) {
                        void 0 === t && (t = new n.Point);
                        var e = 2 * Math.PI * Math.random(),
                            i = Math.random() + Math.random(),
                            s = i > 1 ? 2 - i : i,
                            r = s * Math.cos(e),
                            o = s * Math.sin(e);
                        return t.x = this.x + r * this.radius, t.y = this.y + o * this.radius, t
                    },
                    getBounds: function() {
                        return new n.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter)
                    },
                    setTo: function(t, e, i) {
                        return this.x = t, this.y = e, this._diameter = i, this._radius = .5 * i, this
                    },
                    copyFrom: function(t) {
                        return this.setTo(t.x, t.y, t.diameter)
                    },
                    copyTo: function(t) {
                        return t.x = this.x, t.y = this.y, t.diameter = this._diameter, t
                    },
                    distance: function(t, e) {
                        var i = n.Math.distance(this.x, this.y, t.x, t.y);
                        return e ? Math.round(i) : i
                    },
                    clone: function(t) {
                        return void 0 === t || null === t ? t = new n.Circle(this.x, this.y, this.diameter) : t.setTo(this.x, this.y, this.diameter), t
                    },
                    contains: function(t, e) {
                        return n.Circle.contains(this, t, e)
                    },
                    circumferencePoint: function(t, e, i) {
                        return n.Circle.circumferencePoint(this, t, e, i)
                    },
                    sample: function(t, e, i, s, r) {
                        t || (t = 60), null == e && (e = 0), null == i && (i = n.Math.PI2), r || (r = []);
                        for (var o = 0; o < t;) this.circumferencePoint(n.Math.linear(e, i, o / t), s, r[o] || (r[o] = new n.Point)), o += 1;
                        return r
                    },
                    offset: function(t, e) {
                        return this.x += t, this.y += e, this
                    },
                    offsetPoint: function(t) {
                        return this.offset(t.x, t.y)
                    },
                    toString: function() {
                        return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
                    }
                }, n.Circle.prototype.constructor = n.Circle, Object.defineProperty(n.Circle.prototype, "diameter", {
                    get: function() {
                        return this._diameter
                    },
                    set: function(t) {
                        t > 0 && (this._diameter = t, this._radius = .5 * t)
                    }
                }), Object.defineProperty(n.Circle.prototype, "radius", {
                    get: function() {
                        return this._radius
                    },
                    set: function(t) {
                        t > 0 && (this._radius = t, this._diameter = 2 * t)
                    }
                }), Object.defineProperty(n.Circle.prototype, "left", {
                    get: function() {
                        return this.x - this._radius
                    },
                    set: function(t) {
                        t > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - t
                    }
                }), Object.defineProperty(n.Circle.prototype, "right", {
                    get: function() {
                        return this.x + this._radius
                    },
                    set: function(t) {
                        t < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.x
                    }
                }), Object.defineProperty(n.Circle.prototype, "top", {
                    get: function() {
                        return this.y - this._radius
                    },
                    set: function(t) {
                        t > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - t
                    }
                }), Object.defineProperty(n.Circle.prototype, "bottom", {
                    get: function() {
                        return this.y + this._radius
                    },
                    set: function(t) {
                        t < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.y
                    }
                }), Object.defineProperty(n.Circle.prototype, "area", {
                    get: function() {
                        return this._radius > 0 ? Math.PI * this._radius * this._radius : 0
                    }
                }), Object.defineProperty(n.Circle.prototype, "empty", {
                    get: function() {
                        return 0 === this._diameter
                    },
                    set: function(t) {
                        !0 === t && this.setTo(0, 0, 0)
                    }
                }), n.Circle.contains = function(t, e, i) {
                    return t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius
                }, n.Circle.equals = function(t, e) {
                    return t.x === e.x && t.y === e.y && t.diameter === e.diameter
                }, n.Circle.intersects = function(t, e) {
                    return n.Math.distance(t.x, t.y, e.x, e.y) <= t.radius + e.radius
                }, n.Circle.circumferencePoint = function(t, e, i, s) {
                    return void 0 === i && (i = !1), void 0 === s && (s = new n.Point), !0 === i && (e = n.Math.degToRad(e)), s.x = t.x + t.radius * Math.cos(e), s.y = t.y + t.radius * Math.sin(e), s
                }, n.Circle.intersectsRectangle = function(t, e) {
                    var i = Math.abs(t.x - e.x - e.halfWidth);
                    if (i > e.halfWidth + t.radius) return !1;
                    var s = Math.abs(t.y - e.y - e.halfHeight);
                    if (s > e.halfHeight + t.radius) return !1;
                    if (i <= e.halfWidth || s <= e.halfHeight) return !0;
                    var n = i - e.halfWidth,
                        r = s - e.halfHeight;
                    return n * n + r * r <= t.radius * t.radius
                }, n.Circle.intersectsLine = function(t, e, i) {
                    var s = t.x,
                        r = t.y,
                        o = (e.end.y - e.start.y) / (e.end.x - e.start.x),
                        a = e.end.y - o * e.end.x,
                        h = t.radius,
                        l = t.radius,
                        c = a + o * s,
                        u = (s * (l * l) - o * (h * h) * (a - r) + h * l * Math.sqrt(h * h * (o * o) + l * l - c * c - r * r + 2 * c * r)) / (h * h * (o * o) + l * l),
                        d = (s * (l * l) - o * (h * h) * (a - r) - h * l * Math.sqrt(h * h * (o * o) + l * l - c * c - r * r + 2 * c * r)) / (h * h * (o * o) + l * l),
                        p = o * u + a,
                        f = o * d + a,
                        g = new n.Point(u, p),
                        m = new n.Point(d, f),
                        y = e.pointOnSegment(g.x, g.y, .01),
                        v = e.pointOnSegment(m.x, m.y, .01);
                    return y && v ? !i || [g, m] : y ? !i || [g] : v ? !i || [m] : !!i && []
                }, PIXI.Circle = n.Circle, n.Ellipse = function(t, e, i, s) {
                    t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.x = t, this.y = e, this.width = i, this.height = s, this.type = n.ELLIPSE
                }, n.Ellipse.prototype = {
                    setTo: function(t, e, i, s) {
                        return this.x = t, this.y = e, this.width = i, this.height = s, this
                    },
                    getBounds: function() {
                        return new n.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height)
                    },
                    copyFrom: function(t) {
                        return this.setTo(t.x, t.y, t.width, t.height)
                    },
                    copyTo: function(t) {
                        return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                    },
                    clone: function(t) {
                        return void 0 === t || null === t ? t = new n.Ellipse(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
                    },
                    contains: function(t, e) {
                        return n.Ellipse.contains(this, t, e)
                    },
                    random: function(t) {
                        void 0 === t && (t = new n.Point);
                        var e = Math.random() * Math.PI * 2,
                            i = Math.sqrt(Math.random());
                        return t.x = this.centerX + .5 * i * Math.cos(e) * this.width, t.y = this.centerY + .5 * i * Math.sin(e) * this.height, t
                    },
                    toString: function() {
                        return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
                    }
                }, n.Ellipse.prototype.constructor = n.Ellipse, Object.defineProperty(n.Ellipse.prototype, "left", {
                    get: function() {
                        return this.x
                    },
                    set: function(t) {
                        this.x = t
                    }
                }), Object.defineProperty(n.Ellipse.prototype, "right", {
                    get: function() {
                        return this.x + this.width
                    },
                    set: function(t) {
                        t < this.x ? this.width = 0 : this.width = t - this.x
                    }
                }), Object.defineProperty(n.Ellipse.prototype, "top", {
                    get: function() {
                        return this.y
                    },
                    set: function(t) {
                        this.y = t
                    }
                }), Object.defineProperty(n.Ellipse.prototype, "bottom", {
                    get: function() {
                        return this.y + this.height
                    },
                    set: function(t) {
                        t < this.y ? this.height = 0 : this.height = t - this.y
                    }
                }), Object.defineProperty(n.Ellipse.prototype, "centerX", {
                    get: function() {
                        return this.x + .5 * this.width
                    }
                }), Object.defineProperty(n.Ellipse.prototype, "centerY", {
                    get: function() {
                        return this.y + .5 * this.height
                    }
                }), Object.defineProperty(n.Ellipse.prototype, "empty", {
                    get: function() {
                        return 0 === this.width || 0 === this.height
                    },
                    set: function(t) {
                        !0 === t && this.setTo(0, 0, 0, 0)
                    }
                }), n.Ellipse.contains = function(t, e, i) {
                    if (t.width <= 0 || t.height <= 0) return !1;
                    var s = (e - t.x) / t.width - .5,
                        n = (i - t.y) / t.height - .5;
                    return (s *= s) + (n *= n) < .25
                }, n.Ellipse.intersectsLine = function(t, e, i) {
                    var s = t.x,
                        r = t.y,
                        o = (e.end.y - e.start.y) / (e.end.x - e.start.x),
                        a = e.end.y - o * e.end.x,
                        h = t.width / 2,
                        l = t.height / 2,
                        c = a + o * s,
                        u = (s * (l * l) - o * (h * h) * (a - r) + h * l * Math.sqrt(h * h * (o * o) + l * l - c * c - r * r + 2 * c * r)) / (h * h * (o * o) + l * l),
                        d = (s * (l * l) - o * (h * h) * (a - r) - h * l * Math.sqrt(h * h * (o * o) + l * l - c * c - r * r + 2 * c * r)) / (h * h * (o * o) + l * l),
                        p = o * u + a,
                        f = o * d + a,
                        g = new n.Point(u, p),
                        m = new n.Point(d, f),
                        y = e.pointOnSegment(g.x, g.y, .01),
                        v = e.pointOnSegment(m.x, m.y, .01);
                    return y && v ? !i || [g, m] : y ? !i || [g] : v ? !i || [m] : !!i && []
                }, PIXI.Ellipse = n.Ellipse, n.Line = function(t, e, i, s) {
                    t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.start = new n.Point(t, e), this.end = new n.Point(i, s), this.type = n.LINE
                }, n.Line.prototype = {
                    setTo: function(t, e, i, s) {
                        return this.start.setTo(t, e), this.end.setTo(i, s), this
                    },
                    fromPoints: function(t, e) {
                        return this.setTo(t.x, t.y, e.x, e.y), this
                    },
                    fromSprite: function(t, e, i) {
                        return void 0 === i && (i = !1), i ? this.setTo(t.centerX, t.centerY, e.centerX, e.centerY) : this.fromPoints(t, e)
                    },
                    fromAngle: function(t, e, i, s) {
                        return this.start.setTo(t, e), this.end.setTo(t + Math.cos(i) * s, e + Math.sin(i) * s), this
                    },
                    rotate: function(t, e) {
                        var i = (this.start.x + this.end.x) / 2,
                            s = (this.start.y + this.end.y) / 2;
                        return this.start.rotate(i, s, t, e), this.end.rotate(i, s, t, e), this
                    },
                    rotateAround: function(t, e, i, s) {
                        return this.start.rotate(t, e, i, s), this.end.rotate(t, e, i, s), this
                    },
                    intersects: function(t, e, i) {
                        return n.Line.intersectsPoints(this.start, this.end, t.start, t.end, e, i)
                    },
                    reflect: function(t) {
                        return n.Line.reflect(this, t)
                    },
                    midPoint: function(t) {
                        return void 0 === t && (t = new n.Point), t.x = (this.start.x + this.end.x) / 2, t.y = (this.start.y + this.end.y) / 2, t
                    },
                    centerOn: function(t, e) {
                        var i = t - (this.start.x + this.end.x) / 2,
                            s = e - (this.start.y + this.end.y) / 2;
                        this.start.add(i, s), this.end.add(i, s)
                    },
                    pointOnLine: function(t, e, i) {
                        return n.Math.fuzzyEqual((t - this.start.x) * (this.end.y - this.start.y), (this.end.x - this.start.x) * (e - this.start.y), i || 0)
                    },
                    pointOnSegment: function(t, e, i) {
                        var s = Math.min(this.start.x, this.end.x),
                            n = Math.max(this.start.x, this.end.x),
                            r = Math.min(this.start.y, this.end.y),
                            o = Math.max(this.start.y, this.end.y);
                        return this.pointOnLine(t, e, i) && t >= s && t <= n && e >= r && e <= o
                    },
                    random: function(t) {
                        void 0 === t && (t = new n.Point);
                        var e = Math.random();
                        return t.x = this.start.x + e * (this.end.x - this.start.x), t.y = this.start.y + e * (this.end.y - this.start.y), t
                    },
                    coordinatesOnLine: function(t, e) {
                        void 0 === t && (t = 1), void 0 === e && (e = []);
                        var i = Math.round(this.start.x),
                            s = Math.round(this.start.y),
                            n = Math.round(this.end.x),
                            r = Math.round(this.end.y),
                            o = Math.abs(n - i),
                            a = Math.abs(r - s),
                            h = i < n ? 1 : -1,
                            l = s < r ? 1 : -1,
                            c = o - a;
                        e.push([i, s]);
                        for (var u = 1; i !== n || s !== r;) {
                            var d = c << 1;
                            d > -a && (c -= a, i += h), d < o && (c += o, s += l), u % t == 0 && e.push([i, s]), u++
                        }
                        return e
                    },
                    clone: function(t) {
                        return void 0 === t || null === t ? t = new n.Line(this.start.x, this.start.y, this.end.x, this.end.y) : t.setTo(this.start.x, this.start.y, this.end.x, this.end.y), t
                    }
                }, Object.defineProperty(n.Line.prototype, "length", {
                    get: function() {
                        return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
                    }
                }), Object.defineProperty(n.Line.prototype, "angle", {
                    get: function() {
                        return n.Point.angle(this.end, this.start)
                    }
                }), Object.defineProperty(n.Line.prototype, "slope", {
                    get: function() {
                        return (this.end.y - this.start.y) / (this.end.x - this.start.x)
                    }
                }), Object.defineProperty(n.Line.prototype, "perpSlope", {
                    get: function() {
                        return -(this.end.x - this.start.x) / (this.end.y - this.start.y)
                    }
                }), Object.defineProperty(n.Line.prototype, "x", {
                    get: function() {
                        return Math.min(this.start.x, this.end.x)
                    }
                }), Object.defineProperty(n.Line.prototype, "y", {
                    get: function() {
                        return Math.min(this.start.y, this.end.y)
                    }
                }), Object.defineProperty(n.Line.prototype, "left", {
                    get: function() {
                        return Math.min(this.start.x, this.end.x)
                    }
                }), Object.defineProperty(n.Line.prototype, "right", {
                    get: function() {
                        return Math.max(this.start.x, this.end.x)
                    }
                }), Object.defineProperty(n.Line.prototype, "top", {
                    get: function() {
                        return Math.min(this.start.y, this.end.y)
                    }
                }), Object.defineProperty(n.Line.prototype, "bottom", {
                    get: function() {
                        return Math.max(this.start.y, this.end.y)
                    }
                }), Object.defineProperty(n.Line.prototype, "width", {
                    get: function() {
                        return Math.abs(this.start.x - this.end.x)
                    }
                }), Object.defineProperty(n.Line.prototype, "height", {
                    get: function() {
                        return Math.abs(this.start.y - this.end.y)
                    }
                }), Object.defineProperty(n.Line.prototype, "normalX", {
                    get: function() {
                        return Math.cos(this.angle - 1.5707963267948966)
                    }
                }), Object.defineProperty(n.Line.prototype, "normalY", {
                    get: function() {
                        return Math.sin(this.angle - 1.5707963267948966)
                    }
                }), Object.defineProperty(n.Line.prototype, "normalAngle", {
                    get: function() {
                        return n.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI)
                    }
                }), n.Line.intersectsPoints = function(t, e, i, s, r, o) {
                    void 0 === r && (r = !0), void 0 === o && (o = new n.Point);
                    var a = e.y - t.y,
                        h = s.y - i.y,
                        l = t.x - e.x,
                        c = i.x - s.x,
                        u = e.x * t.y - t.x * e.y,
                        d = s.x * i.y - i.x * s.y,
                        p = a * c - h * l;
                    if (0 === p) return null;
                    if (o.x = (l * d - c * u) / p, o.y = (h * u - a * d) / p, r) {
                        var f = (s.y - i.y) * (e.x - t.x) - (s.x - i.x) * (e.y - t.y),
                            g = ((s.x - i.x) * (t.y - i.y) - (s.y - i.y) * (t.x - i.x)) / f,
                            m = ((e.x - t.x) * (t.y - i.y) - (e.y - t.y) * (t.x - i.x)) / f;
                        return g >= 0 && g <= 1 && m >= 0 && m <= 1 ? o : null
                    }
                    return o
                }, n.Line.intersects = function(t, e, i, s) {
                    return n.Line.intersectsPoints(t.start, t.end, e.start, e.end, i, s)
                }, n.Line.intersectsRectangle = function(t, e) {
                    if (0 === t.length || e.empty) return !1;
                    var i = t.start.x,
                        s = t.start.y,
                        n = t.end.x,
                        r = t.end.y,
                        o = e.x,
                        a = e.y,
                        h = e.right,
                        l = e.bottom,
                        c = 0;
                    if (i >= o && i <= h && s >= a && s <= l || n >= o && n <= h && r >= a && r <= l) return !0;
                    if (i < o && n >= o) {
                        if ((c = s + (r - s) * (o - i) / (n - i)) > a && c <= l) return !0
                    } else if (i > h && n <= h && (c = s + (r - s) * (h - i) / (n - i)) >= a && c <= l) return !0;
                    if (s < a && r >= a) {
                        if ((c = i + (n - i) * (a - s) / (r - s)) >= o && c <= h) return !0
                    } else if (s > l && r <= l && (c = i + (n - i) * (l - s) / (r - s)) >= o && c <= h) return !0;
                    return !1
                }, n.Line.intersectionWithRectangle = function(t, e, i) {
                    var s = n.Line.intersectionWithRectangle;
                    i || (i = new n.Point), s.edges || (s.edges = [new n.Line, new n.Line, new n.Line, new n.Line]), s.edgeIntersection || (s.edgeIntersection = new n.Point);
                    var r = s.edges,
                        o = s.edgeIntersection.set(0),
                        a = e.x,
                        h = e.y,
                        l = e.right,
                        c = e.bottom,
                        u = 1 / 0;
                    r[0].setTo(a, h, l, h), r[1].setTo(a, c, l, c), r[2].setTo(a, h, a, c), r[3].setTo(l, h, l, c);
                    for (var d, p = 0; d = r[p]; p++)
                        if (t.intersects(d, !0, o)) {
                            var f = t.start.distance(o);
                            f < u && (u = f, i.copyFrom(o))
                        } return null != f ? i : null
                }, n.Line.reflect = function(t, e) {
                    return 2 * e.normalAngle - 3.141592653589793 - t.angle
                }, n.Matrix = function(t, e, i, s, r, o) {
                    void 0 !== t && null !== t || (t = 1), void 0 !== e && null !== e || (e = 0), void 0 !== i && null !== i || (i = 0), void 0 !== s && null !== s || (s = 1), void 0 !== r && null !== r || (r = 0), void 0 !== o && null !== o || (o = 0), this.a = t, this.b = e, this.c = i, this.d = s, this.tx = r, this.ty = o, this.type = n.MATRIX
                }, n.Matrix.prototype = {
                    fromArray: function(t) {
                        return this.setTo(t[0], t[1], t[3], t[4], t[2], t[5])
                    },
                    setTo: function(t, e, i, s, n, r) {
                        return this.a = t, this.b = e, this.c = i, this.d = s, this.tx = n, this.ty = r, this
                    },
                    clone: function(t) {
                        return void 0 === t || null === t ? t = new n.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty), t
                    },
                    copyTo: function(t) {
                        return t.copyFrom(this), t
                    },
                    copyFrom: function(t) {
                        return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
                    },
                    toArray: function(t, e) {
                        return void 0 === e && (e = new Float32Array(9)), t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, e[7] = this.ty, e[8] = 1) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0, e[7] = 0, e[8] = 1), e
                    },
                    apply: function(t, e) {
                        return void 0 === e && (e = new n.Point), e.x = this.a * t.x + this.c * t.y + this.tx, e.y = this.b * t.x + this.d * t.y + this.ty, e
                    },
                    applyInverse: function(t, e) {
                        void 0 === e && (e = new n.Point);
                        var i = 1 / (this.a * this.d + this.c * -this.b),
                            s = t.x,
                            r = t.y;
                        return e.x = this.d * i * s + -this.c * i * r + (this.ty * this.c - this.tx * this.d) * i, e.y = this.a * i * r + -this.b * i * s + (-this.ty * this.a + this.tx * this.b) * i, e
                    },
                    translate: function(t, e) {
                        return this.tx += t, this.ty += e, this
                    },
                    scale: function(t, e) {
                        return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
                    },
                    rotate: function(t) {
                        var e = Math.cos(t),
                            i = Math.sin(t),
                            s = this.a,
                            n = this.c,
                            r = this.tx;
                        return this.a = s * e - this.b * i, this.b = s * i + this.b * e, this.c = n * e - this.d * i, this.d = n * i + this.d * e, this.tx = r * e - this.ty * i, this.ty = r * i + this.ty * e, this
                    },
                    append: function(t) {
                        var e = this.a,
                            i = this.b,
                            s = this.c,
                            n = this.d;
                        return this.a = t.a * e + t.b * s, this.b = t.a * i + t.b * n, this.c = t.c * e + t.d * s, this.d = t.c * i + t.d * n, this.tx = t.tx * e + t.ty * s + this.tx, this.ty = t.tx * i + t.ty * n + this.ty, this
                    },
                    identity: function() {
                        return this.setTo(1, 0, 0, 1, 0, 0)
                    }
                }, n.identityMatrix = new n.Matrix, n.Point = function(t, e) {
                    t = t || 0, e = e || 0, this.x = t, this.y = e, this.type = n.POINT
                }, n.Point.prototype = {
                    copyFrom: function(t) {
                        return this.setTo(t.x, t.y)
                    },
                    invert: function() {
                        return this.setTo(this.y, this.x)
                    },
                    setTo: function(t, e) {
                        return n.Point.set(this, t, e)
                    },
                    set: function(t, e) {
                        return n.Point.set(this, t, e)
                    },
                    setToPolar: function(t, e, i) {
                        return null == e && (e = 1), i && (t = n.Math.degToRad(t)), this.setTo(Math.cos(t) * e, Math.sin(t) * e)
                    },
                    add: function(t, e) {
                        return this.x += t, this.y += e, this
                    },
                    subtract: function(t, e) {
                        return this.x -= t, this.y -= e, this
                    },
                    multiply: function(t, e) {
                        return this.x *= t, this.y *= e, this
                    },
                    divide: function(t, e) {
                        return this.x /= t, this.y /= e, this
                    },
                    clampX: function(t, e) {
                        return this.x = n.Math.clamp(this.x, t, e), this
                    },
                    clampY: function(t, e) {
                        return this.y = n.Math.clamp(this.y, t, e), this
                    },
                    clamp: function(t, e) {
                        return this.x = n.Math.clamp(this.x, t, e), this.y = n.Math.clamp(this.y, t, e), this
                    },
                    clip: function(t) {
                        var e = t.left,
                            i = t.top,
                            s = t.right,
                            n = t.bottom;
                        return this.x < e ? this.x = e : this.x > s && (this.x = s), this.y < i ? this.y = i : this.y > n && (this.y = n), this
                    },
                    clone: function(t) {
                        return void 0 === t || null === t ? t = new n.Point(this.x, this.y) : t.setTo(this.x, this.y), t
                    },
                    copyTo: function(t) {
                        return t.x = this.x, t.y = this.y, t
                    },
                    distance: function(t, e) {
                        return n.Point.distance(this, t, e)
                    },
                    equals: function(t) {
                        return t.x === this.x && t.y === this.y
                    },
                    equalsXY: function(t, e) {
                        return this.x === t && this.y === e
                    },
                    fuzzyEquals: function(t, e) {
                        return n.Point.fuzzyEquals(this, t, e)
                    },
                    fuzzyEqualsXY: function(t, e, i) {
                        return n.Point.fuzzyEqualsXY(this, t, e, i)
                    },
                    angle: function(t, e) {
                        return this.angleXY(t.x, t.y, e)
                    },
                    angleXY: function(t, e, i) {
                        var s = Math.atan2(e - this.y, t - this.x);
                        return i ? n.Math.radToDeg(s) : s
                    },
                    atan: function(t) {
                        var e = Math.atan2(this.y, this.x);
                        return t ? n.Math.radToDeg(e) : e
                    },
                    rotate: function(t, e, i, s, r) {
                        return n.Point.rotate(this, t, e, i, s, r)
                    },
                    getMagnitude: function() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    },
                    getMagnitudeSq: function() {
                        return this.x * this.x + this.y * this.y
                    },
                    setMagnitude: function(t) {
                        return this.normalize().multiply(t, t)
                    },
                    normalize: function() {
                        if (!this.isZero()) {
                            var t = this.getMagnitude();
                            this.x /= t, this.y /= t
                        }
                        return this
                    },
                    limit: function(t) {
                        return this.getMagnitudeSq() > t * t && this.setMagnitude(t), this
                    },
                    expand: function(t) {
                        return this.getMagnitudeSq() < t * t && this.setMagnitude(t), this
                    },
                    isZero: function() {
                        return 0 === this.x && 0 === this.y
                    },
                    dot: function(t) {
                        return this.x * t.x + this.y * t.y
                    },
                    cross: function(t) {
                        return this.x * t.y - this.y * t.x
                    },
                    perp: function() {
                        return this.setTo(-this.y, this.x)
                    },
                    rperp: function() {
                        return this.setTo(this.y, -this.x)
                    },
                    normalRightHand: function() {
                        return this.setTo(-1 * this.y, this.x)
                    },
                    floor: function() {
                        return this.setTo(Math.floor(this.x), Math.floor(this.y))
                    },
                    ceil: function() {
                        return this.setTo(Math.ceil(this.x), Math.ceil(this.y))
                    },
                    round: function() {
                        return this.setTo(Math.round(this.x), Math.round(this.y))
                    },
                    toString: function() {
                        return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
                    }
                }, n.Point.prototype.constructor = n.Point, n.Point.add = function(t, e, i) {
                    return void 0 === i && (i = new n.Point), i.x = t.x + e.x, i.y = t.y + e.y, i
                }, n.Point.subtract = function(t, e, i) {
                    return void 0 === i && (i = new n.Point), i.x = t.x - e.x, i.y = t.y - e.y, i
                }, n.Point.multiply = function(t, e, i) {
                    return void 0 === i && (i = new n.Point), i.x = t.x * e.x, i.y = t.y * e.y, i
                }, n.Point.divide = function(t, e, i) {
                    return void 0 === i && (i = new n.Point), i.x = t.x / e.x, i.y = t.y / e.y, i
                }, n.Point.equals = function(t, e) {
                    return t.x === e.x && t.y === e.y
                }, n.Point.equalsXY = function(t, e, i) {
                    return t.x === e && t.y === i
                }, n.Point.fuzzyEquals = function(t, e, i) {
                    return n.Math.fuzzyEqual(t.x, e.x, i) && n.Math.fuzzyEqual(t.y, e.y, i)
                }, n.Point.fuzzyEqualsXY = function(t, e, i, s) {
                    return n.Math.fuzzyEqual(t.x, e, s) && n.Math.fuzzyEqual(t.y, i, s)
                }, n.Point.angle = function(t, e) {
                    return Math.atan2(t.y - e.y, t.x - e.x)
                }, n.Point.negative = function(t, e) {
                    return void 0 === e && (e = new n.Point), e.setTo(-t.x, -t.y)
                }, n.Point.multiplyAdd = function(t, e, i, s) {
                    return void 0 === s && (s = new n.Point), s.setTo(t.x + e.x * i, t.y + e.y * i)
                }, n.Point.interpolate = function(t, e, i, s) {
                    return void 0 === s && (s = new n.Point), s.setTo(t.x + (e.x - t.x) * i, t.y + (e.y - t.y) * i)
                }, n.Point.perp = function(t, e) {
                    return void 0 === e && (e = new n.Point), e.setTo(-t.y, t.x)
                }, n.Point.rperp = function(t, e) {
                    return void 0 === e && (e = new n.Point), e.setTo(t.y, -t.x)
                }, n.Point.distance = function(t, e, i) {
                    var s = n.Math.distance(t.x, t.y, e.x, e.y);
                    return i ? Math.round(s) : s
                }, n.Point.project = function(t, e, i) {
                    void 0 === i && (i = new n.Point);
                    var s = t.dot(e) / e.getMagnitudeSq();
                    return 0 !== s && i.setTo(s * e.x, s * e.y), i
                }, n.Point.projectUnit = function(t, e, i) {
                    void 0 === i && (i = new n.Point);
                    var s = t.dot(e);
                    return 0 !== s && i.setTo(s * e.x, s * e.y), i
                }, n.Point.normalRightHand = function(t, e) {
                    return void 0 === e && (e = new n.Point), e.setTo(-1 * t.y, t.x)
                }, n.Point.normalize = function(t, e) {
                    void 0 === e && (e = new n.Point);
                    var i = t.getMagnitude();
                    return 0 !== i && e.setTo(t.x / i, t.y / i), e
                }, n.Point.rotate = function(t, e, i, s, r, o) {
                    if (r && (s = n.Math.degToRad(s)), void 0 === o) {
                        t.subtract(e, i);
                        var a = Math.sin(s),
                            h = Math.cos(s),
                            l = h * t.x - a * t.y,
                            c = a * t.x + h * t.y;
                        t.x = l + e, t.y = c + i
                    } else {
                        var u = s + Math.atan2(t.y - i, t.x - e);
                        t.x = e + o * Math.cos(u), t.y = i + o * Math.sin(u)
                    }
                    return t
                }, n.Point.centroid = function(t, e) {
                    if (void 0 === e && (e = new n.Point), "[object Array]" !== Object.prototype.toString.call(t)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
                    var i = t.length;
                    if (i < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
                    if (1 === i) return e.copyFrom(t[0]), e;
                    for (var s = 0; s < i; s++) n.Point.add(e, t[s], e);
                    return e.divide(i, i), e
                }, n.Point.parse = function(t, e, i) {
                    e = e || "x", i = i || "y";
                    var s = new n.Point;
                    return t[e] && (s.x = parseFloat(t[e])), t[i] && (s.y = parseFloat(t[i])), s
                }, n.Point.trunc = function(t) {
                    return t.x = n.Math.trunc(t.x), t.y = n.Math.trunc(t.y), t
                }, n.Point.isPoint = function(t) {
                    return null != t && "number" == typeof t.x && "number" == typeof t.y
                }, n.Point.set = function(t, e, i) {
                    return t.x = e || 0, t.y = i || (0 !== i ? t.x : 0), t
                }, n.Point.sortClockwise = function(t, e) {
                    e || (e = this.centroid(t));
                    var i = e.x,
                        s = e.y;
                    return t.sort(function(t, e) {
                        if (t.x - i >= 0 && e.x - i < 0) return -1;
                        if (t.x - i < 0 && e.x - i >= 0) return 1;
                        if (t.x - i == 0 && e.x - i == 0) return t.y - s >= 0 || e.y - s >= 0 ? t.y > e.y ? 1 : -1 : e.y > t.y ? 1 : -1;
                        var n = (t.x - i) * -(e.y - s) - (e.x - i) * -(t.y - s);
                        return n < 0 ? -1 : n > 0 ? 1 : (t.x - i) * (t.x - i) + (t.y - s) * (t.y - s) > (e.x - i) * (e.x - i) + (e.y - s) * (e.y - s) ? -1 : 1
                    })
                }, PIXI.Point = n.Point, n.Polygon = function() {
                    this.area = 0, this._points = [], arguments.length > 0 && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = n.POLYGON
                }, n.Polygon.prototype = {
                    toNumberArray: function(t) {
                        void 0 === t && (t = []);
                        for (var e = 0; e < this._points.length; e++) "number" == typeof this._points[e] ? (t.push(this._points[e]), t.push(this._points[e + 1]), e++) : (t.push(this._points[e].x), t.push(this._points[e].y));
                        return t
                    },
                    flatten: function() {
                        return this._points = this.toNumberArray(), this.flattened = !0, this
                    },
                    clone: function(t) {
                        var e = this._points.slice();
                        return void 0 === t || null === t ? t = new n.Polygon(e) : t.setTo(e), t
                    },
                    contains: function(t, e) {
                        var i = !1;
                        if (this.flattened)
                            for (var s = -2, n = this._points.length - 2;
                                (s += 2) < this._points.length; n = s) {
                                var r = this._points[s],
                                    o = this._points[s + 1],
                                    a = this._points[n],
                                    h = this._points[n + 1];
                                (o <= e && e < h || h <= e && e < o) && t < (a - r) * (e - o) / (h - o) + r && (i = !i)
                            } else
                                for (s = -1, n = this._points.length - 1; ++s < this._points.length; n = s) {
                                    r = this._points[s].x, o = this._points[s].y, a = this._points[n].x, h = this._points[n].y;
                                    (o <= e && e < h || h <= e && e < o) && t < (a - r) * (e - o) / (h - o) + r && (i = !i)
                                }
                        return i
                    },
                    setTo: function(t) {
                        if (this.area = 0, this._points = [], arguments.length > 0) {
                            Array.isArray(t) || (t = Array.prototype.slice.call(arguments));
                            for (var e = Number.MAX_VALUE, i = 0, s = t.length; i < s; i++) {
                                if ("number" == typeof t[i]) {
                                    var n = new PIXI.Point(t[i], t[i + 1]);
                                    i++
                                } else if (Array.isArray(t[i])) n = new PIXI.Point(t[i][0], t[i][1]);
                                else n = new PIXI.Point(t[i].x, t[i].y);
                                this._points.push(n), n.y < e && (e = n.y)
                            }
                            this.calculateArea(e)
                        }
                        return this
                    },
                    calculateArea: function(t) {
                        for (var e, i, s, n, r = 0, o = this._points.length; r < o; r++) e = this._points[r], i = r === o - 1 ? this._points[0] : this._points[r + 1], s = (e.y - t + (i.y - t)) / 2, n = e.x - i.x, this.area += s * n;
                        return this.area
                    }
                }, n.Polygon.prototype.constructor = n.Polygon, Object.defineProperty(n.Polygon.prototype, "points", {
                    get: function() {
                        return this._points
                    }
                }), PIXI.Polygon = n.Polygon, n.Rectangle = function(t, e, i, s) {
                    t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.x = t, this.y = e, this.width = i, this.height = s, this.type = n.RECTANGLE
                }, n.Rectangle.prototype = {
                    offset: function(t, e) {
                        return this.x += t, this.y += e, this
                    },
                    offsetPoint: function(t) {
                        return this.offset(t.x, t.y)
                    },
                    setTo: function(t, e, i, s) {
                        return this.x = t, this.y = e, this.width = i, this.height = s, this
                    },
                    scale: function(t, e) {
                        return void 0 === e && (e = t), this.width *= t, this.height *= e, this
                    },
                    centerOn: function(t, e) {
                        return this.centerX = t, this.centerY = e, this
                    },
                    floor: function() {
                        this.x = Math.floor(this.x), this.y = Math.floor(this.y)
                    },
                    floorAll: function() {
                        this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height)
                    },
                    ceil: function() {
                        this.x = Math.ceil(this.x), this.y = Math.ceil(this.y)
                    },
                    ceilAll: function() {
                        this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height)
                    },
                    copyFrom: function(t) {
                        return this.setTo(t.x, t.y, t.width, t.height)
                    },
                    copyFromBounds: function(t) {
                        return this.setTo(t.left, t.top, t.width, t.height)
                    },
                    copyTo: function(t) {
                        return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                    },
                    inflate: function(t, e) {
                        return n.Rectangle.inflate(this, t, e)
                    },
                    size: function(t) {
                        return n.Rectangle.size(this, t)
                    },
                    resize: function(t, e) {
                        return this.width = t, this.height = e, this
                    },
                    clone: function(t) {
                        return n.Rectangle.clone(this, t)
                    },
                    contains: function(t, e) {
                        return n.Rectangle.contains(this, t, e)
                    },
                    containsRect: function(t) {
                        return n.Rectangle.containsRect(t, this)
                    },
                    equals: function(t) {
                        return n.Rectangle.equals(this, t)
                    },
                    intersection: function(t, e) {
                        return n.Rectangle.intersection(this, t, e)
                    },
                    intersects: function(t) {
                        return n.Rectangle.intersects(this, t)
                    },
                    intersectsRaw: function(t, e, i, s, r) {
                        return n.Rectangle.intersectsRaw(this, t, e, i, s, r)
                    },
                    union: function(t, e) {
                        return n.Rectangle.union(this, t, e)
                    },
                    random: function(t) {
                        return void 0 === t && (t = new n.Point), t.x = this.randomX, t.y = this.randomY, t
                    },
                    getPoint: function(t, e) {
                        switch (void 0 === e && (e = new n.Point), t) {
                            default:
                            case n.TOP_LEFT:
                                return e.set(this.x, this.y);
                            case n.TOP_CENTER:
                                return e.set(this.centerX, this.y);
                            case n.TOP_RIGHT:
                                return e.set(this.right, this.y);
                            case n.LEFT_CENTER:
                                return e.set(this.x, this.centerY);
                            case n.CENTER:
                                return e.set(this.centerX, this.centerY);
                            case n.RIGHT_CENTER:
                                return e.set(this.right, this.centerY);
                            case n.BOTTOM_LEFT:
                                return e.set(this.x, this.bottom);
                            case n.BOTTOM_CENTER:
                                return e.set(this.centerX, this.bottom);
                            case n.BOTTOM_RIGHT:
                                return e.set(this.right, this.bottom)
                        }
                    },
                    sides: function(t, e, i, s) {
                        arguments.length || (t = new n.Line, e = new n.Line, i = new n.Line, s = new n.Line);
                        var r = this.x,
                            o = this.y,
                            a = this.right,
                            h = this.bottom;
                        return t.setTo(r, o, a, o), e.setTo(a, o, a, h), i.setTo(r, h, a, h), s.setTo(r, o, r, h), arguments.length ? null : [t, e, i, s]
                    },
                    toString: function() {
                        return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
                    }
                }, Object.defineProperty(n.Rectangle.prototype, "halfWidth", {
                    get: function() {
                        return Math.round(this.width / 2)
                    }
                }), Object.defineProperty(n.Rectangle.prototype, "halfHeight", {
                    get: function() {
                        return Math.round(this.height / 2)
                    }
                }), Object.defineProperty(n.Rectangle.prototype, "bottom", {
                    get: function() {
                        return this.y + this.height
                    },
                    set: function(t) {
                        t <= this.y ? this.height = 0 : this.height = t - this.y
                    }
                }), Object.defineProperty(n.Rectangle.prototype, "bottomLeft", {
                    get: function() {
                        return new n.Point(this.x, this.bottom)
                    },
                    set: function(t) {
                        this.x = t.x, this.bottom = t.y
                    }
                }), Object.defineProperty(n.Rectangle.prototype, "bottomRight", {
                    get: function() {
                        return new n.Point(this.right, this.bottom)
                    },
                    set: function(t) {
                        this.right = t.x, this.bottom = t.y
                    }
                }), Object.defineProperty(n.Rectangle.prototype, "left", {
                    get: function() {
                        return this.x
                    },
                    set: function(t) {
                        t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t
                    }
                }), Object.defineProperty(n.Rectangle.prototype, "right", {
                    get: function() {
                        return this.x + this.width
                    },
                    set: function(t) {
                        t <= this.x ? this.width = 0 : this.width = t - this.x
                    }
                }), Object.defineProperty(n.Rectangle.prototype, "volume", {
                    get: function() {
                        return this.width * this.height
                    }
                }), Object.defineProperty(n.Rectangle.prototype, "perimeter", {
                    get: function() {
                        return 2 * this.width + 2 * this.height
                    }
                }), Object.defineProperty(n.Rectangle.prototype, "centerX", {
                    get: function() {
                        return this.x + this.halfWidth
                    },
                    set: function(t) {
                        this.x = t - this.halfWidth
                    }
                }), Object.defineProperty(n.Rectangle.prototype, "centerY", {
                    get: function() {
                        return this.y + this.halfHeight
                    },
                    set: function(t) {
                        this.y = t - this.halfHeight
                    }
                }), Object.defineProperty(n.Rectangle.prototype, "randomX", {
                    get: function() {
                        return this.x + Math.random() * this.width
                    }
                }), Object.defineProperty(n.Rectangle.prototype, "randomY", {
                    get: function() {
                        return this.y + Math.random() * this.height
                    }
                }), Object.defineProperty(n.Rectangle.prototype, "top", {
                    get: function() {
                        return this.y
                    },
                    set: function(t) {
                        t >= this.bottom ? (this.height = 0, this.y = t) : this.height = this.bottom - t
                    }
                }), Object.defineProperty(n.Rectangle.prototype, "topLeft", {
                    get: function() {
                        return new n.Point(this.x, this.y)
                    },
                    set: function(t) {
                        this.x = t.x, this.y = t.y
                    }
                }), Object.defineProperty(n.Rectangle.prototype, "topRight", {
                    get: function() {
                        return new n.Point(this.x + this.width, this.y)
                    },
                    set: function(t) {
                        this.right = t.x, this.y = t.y
                    }
                }), Object.defineProperty(n.Rectangle.prototype, "empty", {
                    get: function() {
                        return !this.width || !this.height
                    },
                    set: function(t) {
                        !0 === t && this.setTo(0, 0, 0, 0)
                    }
                }), n.Rectangle.prototype.constructor = n.Rectangle, n.Rectangle.inflate = function(t, e, i) {
                    return t.x -= e, t.width += 2 * e, t.y -= i, t.height += 2 * i, t
                }, n.Rectangle.inflatePoint = function(t, e) {
                    return n.Rectangle.inflate(t, e.x, e.y)
                }, n.Rectangle.size = function(t, e) {
                    return void 0 === e || null === e ? e = new n.Point(t.width, t.height) : e.setTo(t.width, t.height), e
                }, n.Rectangle.clone = function(t, e) {
                    return void 0 === e || null === e ? e = new n.Rectangle(t.x, t.y, t.width, t.height) : e.setTo(t.x, t.y, t.width, t.height), e
                }, n.Rectangle.createFromBounds = function(t, e) {
                    return void 0 !== e && null !== e || (e = new n.Rectangle(t.x, t.y, t.width, t.height)), e.copyFromBounds(t)
                }, n.Rectangle.contains = function(t, e, i) {
                    return !(t.width <= 0 || t.height <= 0) && (e >= t.x && e < t.right && i >= t.y && i < t.bottom)
                }, n.Rectangle.containsRaw = function(t, e, i, s, n, r) {
                    return n >= t && n < t + i && r >= e && r < e + s
                }, n.Rectangle.containsPoint = function(t, e) {
                    return n.Rectangle.contains(t, e.x, e.y)
                }, n.Rectangle.containsRect = function(t, e) {
                    return !(t.volume > e.volume) && (t.x >= e.x && t.y >= e.y && t.right < e.right && t.bottom < e.bottom)
                }, n.Rectangle.equals = function(t, e) {
                    return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
                }, n.Rectangle.sameDimensions = function(t, e) {
                    return t.width === e.width && t.height === e.height
                }, n.Rectangle.intersection = function(t, e, i) {
                    return void 0 === i && (i = new n.Rectangle), n.Rectangle.intersects(t, e) && (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y), i
                }, n.Rectangle.intersects = function(t, e) {
                    return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0) && !(t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom)
                }, n.Rectangle.intersectsRaw = function(t, e, i, s, n, r) {
                    return void 0 === r && (r = 0), !(e > t.right + r || i < t.left - r || s > t.bottom + r || n < t.top - r)
                }, n.Rectangle.union = function(t, e, i) {
                    return void 0 === i && (i = new n.Rectangle), i.setTo(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.max(t.right, e.right) - Math.min(t.left, e.left), Math.max(t.bottom, e.bottom) - Math.min(t.top, e.top))
                }, n.Rectangle.aabb = function(t, e) {
                    void 0 === e && (e = new n.Rectangle);
                    var i = Number.NEGATIVE_INFINITY,
                        s = Number.POSITIVE_INFINITY,
                        r = Number.NEGATIVE_INFINITY,
                        o = Number.POSITIVE_INFINITY;
                    return t.forEach(function(t) {
                        t.x > i && (i = t.x), t.x < s && (s = t.x), t.y > r && (r = t.y), t.y < o && (o = t.y)
                    }), e.setTo(s, o, i - s, r - o), e
                }, PIXI.Rectangle = n.Rectangle, n.EmptyRectangle = new n.Rectangle(0, 0, 0, 0), n.RoundedRectangle = function(t, e, i, s, r) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === r && (r = 20), this.x = t, this.y = e, this.width = i, this.height = s, this.radius = r || 20, this.type = n.ROUNDEDRECTANGLE
                }, n.RoundedRectangle.prototype = {
                    clone: function() {
                        return new n.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius)
                    },
                    contains: function(t, e) {
                        if (this.width <= 0 || this.height <= 0) return !1;
                        var i = this.x;
                        if (t >= i && t <= i + this.width) {
                            var s = this.y;
                            if (e >= s && e <= s + this.height) return !0
                        }
                        return !1
                    }
                }, n.RoundedRectangle.prototype.constructor = n.RoundedRectangle, PIXI.RoundedRectangle = n.RoundedRectangle, n.Camera = function(t, e, i, s, r, o) {
                    this.game = t, this.world = t.world, this.id = 0, this.view = new n.Rectangle(i, s, r, o), this.bounds = new n.Rectangle(i, s, r, o), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = {
                        x: !1,
                        y: !1
                    }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new n.Point(1, 1), this.onShakeComplete = new n.Signal, this.onFlashComplete = new n.Signal, this.onFadeComplete = new n.Signal, this.fx = null, this._targetPosition = new n.Point, this._edge = 0, this._position = new n.Point, this._shake = {
                        intensity: 0,
                        duration: 0,
                        horizontal: !1,
                        vertical: !1,
                        shakeBounds: !0,
                        x: 0,
                        y: 0
                    }, this._fxDuration = 0, this._fxType = 0, this._fixedView = new n.Rectangle
                }, n.Camera.FOLLOW_LOCKON = 0, n.Camera.FOLLOW_PLATFORMER = 1, n.Camera.FOLLOW_TOPDOWN = 2, n.Camera.FOLLOW_TOPDOWN_TIGHT = 3, n.Camera.SHAKE_BOTH = 4, n.Camera.SHAKE_HORIZONTAL = 5, n.Camera.SHAKE_VERTICAL = 6, n.Camera.ENABLE_FX = !0, n.Camera.prototype = {
                    boot: function() {
                        this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, n.Graphics && n.Camera.ENABLE_FX && (this.fx = new n.Graphics(this.game), this.game.stage.addChild(this.fx))
                    },
                    preUpdate: function() {
                        this.totalInView = 0
                    },
                    follow: function(t, e, i, s) {
                        var r;
                        switch (void 0 === e && (e = n.Camera.FOLLOW_LOCKON), void 0 === i && (i = 1), void 0 === s && (s = 1), this.target = t, this.lerp.set(i, s), e) {
                            case n.Camera.FOLLOW_PLATFORMER:
                                var o = this.width / 8,
                                    a = this.height / 3;
                                this.deadzone = new n.Rectangle((this.width - o) / 2, (this.height - a) / 2 - .25 * a, o, a);
                                break;
                            case n.Camera.FOLLOW_TOPDOWN:
                                r = Math.max(this.width, this.height) / 4, this.deadzone = new n.Rectangle((this.width - r) / 2, (this.height - r) / 2, r, r);
                                break;
                            case n.Camera.FOLLOW_TOPDOWN_TIGHT:
                                r = Math.max(this.width, this.height) / 8, this.deadzone = new n.Rectangle((this.width - r) / 2, (this.height - r) / 2, r, r);
                                break;
                            case n.Camera.FOLLOW_LOCKON:
                            default:
                                this.deadzone = null
                        }
                    },
                    unfollow: function() {
                        this.target = null
                    },
                    focusOn: function(t) {
                        this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight))
                    },
                    focusOnXY: function(t, e) {
                        this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight))
                    },
                    shake: function(t, e, i, s, r) {
                        return void 0 === t && (t = .05), void 0 === e && (e = 500), void 0 === i && (i = !0), void 0 === s && (s = n.Camera.SHAKE_BOTH), void 0 === r && (r = !0), !(!i && this._shake.duration > 0) && (this._shake.intensity = t, this._shake.duration = e, this._shake.shakeBounds = r, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = s === n.Camera.SHAKE_BOTH || s === n.Camera.SHAKE_HORIZONTAL, this._shake.vertical = s === n.Camera.SHAKE_BOTH || s === n.Camera.SHAKE_VERTICAL, !0)
                    },
                    flash: function(t, e, i, s) {
                        return void 0 === t && (t = 16777215), void 0 === e && (e = 500), void 0 === i && (i = !1), void 0 === s && (s = 1), !(!this.fx || !i && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(t, s), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = e, this._fxType = 0, !0)
                    },
                    fade: function(t, e, i, s) {
                        return void 0 === t && (t = 0), void 0 === e && (e = 500), void 0 === i && (i = !1), void 0 === s && (s = 1), !(!this.fx || !i && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(t, s), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = e, this._fxType = 1, !0)
                    },
                    update: function() {
                        this._fxDuration > 0 && this.updateFX(), this._shake.duration > 0 && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                    },
                    updateFX: function() {
                        0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, this.fx.alpha >= 1 && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch()))
                    },
                    updateShake: function() {
                        this._shake.duration -= this.game.time.elapsedMS, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height))
                    },
                    updateTarget: function() {
                        this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                    },
                    setBoundsToWorld: function() {
                        this.bounds && this.bounds.copyFrom(this.game.world.bounds)
                    },
                    checkBounds: function() {
                        this.atLimit.x = !1, this.atLimit.y = !1;
                        var t = this.view.x + this._shake.x,
                            e = this.view.right + this._shake.x,
                            i = this.view.y + this._shake.y,
                            s = this.view.bottom + this._shake.y;
                        t <= this.bounds.x * this.scale.x ? (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)) : e >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), i <= this.bounds.top * this.scale.y ? (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)) : s >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0))
                    },
                    setPosition: function(t, e) {
                        this.view.x = t, this.view.y = e, this.bounds && this.checkBounds()
                    },
                    setSize: function(t, e) {
                        this.view.width = t, this.view.height = e
                    },
                    reset: function() {
                        this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this._shake.x = 0, this._shake.y = 0, this.resetFX()
                    },
                    resetFX: function() {
                        this.fx && (this.fx.clear(), this.fx.alpha = 0), this._fxDuration = 0
                    }
                }, n.Camera.prototype.constructor = n.Camera, Object.defineProperty(n.Camera.prototype, "x", {
                    get: function() {
                        return this.view.x
                    },
                    set: function(t) {
                        this.view.x = t, this.bounds && this.checkBounds()
                    }
                }), Object.defineProperty(n.Camera.prototype, "y", {
                    get: function() {
                        return this.view.y
                    },
                    set: function(t) {
                        this.view.y = t, this.bounds && this.checkBounds()
                    }
                }), Object.defineProperty(n.Camera.prototype, "position", {
                    get: function() {
                        return this._position.set(this.view.x, this.view.y), this._position
                    },
                    set: function(t) {
                        void 0 !== t.x && (this.view.x = t.x), void 0 !== t.y && (this.view.y = t.y), this.bounds && this.checkBounds()
                    }
                }), Object.defineProperty(n.Camera.prototype, "width", {
                    get: function() {
                        return this.view.width
                    },
                    set: function(t) {
                        this.view.width = t
                    }
                }), Object.defineProperty(n.Camera.prototype, "height", {
                    get: function() {
                        return this.view.height
                    },
                    set: function(t) {
                        this.view.height = t
                    }
                }), Object.defineProperty(n.Camera.prototype, "shakeIntensity", {
                    get: function() {
                        return this._shake.intensity
                    },
                    set: function(t) {
                        this._shake.intensity = t
                    }
                }), Object.defineProperty(n.Camera.prototype, "fixedView", {
                    get: function() {
                        return this._fixedView.setTo(0, 0, this.view.width, this.view.height), this._fixedView
                    }
                }), Object.defineProperty(n.Camera.prototype, "centerX", {
                    get: function() {
                        return this.x + .5 * this.width
                    }
                }), Object.defineProperty(n.Camera.prototype, "centerY", {
                    get: function() {
                        return this.y + .5 * this.height
                    }
                }), n.State = function() {
                    this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null
                }, n.State.prototype = {
                    init: function() {},
                    preload: function() {},
                    loadUpdate: function() {},
                    loadRender: function() {},
                    create: function() {},
                    update: function() {},
                    postUpdate: function() {},
                    preRender: function() {},
                    render: function() {},
                    resize: function() {},
                    paused: function() {},
                    resumed: function() {},
                    pauseUpdate: function() {},
                    shutdown: function() {}
                }, n.State.prototype.constructor = n.State, n.StateManager = function(t, e) {
                    this.game = t, this.states = {}, this._pendingState = null, void 0 !== e && null !== e && (this._pendingState = e), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new n.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null
                }, n.StateManager.prototype = {
                    boot: function() {
                        this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0)
                    },
                    add: function(t, e, i) {
                        var s;
                        return void 0 === i && (i = !1), e instanceof n.State ? s = e : "object" == typeof e ? (s = e).game = this.game : "function" == typeof e && (s = new e(this.game)), this.states[t] = s, i && (this.game.isBooted ? this.start(t) : this._pendingState = t), s
                    },
                    remove: function(t) {
                        this.current === t && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[t]
                    },
                    start: function(t, e, i) {
                        void 0 === e && (e = !0), void 0 === i && (i = !1), this.checkState(t) && (this._pendingState = t, this._clearWorld = e, this._clearCache = i, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)))
                    },
                    restart: function(t, e) {
                        void 0 === t && (t = !0), void 0 === e && (e = !1), this._pendingState = this.current, this._clearWorld = t, this._clearCache = e, arguments.length > 2 && (this._args = Array.prototype.slice.call(arguments, 2))
                    },
                    dummy: function() {},
                    preUpdate: function() {
                        if (this._pendingState && this.game.isBooted) {
                            var t = this.current;
                            if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, t), this.current !== this._pendingState) return;
                            this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
                        }
                    },
                    clearCurrentState: function() {
                        this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy()))
                    },
                    checkState: function(t) {
                        var e = this.states[t];
                        return e ? !!(e.preload || e.create || e.update || e.render) || (console.warn("Invalid Phaser State object given. Must contain at least one of the required functions: preload, create, update or render"), !1) : (console.warn("Phaser.StateManager - No state found with the key: " + t), !1)
                    },
                    link: function(t) {
                        var e = this.states[t];
                        e.game = this.game, e.add = this.game.add, e.make = this.game.make, e.camera = this.game.camera, e.cache = this.game.cache, e.input = this.game.input, e.load = this.game.load, e.math = this.game.math, e.sound = this.game.sound, e.scale = this.game.scale, e.state = this, e.stage = this.game.stage, e.time = this.game.time, e.tweens = this.game.tweens, e.world = this.game.world, e.particles = this.game.particles, e.rnd = this.game.rnd, e.physics = this.game.physics, e.key = t
                    },
                    unlink: function(t) {
                        var e = this.states[t];
                        e && (e.game = null, e.add = null, e.make = null, e.camera = null, e.cache = null, e.input = null, e.load = null, e.math = null, e.sound = null, e.scale = null, e.state = null, e.stage = null, e.time = null, e.tweens = null, e.world = null, e.particles = null, e.rnd = null, e.physics = null)
                    },
                    setCurrentState: function(t) {
                        var e = this.states[t];
                        this.callbackContext = e, this.link(t), this.onInitCallback = e.init || this.dummy, this.onPreloadCallback = e.preload || null, this.onLoadRenderCallback = e.loadRender || null, this.onLoadUpdateCallback = e.loadUpdate || null, this.onCreateCallback = e.create || null, this.onUpdateCallback = e.update || null, this.onPostUpdateCallback = e.postUpdate || null, this.onPreRenderCallback = e.preRender || null, this.onRenderCallback = e.render || null, this.onResizeCallback = e.resize || null, this.onPausedCallback = e.paused || null, this.onResumedCallback = e.resumed || null, this.onPauseUpdateCallback = e.pauseUpdate || null, this.onShutDownCallback = e.shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = t, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), t === this._pendingState && (this._args = []), this.game._kickstart = !0
                    },
                    getCurrentState: function() {
                        return this.states[this.current]
                    },
                    loadComplete: function() {
                        !1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
                    },
                    loadUpdate: function() {
                        !1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                    },
                    pause: function() {
                        this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
                    },
                    resume: function() {
                        this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
                    },
                    update: function() {
                        this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                    },
                    postUpdate: function() {
                        this._created && this.onPostUpdateCallback && this.onPostUpdateCallback.call(this.callbackContext, this.game)
                    },
                    pauseUpdate: function() {
                        this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                    },
                    preRender: function(t) {
                        this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, t)
                    },
                    resize: function(t, e) {
                        this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, t, e)
                    },
                    render: function() {
                        this._created ? this.onRenderCallback && (this.game.renderType === n.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
                    },
                    destroy: function() {
                        this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPostUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = ""
                    }
                }, n.StateManager.prototype.constructor = n.StateManager, Object.defineProperty(n.StateManager.prototype, "created", {
                    get: function() {
                        return this._created
                    }
                }), n.Signal = function() {}, n.Signal.prototype = {
                    _bindings: null,
                    _prevParams: null,
                    memorize: !1,
                    _shouldPropagate: !0,
                    active: !0,
                    _boundDispatch: !1,
                    validateListener: function(t, e) {
                        if ("function" != typeof t) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e))
                    },
                    _registerListener: function(t, e, i, s, r) {
                        var o, a = this._indexOfListener(t, i);
                        if (-1 !== a) {
                            if ((o = this._bindings[a]).isOnce() !== e) throw new Error("You cannot add" + (e ? "" : "Once") + "() then add" + (e ? "Once" : "") + "() the same listener without removing the relationship first.")
                        } else o = new n.SignalBinding(this, t, e, i, s, r), this._addBinding(o);
                        return this.memorize && this._prevParams && o.execute(this._prevParams), o
                    },
                    _addBinding: function(t) {
                        this._bindings || (this._bindings = []);
                        var e = this._bindings.length;
                        do {
                            e--
                        } while (this._bindings[e] && t._priority <= this._bindings[e]._priority);
                        this._bindings.splice(e + 1, 0, t)
                    },
                    _indexOfListener: function(t, e) {
                        if (!this._bindings) return -1;
                        void 0 === e && (e = null);
                        for (var i, s = this._bindings.length; s--;)
                            if ((i = this._bindings[s])._listener === t && i.context === e) return s;
                        return -1
                    },
                    has: function(t, e) {
                        return -1 !== this._indexOfListener(t, e)
                    },
                    add: function(t, e, i) {
                        this.validateListener(t, "add");
                        var s = [];
                        if (arguments.length > 3)
                            for (var n = 3; n < arguments.length; n++) s.push(arguments[n]);
                        return this._registerListener(t, !1, e, i, s)
                    },
                    addOnce: function(t, e, i) {
                        this.validateListener(t, "addOnce");
                        var s = [];
                        if (arguments.length > 3)
                            for (var n = 3; n < arguments.length; n++) s.push(arguments[n]);
                        return this._registerListener(t, !0, e, i, s)
                    },
                    remove: function(t, e) {
                        this.validateListener(t, "remove");
                        var i = this._indexOfListener(t, e);
                        return -1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), t
                    },
                    removeAll: function(t) {
                        if (void 0 === t && (t = null), this._bindings) {
                            for (var e = this._bindings.length; e--;) t ? this._bindings[e].context === t && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                            t || (this._bindings.length = 0)
                        }
                    },
                    getNumListeners: function() {
                        return this._bindings ? this._bindings.length : 0
                    },
                    halt: function() {
                        this._shouldPropagate = !1
                    },
                    dispatch: function() {
                        if (this.active && (this._bindings || this.memorize)) {
                            var t = Array.prototype.slice.call(arguments);
                            this.memorize && (this._prevParams = t);
                            var e = this._bindings ? this._bindings.length : 0;
                            if (e) {
                                var i = this._bindings.slice();
                                this._shouldPropagate = !0;
                                do {
                                    e--
                                } while (i[e] && this._shouldPropagate && !1 !== i[e].execute(t))
                            }
                        }
                    },
                    forget: function() {
                        this._prevParams && (this._prevParams = null)
                    },
                    dispose: function() {
                        this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null)
                    },
                    toString: function() {
                        return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
                    }
                }, Object.defineProperty(n.Signal.prototype, "boundDispatch", {
                    get: function() {
                        var t = this;
                        return this._boundDispatch || (this._boundDispatch = function() {
                            return t.dispatch.apply(t, arguments)
                        })
                    }
                }), n.Signal.prototype.constructor = n.Signal, n.SignalBinding = function(t, e, i, s, n, r) {
                    this._listener = e, i && (this._isOnce = !0), null != s && (this.context = s), this._signal = t, n && (this._priority = n), r && r.length && (this._args = r)
                }, n.SignalBinding.prototype = {
                    context: null,
                    _isOnce: !1,
                    _priority: 0,
                    _args: null,
                    callCount: 0,
                    active: !0,
                    params: null,
                    execute: function(t) {
                        var e, i;
                        return this.active && this._listener && (i = this.params ? this.params.concat(t) : t, this._args && (i = i.concat(this._args)), e = this._listener.apply(this.context, i), this.callCount++, this._isOnce && this.detach()), e
                    },
                    detach: function() {
                        return this.isBound() ? this._signal.remove(this._listener, this.context) : null
                    },
                    isBound: function() {
                        return !!this._signal && !!this._listener
                    },
                    isOnce: function() {
                        return this._isOnce
                    },
                    getListener: function() {
                        return this._listener
                    },
                    getSignal: function() {
                        return this._signal
                    },
                    _destroy: function() {
                        delete this._signal, delete this._listener, delete this.context
                    },
                    toString: function() {
                        return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
                    }
                }, n.SignalBinding.prototype.constructor = n.SignalBinding, n.Filter = function(t, e, i) {
                    this.game = t, this.type = n.WEBGL_FILTER, this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.prevPoint = new n.Point;
                    var s = new Date;
                    if (this.uniforms = {
                            resolution: {
                                type: "2f",
                                value: {
                                    x: 256,
                                    y: 256
                                }
                            },
                            time: {
                                type: "1f",
                                value: 0
                            },
                            mouse: {
                                type: "2f",
                                value: {
                                    x: 0,
                                    y: 0
                                }
                            },
                            date: {
                                type: "4fv",
                                value: [s.getFullYear(), s.getMonth(), s.getDate(), 60 * s.getHours() * 60 + 60 * s.getMinutes() + s.getSeconds()]
                            },
                            sampleRate: {
                                type: "1f",
                                value: 44100
                            },
                            iChannel0: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            },
                            iChannel1: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            },
                            iChannel2: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            },
                            iChannel3: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            }
                        }, e)
                        for (var r in e) this.uniforms[r] = e[r];
                    "string" == typeof i && (i = i.split("\n")), this.fragmentSrc = i || []
                }, n.Filter.prototype = {
                    init: function() {},
                    setResolution: function(t, e) {
                        this.uniforms.resolution.value.x = t, this.uniforms.resolution.value.y = e
                    },
                    update: function(t) {
                        if (t) {
                            var e = t.x / this.game.width,
                                i = 1 - t.y / this.game.height;
                            e === this.prevPoint.x && i === this.prevPoint.y || (this.uniforms.mouse.value.x = e.toFixed(2), this.uniforms.mouse.value.y = i.toFixed(2), this.prevPoint.set(e, i))
                        }
                        this.uniforms.time.value = this.game.time.totalElapsedSeconds()
                    },
                    addToWorld: function(t, e, i, s, r, o) {
                        void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 !== i && null !== i ? this.width = i : i = this.width, void 0 !== s && null !== s ? this.height = s : s = this.height;
                        var a = this.game.add.image(t, e, n.Cache.DEFAULT);
                        return a.width = i, a.height = s, a.anchor.set(r, o), a.filters = [this], a
                    },
                    syncUniforms: function() {
                        for (var t = 0; t < this.shaders.length; t++) this.shaders[t].dirty = !0
                    },
                    destroy: function() {
                        this.passes.length = 0, this.shaders.length = 0, this.fragmentSrc.length = 0, this.game = null, this.uniforms = null, this.prevPoint = null
                    }
                }, n.Filter.prototype.constructor = n.Filter, Object.defineProperty(n.Filter.prototype, "width", {
                    get: function() {
                        return this.uniforms.resolution.value.x
                    },
                    set: function(t) {
                        this.uniforms.resolution.value.x = t
                    }
                }), Object.defineProperty(n.Filter.prototype, "height", {
                    get: function() {
                        return this.uniforms.resolution.value.y
                    },
                    set: function(t) {
                        this.uniforms.resolution.value.y = t
                    }
                }), n.Plugin = function(t, e) {
                    void 0 === e && (e = null), this.game = t, this.parent = e, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1
                }, n.Plugin.prototype = {
                    preUpdate: function() {},
                    update: function() {},
                    render: function() {},
                    postRender: function() {},
                    destroy: function() {
                        this.game = null, this.parent = null, this.active = !1, this.visible = !1
                    }
                }, n.Plugin.prototype.constructor = n.Plugin, n.PluginManager = function(t) {
                    this.game = t, this.plugins = [], this._len = 0, this._i = 0
                }, n.PluginManager.prototype = {
                    add: function(t) {
                        var e = Array.prototype.slice.call(arguments, 1),
                            i = !1;
                        return "function" == typeof t ? t = new t(this.game, this) : (t.game = this.game, t.parent = this), "function" == typeof t.preUpdate && (t.hasPreUpdate = !0, i = !0), "function" == typeof t.update && (t.hasUpdate = !0, i = !0), "function" == typeof t.postUpdate && (t.hasPostUpdate = !0, i = !0), "function" == typeof t.render && (t.hasRender = !0, i = !0), "function" == typeof t.postRender && (t.hasPostRender = !0, i = !0), i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0), (t.hasRender || t.hasPostRender) && (t.visible = !0), this._len = this.plugins.push(t), "function" == typeof t.init && t.init.apply(t, e), t) : null
                    },
                    remove: function(t, e) {
                        for (void 0 === e && (e = !0), this._i = this._len; this._i--;)
                            if (this.plugins[this._i] === t) return e && t.destroy(), this.plugins.splice(this._i, 1), void this._len--
                    },
                    removeAll: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
                        this.plugins.length = 0, this._len = 0
                    },
                    preUpdate: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
                    },
                    update: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
                    },
                    postUpdate: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
                    },
                    render: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
                    },
                    postRender: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
                    },
                    destroy: function() {
                        this.removeAll(), this.game = null
                    }
                }, n.PluginManager.prototype.constructor = n.PluginManager, n.Stage = function(t) {
                    this.game = t, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new n.Matrix, this.stage = this, this.currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0,
                        color: 0,
                        rgba: "#000000"
                    }, this.game.transparent || (this._bgColor.a = 1), t.config && this.parseConfig(t.config)
                }, n.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), n.Stage.prototype.constructor = n.Stage, n.Stage.prototype.parseConfig = function(t) {
                    t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange), t.backgroundColor && this.setBackgroundColor(t.backgroundColor)
                }, n.Stage.prototype.boot = function() {
                    n.DOM.getOffset(this.game.canvas, this.offset), n.Canvas.setUserSelect(this.game.canvas, "none"), n.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility()
                }, n.Stage.prototype.preUpdate = function() {
                    this.currentRenderOrderID = 0;
                    for (var t = 0; t < this.children.length;) {
                        var e = this.children[t];
                        e.preUpdate(), this === e.parent && t++
                    }
                }, n.Stage.prototype.update = function() {
                    for (var t = this.children.length; t--;) this.children[t].update()
                }, n.Stage.prototype.postUpdate = function() {
                    this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
                    for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate();
                    this.updateTransform()
                }, n.Stage.prototype.updateTransform = function() {
                    this.worldAlpha = 1;
                    for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
                }, n.Stage.prototype.checkVisibility = function() {
                    void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
                    var t = this;
                    this._onChange = function(e) {
                        return t.visibilityChange(e)
                    }, this._onChangePause = function() {
                        return t._onChange({
                            type: "pause"
                        })
                    }, this._onChangeResume = function() {
                        return t._onChange({
                            type: "resume"
                        })
                    }, this._onClick = function(e) {
                        void 0 === document.hasFocus || document.hasFocus() || t.visibilityChange(e)
                    }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, window.addEventListener("click", this._onClick), this.game.device.cocoonJSApp && CocoonJS.App && (CocoonJS.App.onSuspended && CocoonJS.App.onSuspended.addEventListener(this._onChangePause), CocoonJS.App.onActivated && CocoonJS.App.onActivated.addEventListener(this._onChangeResume), CocoonJS.App.on && (CocoonJS.App.on("activated", this._onChangeResume), CocoonJS.App.on("suspended", this._onChangePause)))
                }, n.Stage.prototype.visibilityChange = function(t) {
                    switch (t.type) {
                        case "blur":
                        case "pagehide":
                            return void this.game.focusLoss(t);
                        case "click":
                        case "focus":
                        case "pageshow":
                            return void this.game.focusGain(t)
                    }
                    this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === t.type ? this.game.gamePaused(t) : this.game.gameResumed(t))
                }, n.Stage.prototype.setBackgroundColor = function(t) {
                    this.game.transparent || (n.Color.valueToColor(t, this._bgColor), n.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1)
                }, n.Stage.prototype.destroy = function() {
                    this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null, window.removeEventListener("click", this._onClick)
                }, n.Stage.prototype.add = function(t, e, i) {
                    return t.parent === this ? t : (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? this.addChild(t) : this.addChildAt(t, i), t)
                }, Object.defineProperty(n.Stage.prototype, "backgroundColor", {
                    get: function() {
                        return this._bgColor.color
                    },
                    set: function(t) {
                        this.setBackgroundColor(t)
                    }
                }), Object.defineProperty(n.Stage.prototype, "smoothed", {
                    get: function() {
                        return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR
                    },
                    set: function(t) {
                        PIXI.scaleModes.DEFAULT = t ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST
                    }
                }), n.Group = function(t, e, i, s, r, o) {
                    void 0 === s && (s = !1), void 0 === r && (r = !1), void 0 === o && (o = n.Physics.ARCADE), this.game = t, void 0 === e && (e = t.world), this.name = i || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), s ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : e && (e.addChild(this), this.z = e.children.length), this.type = n.GROUP, this.physicsType = n.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = n.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.updateOnlyExistingChildren = !1, this.onChildInputDown = new n.Signal, this.onChildInputUp = new n.Signal, this.onChildInputOver = new n.Signal, this.onChildInputOut = new n.Signal, this.enableBody = r, this.enableBodyDebug = !1, this.physicsBodyType = o, this.physicsSortDirection = null, this.onDestroy = new n.Signal, this.cursorIndex = 0, this.fixedToCamera = !1, this.cameraOffset = new n.Point, this.hash = [], this._sortProperty = "z"
                }, n.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), n.Group.prototype.constructor = n.Group, n.Group.RETURN_NONE = 0, n.Group.RETURN_TOTAL = 1, n.Group.RETURN_CHILD = 2, n.Group.RETURN_ALL = 3, n.Group.SORT_ASCENDING = -1, n.Group.SORT_DESCENDING = 1, n.Group.prototype.add = function(t, e, i) {
                    return void 0 === e && (e = !1), t.parent === this ? t : (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? (t.z = this.children.length, this.addChild(t)) : (this.addChildAt(t, i), this.updateZ()), this.enableBody && t.hasOwnProperty("body") && null === t.body ? this.game.physics.enable(t, this.physicsBodyType) : t.body && this.addToHash(t), !this.inputEnableChildren || t.input && !t.inputEnabled || (t.inputEnabled = !0), !e && t.events && t.events.onAddedToGroup$dispatch(t, this), null === this.cursor && (this.cursor = t), t)
                }, n.Group.prototype.addAt = function(t, e, i) {
                    return this.add(t, i, e)
                }, n.Group.prototype.addToHash = function(t) {
                    if (t.parent === this && -1 === this.hash.indexOf(t)) return this.hash.push(t), !0;
                    return !1
                }, n.Group.prototype.removeFromHash = function(t) {
                    if (t) {
                        var e = this.hash.indexOf(t);
                        if (-1 !== e) return this.hash.splice(e, 1), !0
                    }
                    return !1
                }, n.Group.prototype.addMultiple = function(t, e) {
                    if (t instanceof n.Group) t.moveAll(this, e);
                    else if (Array.isArray(t))
                        for (var i = 0; i < t.length; i++) this.add(t[i], e);
                    return t
                }, n.Group.prototype.getAt = function(t) {
                    return t < 0 || t >= this.children.length ? -1 : this.getChildAt(t)
                }, n.Group.prototype.create = function(t, e, i, s, n, r) {
                    void 0 === n && (n = !0);
                    var o = new this.classType(this.game, t, e, i, s);
                    return o.exists = n, o.visible = n, o.alive = n, this.add(o, !1, r)
                }, n.Group.prototype.createMultiple = function(t, e, i, s, n, r) {
                    void 0 === i && (i = 0), void 0 === s && (s = !1), Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]);
                    var o = this,
                        a = [];
                    return e.forEach(function(e) {
                        i.forEach(function(i) {
                            for (var h = 0; h < t; h++) {
                                var l = o.create(0, 0, e, i, s);
                                n && n.call(r || l, l, h), a.push(l)
                            }
                        })
                    }), a
                }, n.Group.prototype.updateZ = function() {
                    for (var t = this.children.length; t--;) this.children[t].z = t
                }, n.Group.prototype.align = function(t, e, i, s, r, o) {
                    if (void 0 === r && (r = n.TOP_LEFT), void 0 === o && (o = 0), 0 === this.children.length || o > this.children.length || -1 === t && -1 === e) return !1;
                    for (var a = new n.Rectangle(0, 0, i, s), h = t * i, l = e * s, c = o; c < this.children.length; c++) {
                        var u = this.children[c];
                        if (u.alignIn)
                            if (u.alignIn(a, r), -1 === t) a.y += s, a.y === l && (a.x += i, a.y = 0);
                            else if (-1 === e) a.x += i, a.x === h && (a.x = 0, a.y += s);
                        else if (a.x += i, a.x === h && (a.x = 0, a.y += s, a.y === l)) return !0
                    }
                    return !0
                }, n.Group.prototype.resetCursor = function(t) {
                    if (void 0 === t && (t = 0), t > this.children.length - 1 && (t = 0), this.cursor) return this.cursorIndex = t, this.cursor = this.children[this.cursorIndex], this.cursor
                }, n.Group.prototype.next = function() {
                    if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor
                }, n.Group.prototype.previous = function() {
                    if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor
                }, n.Group.prototype.swap = function(t, e) {
                    this.swapChildren(t, e), this.updateZ()
                }, n.Group.prototype.bringToTop = function(t) {
                    return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0), this.add(t, !0)), t
                }, n.Group.prototype.bringChildToTop = n.Group.prototype.bringToTop, n.Group.prototype.sendToBack = function(t) {
                    return t.parent === this && this.getIndex(t) > 0 && (this.remove(t, !1, !0), this.addAt(t, 0, !0)), t
                }, n.Group.prototype.sendChildToBack = n.Group.prototype.sendToBack, n.Group.prototype.moveUp = function(t) {
                    if (t.parent === this && this.getIndex(t) < this.children.length - 1) {
                        var e = this.getIndex(t),
                            i = this.getAt(e + 1);
                        i && this.swap(t, i)
                    }
                    return t
                }, n.Group.prototype.moveDown = function(t) {
                    if (t.parent === this && this.getIndex(t) > 0) {
                        var e = this.getIndex(t),
                            i = this.getAt(e - 1);
                        i && this.swap(t, i)
                    }
                    return t
                }, n.Group.prototype.xy = function(t, e, i) {
                    if (t < 0 || t > this.children.length) return -1;
                    this.getChildAt(t).x = e, this.getChildAt(t).y = i
                }, n.Group.prototype.reverse = function() {
                    this.children.reverse(), this.updateZ()
                }, n.Group.prototype.getIndex = function(t) {
                    return this.children.indexOf(t)
                }, n.Group.prototype.getByName = function(t) {
                    return this.getFirst("name", t)
                }, n.Group.prototype.replace = function(t, e) {
                    var i = this.getIndex(t);
                    if (-1 !== i) return e.parent && (e.parent instanceof n.Group ? e.parent.remove(e) : e.parent.removeChild(e)), this.remove(t), this.addAt(e, i), t
                }, n.Group.prototype.hasProperty = function(t, e) {
                    var i = e.length;
                    return 1 === i && e[0] in t || (2 === i && e[0] in t && e[1] in t[e[0]] || (3 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] || 4 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] && e[3] in t[e[0]][e[1]][e[2]]))
                }, n.Group.prototype.setProperty = function(t, e, i, s, n) {
                    if (void 0 === n && (n = !1), s = s || 0, !this.hasProperty(t, e) && (!n || s > 0)) return !1;
                    var r = e.length;
                    return 1 === r ? 0 === s ? t[e[0]] = i : 1 === s ? t[e[0]] += i : 2 === s ? t[e[0]] -= i : 3 === s ? t[e[0]] *= i : 4 === s && (t[e[0]] /= i) : 2 === r ? 0 === s ? t[e[0]][e[1]] = i : 1 === s ? t[e[0]][e[1]] += i : 2 === s ? t[e[0]][e[1]] -= i : 3 === s ? t[e[0]][e[1]] *= i : 4 === s && (t[e[0]][e[1]] /= i) : 3 === r ? 0 === s ? t[e[0]][e[1]][e[2]] = i : 1 === s ? t[e[0]][e[1]][e[2]] += i : 2 === s ? t[e[0]][e[1]][e[2]] -= i : 3 === s ? t[e[0]][e[1]][e[2]] *= i : 4 === s && (t[e[0]][e[1]][e[2]] /= i) : 4 === r && (0 === s ? t[e[0]][e[1]][e[2]][e[3]] = i : 1 === s ? t[e[0]][e[1]][e[2]][e[3]] += i : 2 === s ? t[e[0]][e[1]][e[2]][e[3]] -= i : 3 === s ? t[e[0]][e[1]][e[2]][e[3]] *= i : 4 === s && (t[e[0]][e[1]][e[2]][e[3]] /= i)), !0
                }, n.Group.prototype.checkProperty = function(t, e, i, s) {
                    if (void 0 === s && (s = !1), this !== t.parent) return !1;
                    var r = n.Utils.getProperty(t, e);
                    return !(void 0 === r && s || r !== i)
                }, n.Group.prototype.set = function(t, e, i, s, n, r, o) {
                    if (void 0 === o && (o = !1), e = e.split("."), void 0 === s && (s = !1), void 0 === n && (n = !1), (!1 === s || s && t.alive) && (!1 === n || n && t.visible)) return this.setProperty(t, e, i, r, o)
                }, n.Group.prototype.setAll = function(t, e, i, s, n, r) {
                    void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === r && (r = !1), t = t.split("."), n = n || 0;
                    for (var o = this.children.length, a = 0; a < o; a++) {
                        var h = this.children[a];
                        i && !h.alive || s && !h.visible || this.setProperty(h, t, e, n, r)
                    }
                }, n.Group.prototype.setAllChildren = function(t, e, i, s, r, o) {
                    void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === o && (o = !1), r = r || 0;
                    for (var a = this.children.length, h = 0; h < a; h++) {
                        var l = this.children[h];
                        i && !l.alive || s && !l.visible || (l instanceof n.Group ? l.setAllChildren(t, e, i, s, r, o) : this.setProperty(l, t.split("."), e, r, o))
                    }
                }, n.Group.prototype.checkAll = function(t, e, i, s, n) {
                    void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === n && (n = !1);
                    for (var r = 0; r < this.children.length; r++) {
                        var o = this.children[r];
                        if ((!i || o.alive) && (!s || o.visible) && !this.checkProperty(o, t, e, n)) return !1
                    }
                    return !0
                }, n.Group.prototype.checkAny = function(t, e, i, s) {
                    void 0 === i && (i = !1), void 0 === s && (s = !1);
                    for (var n = 0; n < this.children.length; n++) {
                        var r = this.children[n];
                        if ((!i || r.alive) && (!s || r.visible) && this.checkProperty(r, t, e)) return !0
                    }
                    return !1
                }, n.Group.prototype.addAll = function(t, e, i, s) {
                    this.setAll(t, e, i, s, 1)
                }, n.Group.prototype.subAll = function(t, e, i, s) {
                    this.setAll(t, e, i, s, 2)
                }, n.Group.prototype.multiplyAll = function(t, e, i, s) {
                    this.setAll(t, e, i, s, 3)
                }, n.Group.prototype.divideAll = function(t, e, i, s) {
                    this.setAll(t, e, i, s, 4)
                }, n.Group.prototype.kill = function() {
                    this.alive = !1, this.exists = !1, this.visible = !1
                }, n.Group.prototype.killAll = function() {
                    this.callAllExists("kill", !0)
                }, n.Group.prototype.revive = function() {
                    this.alive = !0, this.exists = !0, this.visible = !0
                }, n.Group.prototype.reviveAll = function() {
                    this.callAllExists("revive", !1)
                }, n.Group.prototype.resetAll = function(t, e, i, s, n) {
                    this.forEach(this.resetChild, this, n, t, e, i, s)
                }, n.Group.prototype.callAllExists = function(t, e) {
                    var i;
                    if (arguments.length > 2) {
                        i = [];
                        for (var s = 2; s < arguments.length; s++) i.push(arguments[s])
                    }
                    for (s = 0; s < this.children.length; s++) {
                        var n = this.children[s];
                        n.exists === e && n[t] && n[t].apply(n, i)
                    }
                }, n.Group.prototype.callbackFromArray = function(t, e, i) {
                    if (1 === i) {
                        if (t[e[0]]) return t[e[0]]
                    } else if (2 === i) {
                        if (t[e[0]][e[1]]) return t[e[0]][e[1]]
                    } else if (3 === i) {
                        if (t[e[0]][e[1]][e[2]]) return t[e[0]][e[1]][e[2]]
                    } else if (4 === i) {
                        if (t[e[0]][e[1]][e[2]][e[3]]) return t[e[0]][e[1]][e[2]][e[3]]
                    } else if (t[e]) return t[e];
                    return !1
                }, n.Group.prototype.callAll = function(t, e) {
                    if (void 0 !== t) {
                        var i, s = (t = t.split(".")).length;
                        if (void 0 === e || null === e || "" === e) e = null;
                        else if ("string" == typeof e) var n = (e = e.split(".")).length;
                        if (arguments.length > 2) {
                            i = [];
                            for (var r = 2; r < arguments.length; r++) i.push(arguments[r])
                        }
                        var o = null,
                            a = null;
                        for (r = 0; r < this.children.length; r++) {
                            var h = this.children[r];
                            o = this.callbackFromArray(h, t, s), e && o ? (a = this.callbackFromArray(h, e, n), o.apply(a, i)) : o && o.apply(h, i)
                        }
                    }
                }, n.Group.prototype.preUpdate = function() {
                    if (this.pendingDestroy) return this.destroy(), !1;
                    if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
                    for (var t = 0; t < this.children.length;) {
                        var e = this.children[t];
                        e.preUpdate(), this === e.parent && t++
                    }
                    return !0
                }, n.Group.prototype.update = function() {
                    for (var t = this.children.length; t--;) {
                        var e = this.children.length;
                        t >= e && (t = e - 1);
                        var i = this.children[t];
                        this.updateOnlyExistingChildren && !i.exists || i.update()
                    }
                }, n.Group.prototype.postUpdate = function() {
                    this.fixedToCamera && (this.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
                    for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
                }, n.Group.prototype.filter = function(t, e) {
                    for (var i = -1, s = this.children.length, r = []; ++i < s;) {
                        var o = this.children[i];
                        (!e || e && o.exists) && t(o, i, this.children) && r.push(o)
                    }
                    return new n.ArraySet(r)
                }, n.Group.prototype.forEach = function(t, e, i) {
                    if (void 0 === i && (i = !1), arguments.length <= 3)
                        for (var s = 0; s < this.children.length; s++) {
                            var n = this.children[s];
                            i && !n.exists || t.call(e, n)
                        } else {
                            var r = [null];
                            for (s = 3; s < arguments.length; s++) r.push(arguments[s]);
                            for (s = 0; s < this.children.length; s++) {
                                n = this.children[s];
                                i && !n.exists || (r[0] = n, t.apply(e, r))
                            }
                        }
                }, n.Group.prototype.forEachExists = function(t, e) {
                    var i;
                    if (arguments.length > 2) {
                        i = [null];
                        for (var s = 2; s < arguments.length; s++) i.push(arguments[s])
                    }
                    this.iterate("exists", !0, n.Group.RETURN_TOTAL, t, e, i)
                }, n.Group.prototype.forEachAlive = function(t, e) {
                    var i;
                    if (arguments.length > 2) {
                        i = [null];
                        for (var s = 2; s < arguments.length; s++) i.push(arguments[s])
                    }
                    this.iterate("alive", !0, n.Group.RETURN_TOTAL, t, e, i)
                }, n.Group.prototype.forEachDead = function(t, e) {
                    var i;
                    if (arguments.length > 2) {
                        i = [null];
                        for (var s = 2; s < arguments.length; s++) i.push(arguments[s])
                    }
                    this.iterate("alive", !1, n.Group.RETURN_TOTAL, t, e, i)
                }, n.Group.prototype.sort = function(t, e) {
                    this.children.length < 2 || (void 0 === t && (t = "z"), void 0 === e && (e = n.Group.SORT_ASCENDING), this._sortProperty = t, e === n.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ())
                }, n.Group.prototype.customSort = function(t, e) {
                    this.children.length < 2 || (this.children.sort(t.bind(e)), this.updateZ())
                }, n.Group.prototype.ascendingSortHandler = function(t, e) {
                    return t[this._sortProperty] < e[this._sortProperty] ? -1 : t[this._sortProperty] > e[this._sortProperty] ? 1 : t.z < e.z ? -1 : 1
                }, n.Group.prototype.descendingSortHandler = function(t, e) {
                    return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0
                }, n.Group.prototype.iterate = function(t, e, i, s, r, o) {
                    if (0 === this.children.length) {
                        if (i === n.Group.RETURN_TOTAL) return 0;
                        if (i === n.Group.RETURN_ALL) return []
                    }
                    var a = 0;
                    if (i === n.Group.RETURN_ALL) var h = [];
                    for (var l = 0; l < this.children.length; l++)
                        if (this.children[l][t] === e) {
                            if (a++, s && (o ? (o[0] = this.children[l], s.apply(r, o)) : s.call(r, this.children[l])), i === n.Group.RETURN_CHILD) return this.children[l];
                            i === n.Group.RETURN_ALL && h.push(this.children[l])
                        } return i === n.Group.RETURN_TOTAL ? a : i === n.Group.RETURN_ALL ? h : null
                }, n.Group.prototype.getFirst = function(t, e) {
                    return this.iterate(t, e, n.Group.RETURN_CHILD)
                }, n.Group.prototype.getFirstExists = function(t, e, i, s, n, r) {
                    void 0 === e && (e = !1), "boolean" != typeof t && (t = !0);
                    var o = this.getFirst("exists", t);
                    return null === o && e ? this.create(i, s, n, r) : this.resetChild(o, i, s, n, r)
                }, n.Group.prototype.getFirstAlive = function(t, e, i, s, n) {
                    void 0 === t && (t = !1);
                    var r = this.getFirst("alive", !0);
                    return null === r && t ? this.create(e, i, s, n) : this.resetChild(r, e, i, s, n)
                }, n.Group.prototype.getFirstDead = function(t, e, i, s, n) {
                    void 0 === t && (t = !1);
                    var r = this.getFirst("alive", !1);
                    return null === r && t ? this.create(e, i, s, n) : this.resetChild(r, e, i, s, n)
                }, n.Group.prototype.resetChild = function(t, e, i, s, n) {
                    return null === t ? null : (void 0 === e && (e = null), void 0 === i && (i = null), null !== e && null !== i && t.reset(e, i), void 0 !== s && t.loadTexture(s, n), t)
                }, n.Group.prototype.getTop = function() {
                    if (this.children.length > 0) return this.children[this.children.length - 1]
                }, n.Group.prototype.getBottom = function() {
                    if (this.children.length > 0) return this.children[0]
                }, n.Group.prototype.getClosestTo = function(t, e, i) {
                    for (var s = Number.MAX_VALUE, r = 0, o = null, a = 0; a < this.children.length; a++) {
                        var h = this.children[a];
                        h.exists && (r = Math.abs(n.Point.distance(t, h))) < s && (!e || e.call(i, h, r)) && (s = r, o = h)
                    }
                    return o
                }, n.Group.prototype.getFurthestFrom = function(t, e, i) {
                    for (var s = 0, r = 0, o = null, a = 0; a < this.children.length; a++) {
                        var h = this.children[a];
                        h.exists && (r = Math.abs(n.Point.distance(t, h))) > s && (!e || e.call(i, h, r)) && (s = r, o = h)
                    }
                    return o
                }, n.Group.prototype.count = function(t, e) {
                    return this.iterate(t, e, n.Group.RETURN_TOTAL)
                }, n.Group.prototype.countLiving = function() {
                    return this.count("alive", !0)
                }, n.Group.prototype.countDead = function() {
                    return this.count("alive", !1)
                }, n.Group.prototype.getRandom = function(t, e) {
                    return void 0 === t && (t = 0), void 0 === e && (e = this.children.length), 0 === e ? null : n.ArrayUtils.getRandomItem(this.children, t, e)
                }, n.Group.prototype.getRandomExists = function(t, e) {
                    var i = this.getAll("exists", !0, t, e);
                    return this.game.rnd.pick(i)
                }, n.Group.prototype.getAll = function(t, e, i, s) {
                    void 0 === i && (i = 0), void 0 === s && (s = this.children.length);
                    for (var n = [], r = i; r < s; r++) {
                        var o = this.children[r];
                        t ? o[t] === e && n.push(o) : n.push(o)
                    }
                    return n
                }, n.Group.prototype.remove = function(t, e, i) {
                    if (void 0 === e && (e = !1), void 0 === i && (i = !1), 0 === this.children.length || -1 === this.children.indexOf(t)) return !1;
                    i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup$dispatch(t, this);
                    var s = this.removeChild(t);
                    return this.removeFromHash(t), this.updateZ(), this.cursor === t && this.next(), e && s && s.destroy(!0), !0
                }, n.Group.prototype.moveAll = function(t, e) {
                    if (void 0 === e && (e = !1), this.children.length > 0 && t instanceof n.Group) {
                        do {
                            t.add(this.children[0], e)
                        } while (this.children.length > 0);
                        this.hash = [], this.cursor = null
                    }
                    return t
                }, n.Group.prototype.removeAll = function(t, e, i) {
                    if (void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), 0 !== this.children.length) {
                        do {
                            !e && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                            var s = this.removeChild(this.children[0]);
                            this.removeFromHash(s), t && s && s.destroy(!0, i)
                        } while (this.children.length > 0);
                        this.hash = [], this.cursor = null
                    }
                }, n.Group.prototype.removeBetween = function(t, e, i, s) {
                    if (void 0 === e && (e = this.children.length - 1), void 0 === i && (i = !1), void 0 === s && (s = !1), 0 !== this.children.length) {
                        if (t > e || t < 0 || e > this.children.length) return !1;
                        for (var n = e; n >= t;) {
                            !s && this.children[n].events && this.children[n].events.onRemovedFromGroup$dispatch(this.children[n], this);
                            var r = this.removeChild(this.children[n]);
                            this.removeFromHash(r), i && r && r.destroy(!0), this.cursor === this.children[n] && (this.cursor = null), n--
                        }
                        this.updateZ()
                    }
                }, n.Group.prototype.scatter = function(t, e) {
                    null == t && (t = this.game.world.bounds), this.forEach(function(e) {
                        e.position.set(t.randomX, t.randomY)
                    }, null, e)
                }, n.Group.prototype.shuffle = function() {
                    n.ArrayUtils.shuffle(this.children), this.updateZ()
                }, n.Group.prototype.destroy = function(t, e) {
                    null === this.game || this.ignoreDestroy || (void 0 === t && (t = !0), void 0 === e && (e = !1), this.onDestroy.dispatch(this, t, e), this.removeAll(t), this.cursor = null, this.filters = null, this.pendingDestroy = !1, e || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
                }, Object.defineProperty(n.Group.prototype, "total", {
                    get: function() {
                        return this.iterate("exists", !0, n.Group.RETURN_TOTAL)
                    }
                }), Object.defineProperty(n.Group.prototype, "length", {
                    get: function() {
                        return this.children.length
                    }
                }), Object.defineProperty(n.Group.prototype, "angle", {
                    get: function() {
                        return n.Math.radToDeg(this.rotation)
                    },
                    set: function(t) {
                        this.rotation = n.Math.degToRad(t)
                    }
                }), Object.defineProperty(n.Group.prototype, "centerX", {
                    get: function() {
                        return this.getBounds(this.parent).centerX
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.x - e.x;
                        this.x = t + i - e.halfWidth
                    }
                }), Object.defineProperty(n.Group.prototype, "centerY", {
                    get: function() {
                        return this.getBounds(this.parent).centerY
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.y - e.y;
                        this.y = t + i - e.halfHeight
                    }
                }), Object.defineProperty(n.Group.prototype, "left", {
                    get: function() {
                        return this.getBounds(this.parent).left
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.x - e.x;
                        this.x = t + i
                    }
                }), Object.defineProperty(n.Group.prototype, "right", {
                    get: function() {
                        return this.getBounds(this.parent).right
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.x - e.x;
                        this.x = t + i - e.width
                    }
                }), Object.defineProperty(n.Group.prototype, "top", {
                    get: function() {
                        return this.getBounds(this.parent).top
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.y - e.y;
                        this.y = t + i
                    }
                }), Object.defineProperty(n.Group.prototype, "bottom", {
                    get: function() {
                        return this.getBounds(this.parent).bottom
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.y - e.y;
                        this.y = t + i - e.height
                    }
                }), n.World = function(t) {
                    n.Group.call(this, t, null, "__world", !1), this.bounds = new n.Rectangle(0, 0, t.width, t.height), this.camera = null, this._definedSize = !1, this._width = t.width, this._height = t.height, this.game.state.onStateChange.add(this.stateChange, this)
                }, n.World.prototype = Object.create(n.Group.prototype), n.World.prototype.constructor = n.World, n.World.prototype.boot = function() {
                    this.camera = new n.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot()
                }, n.World.prototype.stateChange = function() {
                    this.x = 0, this.y = 0, this.camera.reset()
                }, n.World.prototype.setBounds = function(t, e, i, s) {
                    this._definedSize = !0, this._width = i, this._height = s, this.bounds.setTo(t, e, i, s), this.x = t, this.y = e, this.camera.bounds && this.camera.bounds.setTo(t, e, Math.max(i, this.game.width), Math.max(s, this.game.height)), this.game.physics.setBoundsToWorld()
                }, n.World.prototype.resize = function(t, e) {
                    this._definedSize && (t < this._width && (t = this._width), e < this._height && (e = this._height)), this.bounds.width = t, this.bounds.height = e, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld()
                }, n.World.prototype.shutdown = function() {
                    this.destroy(!0, !0)
                }, n.World.prototype.wrap = function(t, e, i, s, n) {
                    void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === s && (s = !0), void 0 === n && (n = !0), i ? (t.getBounds(), s && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right : t.x > this.bounds.right && (t.x = this.bounds.left)), n && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom : t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (s && t.x + e < this.bounds.x ? t.x = this.bounds.right + e : s && t.x - e > this.bounds.right && (t.x = this.bounds.left - e), n && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e : n && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e))
                }, n.World.prototype.wrapAll = function(t, e, i, s, n, r) {
                    t.forEach(this.wrap, this, e, i, s, n, r)
                }, Object.defineProperty(n.World.prototype, "width", {
                    get: function() {
                        return this.bounds.width
                    },
                    set: function(t) {
                        t < this.game.width && (t = this.game.width), this.bounds.width = t, this._width = t, this._definedSize = !0
                    }
                }), Object.defineProperty(n.World.prototype, "height", {
                    get: function() {
                        return this.bounds.height
                    },
                    set: function(t) {
                        t < this.game.height && (t = this.game.height), this.bounds.height = t, this._height = t, this._definedSize = !0
                    }
                }), Object.defineProperty(n.World.prototype, "centerX", {
                    get: function() {
                        return this.bounds.halfWidth + this.bounds.x
                    }
                }), Object.defineProperty(n.World.prototype, "centerY", {
                    get: function() {
                        return this.bounds.halfHeight + this.bounds.y
                    }
                }), Object.defineProperty(n.World.prototype, "randomX", {
                    get: function() {
                        return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width)
                    }
                }), Object.defineProperty(n.World.prototype, "randomY", {
                    get: function() {
                        return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height)
                    }
                }), n.Game = function(t, e, i, s, r, o, a, h) {
                    return this.id = n.GAMES.push(this) - 1, this.config = null, this.physicsConfig = h, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.multiTexture = !1, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = n.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = n.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.pendingDestroy = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this.rendersThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new n.Signal, this.forceSingleUpdate = !0, this.forceSingleRender = !0, this.dropFrames = !1, this.powerPreference = "default", this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {
                        enableDebug: !0
                    }, void 0 !== t && (this._width = t), void 0 !== e && (this._height = e), void 0 !== i && (this.renderType = i), void 0 !== s && (this.parent = s), void 0 !== o && (this.transparent = o), void 0 !== a && (this.antialias = a), this.rnd = new n.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new n.StateManager(this, r)), this.device.whenReady(this.boot, this), this
                }, n.Game.prototype = {
                    parseConfig: function(t) {
                        this.config = t, void 0 === t.enableDebug && (this.config.enableDebug = !0), t.width && (this._width = t.width), t.height && (this._height = t.height), t.renderer && (this.renderType = t.renderer), t.parent && (this.parent = t.parent), void 0 !== t.transparent && (this.transparent = t.transparent), void 0 !== t.antialias && (this.antialias = t.antialias), void 0 !== t.clearBeforeRender && (this.clearBeforeRender = t.clearBeforeRender), void 0 !== t.multiTexture && (this.multiTexture = t.multiTexture), t.resolution && (this.resolution = t.resolution), void 0 !== t.preserveDrawingBuffer && (this.preserveDrawingBuffer = t.preserveDrawingBuffer), void 0 !== t.powerPreference && (this.powerPreference = t.powerPreference), t.physicsConfig && (this.physicsConfig = t.physicsConfig);
                        var e = [(Date.now() * Math.random()).toString()];
                        t.seed && (e = t.seed), this.rnd = new n.RandomDataGenerator(e);
                        var i = null;
                        t.state && (i = t.state), this.state = new n.StateManager(this, i)
                    },
                    boot: function() {
                        if (!this.isBooted) {
                            if (this.onPause = new n.Signal, this.onResume = new n.Signal, this.onBlur = new n.Signal, this.onFocus = new n.Signal, this.isBooted = !0, PIXI.game = this, this.math = n.Math, this.scale = new n.ScaleManager(this, this._width, this._height), this.stage = new n.Stage(this), this.setUpRenderer(), this.world = new n.World(this), this.add = new n.GameObjectFactory(this), this.make = new n.GameObjectCreator(this), this.cache = new n.Cache(this), this.load = new n.Loader(this), this.time = new n.Time(this), this.tweens = new n.TweenManager(this), this.input = new n.Input(this), this.sound = new n.SoundManager(this), this.physics = new n.Physics(this, this.physicsConfig), this.particles = new n.Particles(this), this.create = new n.Create(this), this.plugins = new n.PluginManager(this), this.net = new n.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(this.config), this.sound.boot(), this.state.boot(), this.config.enableDebug) this.debug = new n.Utils.Debug(this), this.debug.boot();
                            else {
                                var t = function() {};
                                this.debug = {
                                    preUpdate: t,
                                    update: t,
                                    reset: t,
                                    destroy: t,
                                    isDisabled: !0
                                }
                            }
                            this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new n.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new n.RequestAnimationFrame(this, !1), this._kickstart = !0, this.focusWindow(), this.config.disableStart || (this.cache.isReady ? this.raf.start() : this.cache.onReady.addOnce(function() {
                                this.raf.start()
                            }, this))
                        }
                    },
                    showDebugHeader: function() {
                        if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                            var t = n.VERSION,
                                e = "Canvas",
                                i = "HTML Audio",
                                s = 1;
                            if (this.renderType === n.WEBGL ? (e = "WebGL", s++) : this.renderType === n.HEADLESS && (e = "Headless"), this.device.webAudio && (i = "WebAudio", s++), this.device.ie) window.console && console.log("Phaser v" + t + " | Pixi.js | " + e + " | " + i + " | http://phaser.io");
                            else {
                                for (var r = ["%c %c %c Phaser CE v" + t + " | Pixi.js | " + e + " | " + i + "  %c %c %c http://phaser.io %c%c%c", "background: #fb8cb3", "background: #d44a52", "color: #ffffff; background: #871905;", "background: #d44a52", "background: #fb8cb3", "background: #ffffff"], o = 0; o < 3; o++) o < s ? r.push("color: #ff2424; background: #fff") : r.push("color: #959595; background: #fff");
                                console.log.apply(console, r)
                            }
                        }
                    },
                    setUpRenderer: function() {
                        if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas 2d context, aborting.");
                        if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = n.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.config.crisp && n.Canvas.setImageRenderingCrisp(this.canvas), this.renderType === n.WEBGL || this.renderType === n.WEBGL_MULTI || this.renderType === n.AUTO && this.device.webGL) {
                            (this.multiTexture || this.renderType === n.WEBGL_MULTI) && (PIXI.enableMultiTexture(), this.multiTexture = !0);
                            try {
                                this.renderer = new PIXI.WebGLRenderer(this, this.config), this.renderType = n.WEBGL, this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1)
                            } catch (t) {
                                if (PIXI.defaultRenderer = null, this.renderer = null, this.multiTexture = !1, PIXI._enableMultiTextureToggle = !1, this.renderType === n.WEBGL) throw t
                            }
                        }
                        this.renderer || (this.renderer = new PIXI.CanvasRenderer(this, this.config), this.context = this.renderer.context, this.renderType === n.AUTO && (this.renderType = n.CANVAS)), this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === n.CANVAS), this.renderType !== n.HEADLESS && (this.stage.smoothed = this.antialias, n.Canvas.addToDOM(this.canvas, this.parent, !1), n.Canvas.setTouchAction(this.canvas))
                    },
                    contextLost: function(t) {
                        t.preventDefault(), this.renderer.contextLost = !0
                    },
                    contextRestored: function() {
                        this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1
                    },
                    update: function(t) {
                        if (this.pendingDestroy) this.destroy();
                        else {
                            if (this.time.update(t), this._kickstart) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void(this._kickstart = !1);
                            if (this._spiraling > 1 && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.dropFrames ? this.rendersThisFrame = 0 : (this.updateRender(this.time.slowMotion * this.time.desiredFps), this.rendersThisFrame = 1);
                            else {
                                var e = 1e3 * this.time.slowMotion / this.time.desiredFps;
                                this._deltaTime += Math.max(Math.min(3 * e, this.time.elapsed), 0);
                                var i = 0;
                                for (this.updatesThisFrame = Math.floor(this._deltaTime / e), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)), this.forceSingleRender ? this.rendersThisFrame = 1 : this.rendersThisFrame = Math.min(1, this.updatesThisFrame); this._deltaTime >= e && (this._deltaTime -= e, this.currentUpdateID = i, this.updateLogic(this.time.desiredFpsMult), i++, !this.forceSingleUpdate || 1 !== i);) this.time.refresh();
                                i > this._lastCount ? this._spiraling++ : i < this._lastCount && (this._spiraling = 0), this._lastCount = i, this.rendersThisFrame > 0 && this.updateRender(this._deltaTime / e)
                            }
                            this.renderer.type === n.WEBGL && this.renderer.gl.flush()
                        }
                    },
                    updateLogic: function(t) {
                        this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(t), this.debug.preUpdate(), this.input.pauseUpdate()) : (this.stepping && (this.pendingStep = !0), this.time.countUpdate(), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(t), this.plugins.preUpdate(t), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.plugins.update(), this.stage.postUpdate(), this.state.postUpdate(), this.plugins.postUpdate()), this.stage.updateTransform()
                    },
                    updateRender: function(t) {
                        this.lockRender || this.renderType === n.HEADLESS || (this.time.countRender(), this.state.preRender(t), this.renderer.render(this.stage), this.plugins.render(t), this.state.render(t), this.plugins.postRender(t))
                    },
                    enableStep: function() {
                        this.stepping = !0, this.pendingStep = !1, this.stepCount = 0
                    },
                    disableStep: function() {
                        this.stepping = !1, this.pendingStep = !1
                    },
                    step: function() {
                        this.pendingStep = !1, this.stepCount++
                    },
                    destroy: function() {
                        this.raf.stop(), this.debug.destroy(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.tweens.destroy(), this.debug = null, this.state = null, this.sound = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.tweens = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), n.Canvas.removeFromDOM(this.canvas), PIXI.game === this && (PIXI.game = null), PIXI.defaultRenderer = null, n.GAMES[this.id] = null
                    },
                    gamePaused: function(t) {
                        this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !0))
                    },
                    gameResumed: function(t) {
                        this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !1))
                    },
                    focusLoss: function(t) {
                        this.onBlur.dispatch(t), this.stage.disableVisibilityChange || this.gamePaused(t)
                    },
                    focusGain: function(t) {
                        this.focusWindow(), this.onFocus.dispatch(t), this.stage.disableVisibilityChange || this.gameResumed(t)
                    },
                    focusWindow: function() {
                        window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus()
                    }
                }, n.Game.prototype.constructor = n.Game, Object.defineProperty(n.Game.prototype, "paused", {
                    get: function() {
                        return this._paused
                    },
                    set: function(t) {
                        !0 === t ? (!1 === this._paused && (this._paused = !0, this.sound.muteOnPause && this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), this._codePaused = !1)
                    }
                }), n.Input = function(t) {
                    this.game = t, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = n.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.touchLockCallbacks = [], this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new n.ArraySet, this._localPoint = new n.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0
                }, n.Input.MOUSE_OVERRIDES_TOUCH = 0, n.Input.TOUCH_OVERRIDES_MOUSE = 1, n.Input.MOUSE_TOUCH_COMBINE = 2, n.Input.MAX_POINTERS = 10, n.Input.prototype = {
                    boot: function(t) {
                        "maxPointers" in t && (this.maxPointers = t.maxPointers), this.mousePointer = new n.Pointer(this.game, 0, n.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new n.Mouse(this.game), this.touch = new n.Touch(this.game), this.mspointer = new n.MSPointer(this.game), this.mouseWheel = new n.MouseWheel(this.game), this.pointerLock = new n.PointerLock(this.game), n.Keyboard && (this.keyboard = new n.Keyboard(this.game)), n.Gamepad && (this.gamepad = new n.Gamepad(this.game)), this.onDown = new n.Signal, this.onUp = new n.Signal, this.onTap = new n.Signal, this.onHold = new n.Signal, this.scale = new n.Point(1, 1), this.speed = new n.Point, this.position = new n.Point, this._oldPosition = new n.Point, this.circle = new n.Circle(0, 0, 45), this.activePointer = this.mousePointer, this.hitCanvas = n.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.game.device.mspointer && !1 !== t.mspointer ? this.mspointer.start() : this.game.device.touch && !1 !== t.touch && this.touch.start(), this.mspointer.active || !1 === t.mouse || this.mouse.start(), this.mousePointer.active = !0, !1 !== t.mouseWheel && this.mouseWheel.start(), !1 !== t.pointerLock && this.pointerLock.start(), this.keyboard && !1 !== t.keyboard && this.keyboard.start();
                        var e = this;
                        this._onClickTrampoline = function(t) {
                            e.onClickTrampoline(t)
                        }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
                    },
                    destroy: function() {
                        this.mouse.stop(), this.mouseWheel.stop(), this.touch.stop(), this.mspointer.stop(), this.pointerLock.stop(), this.keyboard && this.keyboard.stop(), this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], n.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline)
                    },
                    setInteractiveCandidateHandler: function(t, e) {
                        this.customCandidateHandler = t, this.customCandidateHandlerContext = e
                    },
                    addMoveCallback: function(t, e) {
                        this.moveCallbacks.push({
                            callback: t,
                            context: e
                        })
                    },
                    addTouchLockCallback: function(t, e, i) {
                        void 0 === i && (i = !1), this.touchLockCallbacks.push({
                            callback: t,
                            context: e,
                            onEnd: i
                        })
                    },
                    removeTouchLockCallback: function(t, e) {
                        for (var i = this.touchLockCallbacks.length; i--;)
                            if (this.touchLockCallbacks[i].callback === t && this.touchLockCallbacks[i].context === e) return this.touchLockCallbacks.splice(i, 1), !0;
                        return !1
                    },
                    executeTouchLockCallbacks: function(t, e) {
                        for (var i = this.touchLockCallbacks.length; i--;) {
                            var s = this.touchLockCallbacks[i];
                            s.onEnd === t && s.callback.call(s.context, this, e) && this.touchLockCallbacks.splice(i, 1)
                        }
                    },
                    deleteMoveCallback: function(t, e) {
                        for (var i = this.moveCallbacks.length; i--;)
                            if (this.moveCallbacks[i].callback === t && this.moveCallbacks[i].context === e) return void this.moveCallbacks.splice(i, 1)
                    },
                    addPointer: function() {
                        if (this.pointers.length >= n.Input.MAX_POINTERS) return console.warn("Phaser.Input.addPointer: Maximum limit of " + n.Input.MAX_POINTERS + " pointers reached."), null;
                        var t = this.pointers.length + 1,
                            e = new n.Pointer(this.game, t, n.PointerMode.CONTACT);
                        return this.pointers.push(e), this["pointer" + t] = e, e
                    },
                    update: function() {
                        if (this.keyboard && this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate) this._pollCounter++;
                        else {
                            this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update();
                            for (var t = 0; t < this.pointers.length; t++) this.pointers[t].update();
                            this._pollCounter = 0
                        }
                    },
                    pauseUpdate: function() {
                        this.gamepad && this.gamepad.active && this.gamepad.update()
                    },
                    reset: function(t) {
                        if (this.game.isBooted && !this.resetLocked) {
                            void 0 === t && (t = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(t);
                            for (var e = 0; e < this.pointers.length; e++) this.pointers[e].reset();
                            "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = ""), t && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new n.Signal, this.onUp = new n.Signal, this.onTap = new n.Signal, this.onHold = new n.Signal, this.moveCallbacks = []), this._pollCounter = 0
                        }
                    },
                    resetSpeed: function(t, e) {
                        this._oldPosition.setTo(t, e), this.speed.setTo(0, 0)
                    },
                    startPointer: function(t) {
                        if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
                        if (!this.pointer1.active) return this.pointer1.start(t);
                        if (!this.pointer2.active) return this.pointer2.start(t);
                        for (var e = 2; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (!i.active) return i.start(t)
                        }
                        return null
                    },
                    updatePointer: function(t) {
                        if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.move(t);
                        if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.move(t);
                        for (var e = 2; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.active && i.identifier === t.identifier) return i.move(t)
                        }
                        return null
                    },
                    stopPointer: function(t) {
                        if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.stop(t);
                        if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.stop(t);
                        for (var e = 2; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.active && i.identifier === t.identifier) return i.stop(t)
                        }
                        return null
                    },
                    countActivePointers: function(t) {
                        void 0 === t && (t = this.pointers.length);
                        for (var e = t, i = 0; i < this.pointers.length && e > 0; i++) {
                            this.pointers[i].active && e--
                        }
                        return t - e
                    },
                    getPointer: function(t) {
                        void 0 === t && (t = !1);
                        for (var e = 0; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.active === t) return i
                        }
                        return null
                    },
                    getPointerFromIdentifier: function(t) {
                        for (var e = 0; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.identifier === t) return i
                        }
                        return null
                    },
                    getPointerFromId: function(t) {
                        for (var e = 0; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.pointerId === t) return i
                        }
                        return null
                    },
                    getLocalPosition: function(t, e, i) {
                        void 0 === i && (i = new n.Point);
                        var s = t.worldTransform,
                            r = 1 / (s.a * s.d + s.c * -s.b);
                        return i.setTo(s.d * r * e.x + -s.c * r * e.y + (s.ty * s.c - s.tx * s.d) * r, s.a * r * e.y + -s.b * r * e.x + (-s.ty * s.a + s.tx * s.b) * r)
                    },
                    hitTest: function(t, e, i) {
                        if (!t.worldVisible) return !1;
                        if (this.getLocalPosition(t, e, this._localPoint), i.copyFrom(this._localPoint), t.hitArea && t.hitArea.contains) return t.hitArea.contains(this._localPoint.x, this._localPoint.y);
                        if (n.Creature && t instanceof n.Creature) {
                            var s = Math.abs(t.width),
                                r = Math.abs(t.height),
                                o = t.x - s * t.anchorX;
                            if (this.game.camera.x + e.x >= o && this.game.camera.x + e.x < o + s) {
                                var a = t.y - r * t.anchorY;
                                if (this.game.camera.y + e.y >= a && this.game.camera.y + e.y < a + r) return !0
                            }
                        } else if (t instanceof n.TileSprite) {
                            s = t.width, r = t.height, o = -s * t.anchor.x;
                            if (this._localPoint.x >= o && this._localPoint.x < o + s) {
                                a = -r * t.anchor.y;
                                if (this._localPoint.y >= a && this._localPoint.y < a + r) return !0
                            }
                        } else if (t instanceof PIXI.Sprite) {
                            s = t.texture.frame.width / t.texture.baseTexture.resolution, r = t.texture.frame.height / t.texture.baseTexture.resolution, o = -s * t.anchor.x;
                            if (this._localPoint.x >= o && this._localPoint.x < o + s) {
                                a = -r * t.anchor.y;
                                if (this._localPoint.y >= a && this._localPoint.y < a + r) return !0
                            }
                        } else if (t instanceof n.Graphics)
                            for (var h = 0; h < t.graphicsData.length; h++) {
                                var l = t.graphicsData[h];
                                if (l.fill && (l.shape && l.shape.contains(this._localPoint.x, this._localPoint.y))) return !0
                            }
                        for (h = 0; h < t.children.length; h++)
                            if (this.hitTest(t.children[h], e, i)) return !0;
                        return !1
                    },
                    onClickTrampoline: function() {
                        this.activePointer.processClickTrampolines()
                    },
                    callAll: function(t, e) {
                        for (var i = this.interactiveItems.list, s = i.length; s--;) {
                            var n = i[s];
                            n && n.enabled && n[t](e)
                        }
                    }
                }, n.Input.prototype.constructor = n.Input, Object.defineProperty(n.Input.prototype, "x", {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = Math.floor(t)
                    }
                }), Object.defineProperty(n.Input.prototype, "y", {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = Math.floor(t)
                    }
                }), Object.defineProperty(n.Input.prototype, "pollLocked", {
                    get: function() {
                        return this.pollRate > 0 && this._pollCounter < this.pollRate
                    }
                }), Object.defineProperty(n.Input.prototype, "totalInactivePointers", {
                    get: function() {
                        return this.pointers.length - this.countActivePointers()
                    }
                }), Object.defineProperty(n.Input.prototype, "totalActivePointers", {
                    get: function() {
                        return this.countActivePointers()
                    }
                }), Object.defineProperty(n.Input.prototype, "worldX", {
                    get: function() {
                        return this.game.camera.view.x + this.x
                    }
                }), Object.defineProperty(n.Input.prototype, "worldY", {
                    get: function() {
                        return this.game.camera.view.y + this.y
                    }
                }), n.Mouse = function(t) {
                    this.game = t, this.input = t.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.capture = !1, this.active = !1, this.enabled = !0, this.stopOnGameOut = !1, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null
                }, n.Mouse.NO_BUTTON = -1, n.Mouse.LEFT_BUTTON = 0, n.Mouse.MIDDLE_BUTTON = 1, n.Mouse.RIGHT_BUTTON = 2, n.Mouse.BACK_BUTTON = 3, n.Mouse.FORWARD_BUTTON = 4, n.Mouse.prototype = {
                    start: function() {
                        var t = this.game.device;
                        if (t.isAndroidStockBrowser() && this.input.touch.active) return !1;
                        if (null !== this._onMouseDown) return !1;
                        var e = this;
                        this._onMouseDown = function(t) {
                            return e.onMouseDown(t)
                        }, this._onMouseMove = function(t) {
                            return e.onMouseMove(t)
                        }, this._onMouseUp = function(t) {
                            return e.onMouseUp(t)
                        }, this._onMouseUpGlobal = function(t) {
                            return e.onMouseUpGlobal(t)
                        }, this._onMouseOutGlobal = function(t) {
                            return e.onMouseOutGlobal(t)
                        }, this._onMouseOut = function(t) {
                            return e.onMouseOut(t)
                        }, this._onMouseOver = function(t) {
                            return e.onMouseOver(t)
                        };
                        var i = this.game.canvas;
                        return i.addEventListener("mousedown", this._onMouseDown, !0), i.addEventListener("mousemove", this._onMouseMove, !0), i.addEventListener("mouseup", this._onMouseUp, !0), t.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), i.addEventListener("mouseover", this._onMouseOver, !0), i.addEventListener("mouseout", this._onMouseOut, !0)), this.active = !0, !0
                    },
                    onMouseDown: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.start(t))
                    },
                    onMouseMove: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.move(t))
                    },
                    onMouseUp: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.stop(t))
                    },
                    onMouseUpGlobal: function(t) {
                        this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), t.identifier = 0, this.input.mousePointer.stop(t))
                    },
                    onMouseOutGlobal: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(t), this.input.mousePointer.resetButtons())
                    },
                    onMouseOut: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (this.input.mousePointer.updateButtons(t), this.stopOnGameOut && (t.identifier = 0, this.input.mousePointer.stop(t), this.input.callAll("_pointerOutHandler", this.input.mousePointer)))
                    },
                    onMouseOver: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && this.input.mousePointer.updateButtons(t)
                    },
                    stop: function() {
                        var t = this.game.canvas;
                        t.removeEventListener("mousedown", this._onMouseDown, !0), t.removeEventListener("mousemove", this._onMouseMove, !0), t.removeEventListener("mouseup", this._onMouseUp, !0), t.removeEventListener("mouseover", this._onMouseOver, !0), t.removeEventListener("mouseout", this._onMouseOut, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), this.active = !1
                    }
                }, n.Mouse.prototype.constructor = n.Mouse, n.MouseWheel = function(t) {
                    this.game = t, this.input = t.input, this.element = t.canvas, this.preventDefault = !0, this.active = !1, this.callback = null, this.callbackContext = t, this.delta = 0, this.wheelEventName = t.device.wheelEvent, this.boundOnWheelHandler = this.onWheelHandler.bind(this), this.eventProxy = null
                }, n.MouseWheel.UP = 1, n.MouseWheel.DOWN = -1, n.MouseWheel.prototype.start = function() {
                    return !(!this.wheelEventName || this.active) && (this.element.addEventListener(this.wheelEventName, this.boundOnWheelHandler, !0), "mousewheel" === this.wheelEventName ? this.eventProxy = new n.WheelEventProxy(-.025, 1) : "DOMMouseScroll" === this.wheelEventName && (this.eventProxy = new n.WheelEventProxy(1, 1)), this.active = !0, !0)
                }, n.MouseWheel.prototype.stop = function() {
                    this.active && (this.element.removeEventListener(this.wheelEventName, this.boundOnWheelHandler, !0), this.active = !1)
                }, n.MouseWheel.prototype.onWheelHandler = function(t) {
                    this.eventProxy && (t = this.eventProxy.bindEvent(t)), this.preventDefault && t.preventDefault(), this.delta = n.Math.clamp(-t.deltaY, -1, 1), this.callback && this.callback.call(this.callbackContext, t)
                }, n.MSPointer = function(t) {
                    this.game = t, this.input = t.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.pointerOutCallback = null, this.pointerOverCallback = null, this.capture = !1, this.event = null, this.active = !1, this.enabled = !0, this.stopOnGameOut = !1, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null
                }, n.MSPointer.prototype = {
                    start: function() {
                        if (!this.game.device.mspointer) return !1;
                        if (null !== this._onMSPointerDown) return !1;
                        var t = this;
                        this._onMSPointerDown = function(e) {
                            return t.onPointerDown(e)
                        }, this._onMSPointerMove = function(e) {
                            return t.onPointerMove(e)
                        }, this._onMSPointerUp = function(e) {
                            return t.onPointerUp(e)
                        }, this._onMSPointerUpGlobal = function(e) {
                            return t.onPointerUpGlobal(e)
                        }, this._onMSPointerOut = function(e) {
                            return t.onPointerOut(e)
                        }, this._onMSPointerOver = function(e) {
                            return t.onPointerOver(e)
                        };
                        var e = this.game.canvas;
                        return e.addEventListener("MSPointerDown", this._onMSPointerDown, !1), e.addEventListener("MSPointerMove", this._onMSPointerMove, !1), e.addEventListener("MSPointerUp", this._onMSPointerUp, !1), e.addEventListener("pointerdown", this._onMSPointerDown, !1), e.addEventListener("pointermove", this._onMSPointerMove, !1), e.addEventListener("pointerup", this._onMSPointerUp, !1), e.style["-ms-content-zooming"] = "none", e.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), e.addEventListener("MSPointerOver", this._onMSPointerOver, !0), e.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), e.addEventListener("pointerover", this._onMSPointerOver, !0), e.addEventListener("pointerout", this._onMSPointerOut, !0)), this.active = !0, !0
                    },
                    onPointerDown: function(t) {
                        this.game.input.executeTouchLockCallbacks(!1, t), this.event = t, this.capture && t.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.start(t) : this.input.startPointer(t))
                    },
                    onPointerMove: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.move(t) : this.input.updatePointer(t))
                    },
                    onPointerUp: function(t) {
                        this.game.input.executeTouchLockCallbacks(!0, t), this.event = t, this.capture && t.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.stop(t) : this.input.stopPointer(t))
                    },
                    onPointerUpGlobal: function(t) {
                        if (t.identifier = t.pointerId, "mouse" !== t.pointerType && 4 !== t.pointerType || this.input.mousePointer.withinGame) {
                            var e = this.input.getPointerFromIdentifier(t.identifier);
                            e && e.withinGame && this.onPointerUp(t)
                        } else this.onPointerUp(t)
                    },
                    onPointerOut: function(t) {
                        if (this.event = t, this.capture && t.preventDefault(), t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !1;
                        else {
                            var e = this.input.getPointerFromIdentifier(t.identifier);
                            e && (e.withinGame = !1)
                        }
                        this.pointerOutCallback && this.pointerOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && this.stopOnGameOut && (t.identifier = 0, e || (e = this.input.mousePointer), e.stop(t), this.input.callAll("_pointerOutHandler", e))
                    },
                    onPointerOver: function(t) {
                        if (this.event = t, this.capture && t.preventDefault(), t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !0;
                        else {
                            var e = this.input.getPointerFromIdentifier(t.identifier);
                            e && (e.withinGame = !0)
                        }
                        this.pointerOverCallback && this.pointerOverCallback.call(this.callbackContext, t)
                    },
                    stop: function() {
                        var t = this.game.canvas;
                        t.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), t.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), t.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), t.removeEventListener("pointerdown", this._onMSPointerDown, !1), t.removeEventListener("pointermove", this._onMSPointerMove, !1), t.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), t.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.removeEventListener("pointerover", this._onMSPointerOver, !0), t.removeEventListener("pointerout", this._onMSPointerOut, !0), this.active = !1
                    }
                }, n.MSPointer.prototype.constructor = n.MSPointer, n.DeviceButton = function(t, e) {
                    this.parent = t, this.game = t.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = e, this.onDown = new n.Signal, this.onUp = new n.Signal, this.onFloat = new n.Signal
                }, n.DeviceButton.prototype = {
                    start: function(t, e) {
                        this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onDown.dispatch(this, e))
                    },
                    stop: function(t, e) {
                        this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onUp.dispatch(this, e))
                    },
                    startStop: function(t, e, i) {
                        t ? this.start(e, i) : this.stop(e, i)
                    },
                    padFloat: function(t) {
                        this.isDown = !1, this.isUp = !1, this.value = t, this.onFloat.dispatch(this, t)
                    },
                    justPressed: function(t) {
                        return t = t || 250, this.isDown && this.timeDown + t > this.game.time.time
                    },
                    justReleased: function(t) {
                        return t = t || 250, this.isUp && this.timeUp + t > this.game.time.time
                    },
                    reset: function() {
                        this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1
                    },
                    destroy: function() {
                        this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null
                    }
                }, n.DeviceButton.prototype.constructor = n.DeviceButton, Object.defineProperty(n.DeviceButton.prototype, "duration", {
                    get: function() {
                        return this.isUp ? -1 : this.game.time.time - this.timeDown
                    }
                }), n.Pointer = function(t, e, i) {
                    this.game = t, this.id = e, this.type = n.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = i || n.PointerMode.CURSOR | n.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new n.DeviceButton(this, n.Pointer.LEFT_BUTTON), this.middleButton = new n.DeviceButton(this, n.Pointer.MIDDLE_BUTTON), this.rightButton = new n.DeviceButton(this, n.Pointer.RIGHT_BUTTON), this.backButton = new n.DeviceButton(this, n.Pointer.BACK_BUTTON), this.forwardButton = new n.DeviceButton(this, n.Pointer.FORWARD_BUTTON), this.eraserButton = new n.DeviceButton(this, n.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === e, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new n.Point, this.positionDown = new n.Point, this.positionUp = new n.Point, this.circle = new n.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null
                }, n.Pointer.NO_BUTTON = 0, n.Pointer.LEFT_BUTTON = 1, n.Pointer.RIGHT_BUTTON = 2, n.Pointer.MIDDLE_BUTTON = 4, n.Pointer.BACK_BUTTON = 8, n.Pointer.FORWARD_BUTTON = 16, n.Pointer.ERASER_BUTTON = 32, n.Pointer.prototype = {
                    resetButtons: function() {
                        this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset())
                    },
                    processButtonsDown: function(t, e) {
                        switch (t) {
                            case n.Mouse.LEFT_BUTTON:
                                this.leftButton.start(e);
                                break;
                            case n.Mouse.RIGHT_BUTTON:
                                this.rightButton.start(e);
                                break;
                            case n.Mouse.MIDDLE_BUTTON:
                                this.middleButton.start(e);
                                break;
                            case n.Mouse.BACK_BUTTON:
                                this.backButton.start(e);
                                break;
                            case n.Mouse.FORWARD_BUTTON:
                                this.forwardButton.start(e)
                        }
                    },
                    processButtonsUp: function(t, e) {
                        switch (t) {
                            case n.Mouse.LEFT_BUTTON:
                                this.leftButton.stop(e);
                                break;
                            case n.Mouse.RIGHT_BUTTON:
                                this.rightButton.stop(e);
                                break;
                            case n.Mouse.MIDDLE_BUTTON:
                                this.middleButton.stop(e);
                                break;
                            case n.Mouse.BACK_BUTTON:
                                this.backButton.stop(e);
                                break;
                            case n.Mouse.FORWARD_BUTTON:
                                this.forwardButton.stop(e)
                        }
                    },
                    processButtonsUpDown: function(t, e) {
                        var i = e.type.toLowerCase().substr(-4),
                            s = "down" === i,
                            r = "move" === i;
                        void 0 !== t ? (s && 1 === t && e.ctrlKey && (t = 2), this.leftButton.startStop(n.Pointer.LEFT_BUTTON & t, e), this.rightButton.startStop(n.Pointer.RIGHT_BUTTON & t, e), this.middleButton.startStop(n.Pointer.MIDDLE_BUTTON & t, e), this.backButton.startStop(n.Pointer.BACK_BUTTON & t, e), this.forwardButton.startStop(n.Pointer.FORWARD_BUTTON & t, e), this.eraserButton.startStop(n.Pointer.ERASER_BUTTON & t, e)) : void 0 !== e.button ? s && e.ctrlKey && 0 === e.button ? this.rightButton.start(e) : s ? this.processButtonsDown(e.button, e) : r || this.processButtonsUp(e.button, e) : s ? e.ctrlKey ? this.rightButton.start(e) : this.leftButton.start(e) : (this.leftButton.stop(e), this.rightButton.stop(e))
                    },
                    updateButtons: function(t) {
                        this.button = t.button, this.processButtonsUpDown(t.buttons, t), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0)
                    },
                    start: function(t) {
                        var e = this.game.input;
                        return t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.isMouse ? this.updateButtons(t) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(t, !0), this.positionDown.setTo(this.x, this.y), (e.multiInputOverride === n.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === n.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === n.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.x = this.x, e.y = this.y, e.position.setTo(this.x, this.y), e.onDown.dispatch(this, t), e.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this
                    },
                    update: function() {
                        var t = this.game.input;
                        this.active && (this.dirty && (t.interactiveItems.total > 0 && this.processInteractiveObjects(!1), this.dirty = !1), !1 === this._holdSent && this.duration >= t.holdRate && ((t.multiInputOverride === n.Input.MOUSE_OVERRIDES_TOUCH || t.multiInputOverride === n.Input.MOUSE_TOUCH_COMBINE || t.multiInputOverride === n.Input.TOUCH_OVERRIDES_MOUSE && 0 === t.totalActivePointers) && t.onHold.dispatch(this), this._holdSent = !0), t.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + t.recordRate, this._history.push({
                            x: this.position.x,
                            y: this.position.y
                        }), this._history.length > t.recordLimit && this._history.shift()))
                    },
                    move: function(t, e) {
                        var i = this.game.input;
                        if (!i.pollLocked) {
                            void 0 === e && (e = !1), void 0 !== t.button && (this.button = t.button), this.isMouse && this.updateButtons(t), this.clientX = t.clientX, this.clientY = t.clientY, this.pageX = t.pageX, this.pageY = t.pageY, this.screenX = t.screenX, this.screenY = t.screenY, this.isMouse && i.pointerLock.locked && !e && (this.rawMovementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.rawMovementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * i.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * i.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (i.multiInputOverride === n.Input.MOUSE_OVERRIDES_TOUCH || i.multiInputOverride === n.Input.MOUSE_TOUCH_COMBINE || i.multiInputOverride === n.Input.TOUCH_OVERRIDES_MOUSE && 0 === i.totalActivePointers) && (i.activePointer = this, i.x = this.x, i.y = this.y, i.position.setTo(i.x, i.y), i.circle.x = i.x, i.circle.y = i.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY);
                            for (var s = i.moveCallbacks.length; s--;) i.moveCallbacks[s].callback.call(i.moveCallbacks[s].context, this, this.x, this.y, e, t);
                            return null === this.targetObject || this.game.paused && !this.targetObject.noPause || !0 !== this.targetObject.isDragged ? i.interactiveItems.total > 0 && this.processInteractiveObjects(e) : !1 === this.targetObject.update(this) && (this.targetObject = null), this
                        }
                    },
                    processInteractiveObjects: function(t) {
                        var e = 0,
                            i = -1,
                            s = null,
                            n = this.game.input.interactiveItems.first;
                        for (this.interactiveCandidates = []; n;) n.checked = !1, !n.validForInput(i, e, !1) || this.game.paused && !n.sprite.noPause || (n.checked = !0, (t && n.checkPointerDown(this, !0) || !t && n.checkPointerOver(this, !0)) && (e = n.sprite.renderOrderID, i = n.priorityID, s = n, this.interactiveCandidates.push(n))), n = this.game.input.interactiveItems.next;
                        for (n = this.game.input.interactiveItems.first; n;) !n.checked && n.validForInput(i, e, !0) && (t && n.checkPointerDown(this, !1) || !t && n.checkPointerOver(this, !1)) && (e = n.sprite.renderOrderID, i = n.priorityID, s = n, this.interactiveCandidates.push(n)), n = this.game.input.interactiveItems.next;
                        return this.game.input.customCandidateHandler && (s = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, s)), this.swapTarget(s, !1), null !== this.targetObject
                    },
                    swapTarget: function(t, e) {
                        void 0 === e && (e = !1), null === t ? this.targetObject && (this.targetObject._pointerOutHandler(this, e), this.targetObject = null) : null === this.targetObject ? (this.targetObject = t, t._pointerOverHandler(this, e)) : this.targetObject === t ? !1 === t.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, e), this.targetObject = t, this.targetObject._pointerOverHandler(this, e))
                    },
                    leave: function(t) {
                        this.withinGame = !1, this.move(t, !1)
                    },
                    stop: function(t) {
                        var e = this.game.input;
                        if (!this._stateReset || !this.withinGame) {
                            if (this.timeUp = this.game.time.time, (e.multiInputOverride === n.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === n.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === n.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.onUp.dispatch(this, t), this.duration >= 0 && this.duration <= e.tapRate)) {
                                var i = this.timeUp - this.previousTapTime < e.doubleTapRate;
                                e.onTap.dispatch(this, i, t), this.previousTapTime = this.timeUp
                            }
                            return this.isMouse ? this.updateButtons(t) : (this.isDown = !1, this.isUp = !0), this.id > 0 && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(t.pageX, t.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), !1 === this.isMouse && e.currentPointers--, e.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this
                        }
                        t.preventDefault()
                    },
                    justPressed: function(t) {
                        return t = t || this.game.input.justPressedRate, !0 === this.isDown && this.timeDown + t > this.game.time.time
                    },
                    justReleased: function(t) {
                        return t = t || this.game.input.justReleasedRate, this.isUp && this.timeUp + t > this.game.time.time
                    },
                    addClickTrampoline: function(t, e, i, s) {
                        if (this.isDown) {
                            for (var n = this._clickTrampolines = this._clickTrampolines || [], r = 0; r < n.length; r++)
                                if (n[r].name === t) {
                                    n.splice(r, 1);
                                    break
                                } n.push({
                                name: t,
                                targetObject: this.targetObject,
                                callback: e,
                                callbackContext: i,
                                callbackArgs: s
                            })
                        }
                    },
                    processClickTrampolines: function() {
                        var t = this._clickTrampolines;
                        if (t) {
                            for (var e = 0; e < t.length; e++) {
                                var i = t[e];
                                i.targetObject === this._trampolineTargetObject && i.callback.apply(i.callbackContext, i.callbackArgs)
                            }
                            this._clickTrampolines = null, this._trampolineTargetObject = null
                        }
                    },
                    reset: function() {
                        !1 === this.isMouse && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null
                    },
                    resetMovement: function() {
                        this.movementX = 0, this.movementY = 0
                    }
                }, n.Pointer.prototype.constructor = n.Pointer, Object.defineProperty(n.Pointer.prototype, "duration", {
                    get: function() {
                        return this.isUp ? -1 : this.game.time.time - this.timeDown
                    }
                }), Object.defineProperty(n.Pointer.prototype, "worldX", {
                    get: function() {
                        return this.game.world.camera.x + this.x
                    }
                }), Object.defineProperty(n.Pointer.prototype, "worldY", {
                    get: function() {
                        return this.game.world.camera.y + this.y
                    }
                }), n.PointerMode = {
                    CURSOR: 1,
                    CONTACT: 2
                }, n.PointerModes = {}, n.PointerModes[n.PointerMode.CURSOR] = "CURSOR", n.PointerModes[n.PointerMode.CONTACT] = "CONTACT", n.Touch = function(t) {
                    this.game = t, this.active = !1, this.enabled = !0, this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null
                }, n.Touch.prototype = {
                    start: function() {
                        if (!this.game.device.touch) return !1;
                        if (null !== this._onTouchStart) return !1;
                        var t = this;
                        return this._onTouchStart = function(e) {
                            return t.onTouchStart(e)
                        }, this._onTouchMove = function(e) {
                            return t.onTouchMove(e)
                        }, this._onTouchEnd = function(e) {
                            return t.onTouchEnd(e)
                        }, this._onTouchEnter = function(e) {
                            return t.onTouchEnter(e)
                        }, this._onTouchLeave = function(e) {
                            return t.onTouchLeave(e)
                        }, this._onTouchCancel = function(e) {
                            return t.onTouchCancel(e)
                        }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)), this.active = !0, !0
                    },
                    consumeDocumentTouches: function() {
                        this._documentTouchMove = function(t) {
                            t.preventDefault()
                        }, document.addEventListener("touchmove", this._documentTouchMove, !1)
                    },
                    onTouchStart: function(t) {
                        if (this.game.input.executeTouchLockCallbacks(!1, t), this.event = t, this.game.input.enabled && this.enabled) {
                            this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                            for (var e = 0; e < t.changedTouches.length; e++) this.game.input.startPointer(t.changedTouches[e])
                        }
                    },
                    onTouchCancel: function(t) {
                        if (this.event = t, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled) {
                            this.preventDefault && t.preventDefault();
                            for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                        }
                    },
                    onTouchEnter: function(t) {
                        this.event = t, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled && this.preventDefault && t.preventDefault()
                    },
                    onTouchLeave: function(t) {
                        this.event = t, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault()
                    },
                    onTouchMove: function(t) {
                        this.event = t, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                        for (var e = 0; e < t.changedTouches.length; e++) this.game.input.updatePointer(t.changedTouches[e])
                    },
                    onTouchEnd: function(t) {
                        this.game.input.executeTouchLockCallbacks(!0, t), this.event = t, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                        for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                    },
                    stop: function() {
                        this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel), this.active = !1)
                    }
                }, n.Touch.prototype.constructor = n.Touch, n.InputHandler = function(t) {
                    this.sprite = t, this.game = t.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new n.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new n.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new n.Point, this.snapPoint = new n.Point, this._dragPoint = new n.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new n.Point, this._pointerData = [], this._pointerData.push({
                        id: 0,
                        x: 0,
                        y: 0,
                        camX: 0,
                        camY: 0,
                        isDown: !1,
                        isUp: !1,
                        isOver: !1,
                        isOut: !1,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: !1
                    })
                }, n.InputHandler.prototype = {
                    start: function(t, e) {
                        if (t = t || 0, void 0 === e && (e = !1), !1 === this.enabled) {
                            this.game.input.interactiveItems.add(this), this.useHandCursor = e, this.priorityID = t;
                            for (var i = 0; i < 10; i++) this._pointerData[i] = {
                                id: i,
                                x: 0,
                                y: 0,
                                isDown: !1,
                                isUp: !1,
                                isOver: !1,
                                isOut: !1,
                                timeOver: 0,
                                timeOut: 0,
                                timeDown: 0,
                                timeUp: 0,
                                downDuration: 0,
                                isDragged: !1
                            };
                            this.snapOffset = new n.Point, this.enabled = !0, this._wasEnabled = !0
                        }
                        return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite
                    },
                    addedToGroup: function() {
                        this._dragPhase || this._wasEnabled && !this.enabled && this.start()
                    },
                    removedFromGroup: function() {
                        this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1)
                    },
                    reset: function() {
                        this.enabled = !1;
                        for (var t = 0; t < 10; t++) this._pointerData[t] = {
                            id: t,
                            x: 0,
                            y: 0,
                            isDown: !1,
                            isUp: !1,
                            isOver: !1,
                            isOut: !1,
                            timeOver: 0,
                            timeOut: 0,
                            timeDown: 0,
                            timeUp: 0,
                            downDuration: 0,
                            isDragged: !1
                        }
                    },
                    stop: function() {
                        !1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
                    },
                    destroy: function() {
                        this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null)
                    },
                    validForInput: function(t, e, i) {
                        return void 0 === i && (i = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput) && (!(!i && (this.pixelPerfectClick || this.pixelPerfectOver)) && (this.priorityID > t || this.priorityID === t && this.sprite.renderOrderID > e))
                    },
                    isPixelPerfect: function() {
                        return this.pixelPerfectClick || this.pixelPerfectOver
                    },
                    pointerX: function(t) {
                        return t = t || 0, this._pointerData[t].x
                    },
                    pointerY: function(t) {
                        return t = t || 0, this._pointerData[t].y
                    },
                    pointerDown: function(t) {
                        return t = t || 0, this._pointerData[t].isDown
                    },
                    pointerUp: function(t) {
                        return t = t || 0, this._pointerData[t].isUp
                    },
                    pointerTimeDown: function(t) {
                        return t = t || 0, this._pointerData[t].timeDown
                    },
                    pointerTimeUp: function(t) {
                        return t = t || 0, this._pointerData[t].timeUp
                    },
                    pointerOver: function(t) {
                        if (!this.enabled) return !1;
                        if (void 0 === t) {
                            for (var e = 0; e < 10; e++)
                                if (this._pointerData[e].isOver) return !0;
                            return !1
                        }
                        return this._pointerData[t].isOver
                    },
                    pointerOut: function(t) {
                        if (!this.enabled) return !1;
                        if (void 0 !== t) return this._pointerData[t].isOut;
                        for (var e = 0; e < 10; e++)
                            if (this._pointerData[e].isOut) return !0
                    },
                    pointerTimeOver: function(t) {
                        return t = t || 0, this._pointerData[t].timeOver
                    },
                    pointerTimeOut: function(t) {
                        return t = t || 0, this._pointerData[t].timeOut
                    },
                    pointerDragged: function(t) {
                        return t = t || 0, this._pointerData[t].isDragged
                    },
                    checkPointerDown: function(t, e) {
                        return !!(t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
                    },
                    checkPointerOver: function(t, e) {
                        return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
                    },
                    checkPixel: function(t, e, i) {
                        if (this.sprite.texture.baseTexture.source) {
                            if (null === t && null === e) {
                                this.game.input.getLocalPosition(this.sprite, i, this._tempPoint);
                                t = this._tempPoint.x, e = this._tempPoint.y
                            }
                            if (0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y), t += this.sprite.texture.frame.x, e += this.sprite.texture.frame.y, this.sprite.texture.trim && (t -= this.sprite.texture.trim.x, e -= this.sprite.texture.trim.y, t < this.sprite.texture.crop.x || t > this.sprite.texture.crop.right || e < this.sprite.texture.crop.y || e > this.sprite.texture.crop.bottom)) return this._dx = t, this._dy = e, !1;
                            if (this._dx = t, this._dy = e, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1), this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) return !0
                        }
                        return !1
                    },
                    update: function(t) {
                        if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = n.Math.distance(t.x, t.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(t), !0) : this.draggable && this._draggedPointerID === t.id ? this.updateDrag(t, !1) : this._pointerData[t.id].isOver ? this.checkPointerOver(t) ? (this._pointerData[t.id].x = t.x - this.sprite.x, this._pointerData[t.id].y = t.y - this.sprite.y, !0) : (this._pointerOutHandler(t), !1) : void 0 : (this._pointerOutHandler(t), !1)
                    },
                    _pointerOverHandler: function(t, e) {
                        if (null !== this.sprite) {
                            var i = this._pointerData[t.id];
                            if (!1 === i.isOver || t.dirty) {
                                var s = !1 === i.isOver;
                                i.isOver = !0, i.isOut = !1, i.timeOver = this.game.time.time, i.x = t.x - this.sprite.x, i.y = t.y - this.sprite.y, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !e && s && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, t), this.sprite.parent && this.sprite.parent.onChildInputOver && this.sprite.parent.onChildInputOver.dispatch(this.sprite, t)
                            }
                        }
                    },
                    _pointerOutHandler: function(t, e) {
                        if (null !== this.sprite) {
                            var i = this._pointerData[t.id];
                            i.isOver = !1, i.isOut = !0, i.timeOut = this.game.time.time, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "", this._setHandCursor = !1), !e && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.onChildInputOut && this.sprite.parent.onChildInputOut.dispatch(this.sprite, t))
                        }
                    },
                    _touchedHandler: function(t) {
                        if (null !== this.sprite) {
                            var e = this._pointerData[t.id];
                            if (!e.isDown && e.isOver) {
                                if (this.pixelPerfectClick && !this.checkPixel(null, null, t)) return;
                                if (e.isDown = !0, e.isUp = !1, e.timeDown = this.game.time.time, this.downPoint.set(t.x, t.y), t.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.onChildInputDown && this.sprite.parent.onChildInputDown.dispatch(this.sprite, t), null === this.sprite)) return;
                                this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(t) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, this.dragTimeThreshold > 0 ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, t)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop()
                            }
                        }
                    },
                    dragTimeElapsed: function(t) {
                        this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(t)
                    },
                    _releasedHandler: function(t) {
                        if (null !== this.sprite) {
                            var e = this._pointerData[t.id];
                            if (e.isDown && t.isUp) {
                                e.isDown = !1, e.isUp = !0, e.timeUp = this.game.time.time, e.downDuration = e.timeUp - e.timeDown;
                                var i = this.checkPointerOver(t);
                                this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === t.id) || this.sprite.events.onInputUp$dispatch(this.sprite, t, i), this.sprite && this.sprite.parent && this.sprite.parent.onChildInputUp && this.sprite.parent.onChildInputUp.dispatch(this.sprite, t, i), i && (i = this.checkPointerOver(t))), e.isOver = i, !i && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), t.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t)
                            }
                        }
                    },
                    updateDrag: function(t, e) {
                        var i = this.game.camera,
                            s = this.dragOffset,
                            n = this._dragPoint,
                            r = this._pointerData[t.id],
                            o = this.snapPoint,
                            a = this.sprite;
                        if (void 0 === e && (e = !1), t.isUp) return this.stopDrag(t), !1;
                        var h = this.globalToLocal(t);
                        if (a.fixedToCamera) var l = i.scale.x * h.x + n.x + s.x,
                            c = i.scale.y * h.y + n.y + s.y;
                        else l = h.x + n.x + s.x, c = h.y + n.y + s.y;
                        if (a.fixedToCamera) {
                            var u = a.cameraOffset,
                                d = u.x,
                                p = u.y;
                            this.allowHorizontalDrag && (u.x = l - i.x), this.allowVerticalDrag && (u.y = c - i.y), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (u.x = Math.round((u.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, u.y = Math.round((u.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, o.set(u.x, u.y));
                            var f = u.x - d,
                                g = u.y - p
                        } else {
                            var m = i.x - r.camX,
                                y = i.y - r.camY;
                            d = a.x, p = a.y;
                            this.allowHorizontalDrag && (a.x = l + m), this.allowVerticalDrag && (a.y = c + y), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (a.x = Math.round((a.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, a.y = Math.round((a.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, o.set(a.x, a.y));
                            f = a.x - d, g = a.y - p
                        }
                        return this.sprite.events.onDragUpdate.dispatch(a, t, l, c, o, e, f, g), !0
                    },
                    justOver: function(t, e) {
                        return t = t || 0, e = e || 500, this._pointerData[t].isOver && this.overDuration(t) < e
                    },
                    justOut: function(t, e) {
                        return t = t || 0, e = e || 500, this._pointerData[t].isOut && this.game.time.time - this._pointerData[t].timeOut < e
                    },
                    justPressed: function(t, e) {
                        return t = t || 0, e = e || 500, this._pointerData[t].isDown && this.downDuration(t) < e
                    },
                    justReleased: function(t, e) {
                        return t = t || 0, e = e || 500, this._pointerData[t].isUp && this.game.time.time - this._pointerData[t].timeUp < e
                    },
                    overDuration: function(t) {
                        return t = t || 0, this._pointerData[t].isOver ? this.game.time.time - this._pointerData[t].timeOver : -1
                    },
                    downDuration: function(t) {
                        return t = t || 0, this._pointerData[t].isDown ? this.game.time.time - this._pointerData[t].timeDown : -1
                    },
                    enableDrag: function(t, e, i, s, r, o) {
                        void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === s && (s = 255), void 0 === r && (r = null), void 0 === o && (o = null), this._dragPoint = new n.Point, this.draggable = !0, this.bringToTop = e, this.dragOffset = new n.Point, this.dragFromCenter = t, this.pixelPerfectClick = i, this.pixelPerfectAlpha = s, r && (this.boundsRect = r), o && (this.boundsSprite = o)
                    },
                    disableDrag: function() {
                        if (this._pointerData)
                            for (var t = 0; t < 10; t++) this._pointerData[t].isDragged = !1;
                        this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1
                    },
                    startDrag: function(t) {
                        var e = this.sprite.x,
                            i = this.sprite.y,
                            s = this.globalToLocal(t);
                        if (this.isDragged = !0, this._draggedPointerID = t.id, this._pointerData[t.id].camX = this.game.camera.x, this._pointerData[t.id].camY = this.game.camera.y, this._pointerData[t.id].isDragged = !0, this.sprite.fixedToCamera) {
                            if (this.dragFromCenter) {
                                var r = this.sprite.getBounds(),
                                    o = this.globalToLocal(new n.Point(r.centerX, r.centerY));
                                this.sprite.cameraOffset.x = s.x + (this.sprite.cameraOffset.x - o.x), this.sprite.cameraOffset.y = s.y + (this.sprite.cameraOffset.y - o.y)
                            }
                            this._dragPoint.setTo(this.sprite.cameraOffset.x - t.x, this.sprite.cameraOffset.y - t.y)
                        } else {
                            if (this.dragFromCenter) {
                                r = this.sprite.getBounds(), o = this.globalToLocal(new n.Point(r.centerX, r.centerY));
                                this.sprite.x = s.x + (this.sprite.x - o.x), this.sprite.y = s.y + (this.sprite.y - o.y)
                            }
                            this._dragPoint.setTo(this.sprite.x - s.x, this.sprite.y - s.y)
                        }
                        this.updateDrag(t, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(e, i), this.sprite.events.onDragStart$dispatch(this.sprite, t, e, i), this._pendingDrag = !1
                    },
                    globalToLocalX: function(t) {
                        return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.x, t *= this.game.scale.grid.scaleFluidInversed.x), t
                    },
                    globalToLocalY: function(t) {
                        return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.y, t *= this.game.scale.grid.scaleFluidInversed.y), t
                    },
                    globalToLocal: function(t) {
                        return this.sprite.parent ? this.game.input.getLocalPosition(this.sprite.parent, {
                            x: t.x,
                            y: t.y
                        }) : t
                    },
                    stopDrag: function(t) {
                        this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[t.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop$dispatch(this.sprite, t), !1 === this.checkPointerOver(t) && this._pointerOutHandler(t)
                    },
                    setDragLock: function(t, e) {
                        void 0 === t && (t = !0), void 0 === e && (e = !0), this.allowHorizontalDrag = t, this.allowVerticalDrag = e
                    },
                    enableSnap: function(t, e, i, s, n, r) {
                        void 0 === i && (i = !0), void 0 === s && (s = !1), void 0 === n && (n = 0), void 0 === r && (r = 0), this.snapX = t, this.snapY = e, this.snapOffsetX = n, this.snapOffsetY = r, this.snapOnDrag = i, this.snapOnRelease = s
                    },
                    disableSnap: function() {
                        this.snapOnDrag = !1, this.snapOnRelease = !1
                    },
                    checkBoundsRect: function() {
                        this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)))
                    },
                    checkBoundsSprite: function() {
                        this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)))
                    }
                }, n.InputHandler.prototype.constructor = n.InputHandler, n.PointerLock = function(t) {
                    this.game = t, this.input = t.input, this.element = t.canvas, this.active = !1, this.locked = !1, this.onChange = new n.Signal, this.onError = new n.Signal, this.boundOnChangeHandler = this.onChangeHandler.bind(this), this.boundOnErrorHandler = this.onErrorHandler.bind(this);
                    var e = t.device;
                    this.pointerLockElement = e.pointerLockElement, this.pointerlockchange = e.pointerlockchange, this.pointerlockerror = e.pointerlockerror
                }, n.PointerLock.prototype.start = function() {
                    return !(!this.game.device.pointerLock || this.active) && (this.element.requestPointerLock || (this.element.requestPointerLock = this.element.mozRequestPointerLock || this.element.webkitRequestPointerLock), document.exitPointerLock || (document.exitPointerLock = document.mozExitPointerLock || document.webkitExitPointerLock), document.addEventListener(this.pointerlockchange, this.boundOnChangeHandler, !0), document.addEventListener(this.pointerlockerror, this.boundOnErrorHandler, !0), this.active = !0, !0)
                }, n.PointerLock.prototype.stop = function() {
                    this.active && (document.removeEventListener(this.pointerlockchange, this.boundOnChangeHandler, !0), document.removeEventListener(this.pointerlockerror, this.boundOnErrorHandler, !0), this.active = !1)
                }, n.PointerLock.prototype.request = function() {
                    this.active && !this.locked && this.element.requestPointerLock()
                }, n.PointerLock.prototype.exit = function() {
                    document.exitPointerLock()
                }, n.PointerLock.prototype.onChangeHandler = function(t) {
                    this.locked = document[this.pointerLockElement] === this.element, this.onChange.dispatch(this.locked, t)
                }, n.PointerLock.prototype.onErrorHandler = function(t) {
                    this.onError.dispatch(t)
                }, n.Gamepad = function(t) {
                    this.game = t, this._gamepadIndexMap = {}, this._rawPads = [], this._active = !1, this.enabled = !0, this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 !== navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads, this._prevRawGamepadTypes = [], this._prevTimestamps = [], this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this._ongamepadconnected = null, this._gamepaddisconnected = null, this._gamepads = [new n.SinglePad(t, this), new n.SinglePad(t, this), new n.SinglePad(t, this), new n.SinglePad(t, this)]
                }, n.Gamepad.prototype = {
                    addCallbacks: function(t, e) {
                        void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t)
                    },
                    start: function() {
                        if (!this._active) {
                            this._active = !0;
                            var t = this;
                            this._onGamepadConnected = function(e) {
                                return t.onGamepadConnected(e)
                            }, this._onGamepadDisconnected = function(e) {
                                return t.onGamepadDisconnected(e)
                            }, window.addEventListener("gamepadconnected", this._onGamepadConnected, !1), window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1)
                        }
                    },
                    onGamepadConnected: function(t) {
                        var e = t.gamepad;
                        this._rawPads.push(e), this._gamepads[e.index].connect(e)
                    },
                    onGamepadDisconnected: function(t) {
                        var e = t.gamepad;
                        for (var i in this._rawPads) this._rawPads[i].index === e.index && this._rawPads.splice(i, 1);
                        this._gamepads[e.index].disconnect()
                    },
                    update: function() {
                        this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), this.pad4.pollStatus()
                    },
                    _pollGamepads: function() {
                        if (this._active) {
                            if (navigator.getGamepads) var t = navigator.getGamepads();
                            else if (navigator.webkitGetGamepads) t = navigator.webkitGetGamepads();
                            else if (navigator.webkitGamepads) t = navigator.webkitGamepads();
                            if (t) {
                                this._rawPads = [];
                                for (var e = !1, i = 0; i < t.length && (typeof t[i] !== this._prevRawGamepadTypes[i] && (e = !0, this._prevRawGamepadTypes[i] = typeof t[i]), t[i] && this._rawPads.push(t[i]), 3 !== i); i++);
                                for (var s = 0; s < this._gamepads.length; s++) this._gamepads[s]._rawPad = this._rawPads[s];
                                if (e) {
                                    for (var n, r = {
                                            rawIndices: {},
                                            padIndices: {}
                                        }, o = 0; o < this._gamepads.length; o++)
                                        if ((n = this._gamepads[o]).connected)
                                            for (var a = 0; a < this._rawPads.length; a++) this._rawPads[a].index === n.index && (r.rawIndices[n.index] = !0, r.padIndices[o] = !0);
                                    for (var h = 0; h < this._gamepads.length; h++)
                                        if (n = this._gamepads[h], !r.padIndices[h]) {
                                            this._rawPads.length < 1 && n.disconnect();
                                            for (var l = 0; l < this._rawPads.length && !r.padIndices[h]; l++) {
                                                var c = this._rawPads[l];
                                                if (c) {
                                                    if (r.rawIndices[c.index]) {
                                                        n.disconnect();
                                                        continue
                                                    }
                                                    n.connect(c), r.rawIndices[c.index] = !0, r.padIndices[h] = !0
                                                } else n.disconnect()
                                            }
                                        }
                                }
                            }
                        }
                    },
                    setDeadZones: function(t) {
                        for (var e = 0; e < this._gamepads.length; e++) this._gamepads[e].deadZone = t
                    },
                    stop: function() {
                        this._active = !1, window.removeEventListener("gamepadconnected", this._onGamepadConnected), window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected)
                    },
                    reset: function() {
                        this.update();
                        for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].reset()
                    },
                    justPressed: function(t, e) {
                        for (var i = 0; i < this._gamepads.length; i++)
                            if (!0 === this._gamepads[i].justPressed(t, e)) return !0;
                        return !1
                    },
                    justReleased: function(t, e) {
                        for (var i = 0; i < this._gamepads.length; i++)
                            if (!0 === this._gamepads[i].justReleased(t, e)) return !0;
                        return !1
                    },
                    isDown: function(t) {
                        for (var e = 0; e < this._gamepads.length; e++)
                            if (!0 === this._gamepads[e].isDown(t)) return !0;
                        return !1
                    },
                    destroy: function() {
                        this.stop();
                        for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].destroy()
                    }
                }, n.Gamepad.prototype.constructor = n.Gamepad, Object.defineProperty(n.Gamepad.prototype, "active", {
                    get: function() {
                        return this._active
                    }
                }), Object.defineProperty(n.Gamepad.prototype, "supported", {
                    get: function() {
                        return this._gamepadSupportAvailable
                    }
                }), Object.defineProperty(n.Gamepad.prototype, "padsConnected", {
                    get: function() {
                        return this._rawPads.length
                    }
                }), Object.defineProperty(n.Gamepad.prototype, "pad1", {
                    get: function() {
                        return this._gamepads[0]
                    }
                }), Object.defineProperty(n.Gamepad.prototype, "pad2", {
                    get: function() {
                        return this._gamepads[1]
                    }
                }), Object.defineProperty(n.Gamepad.prototype, "pad3", {
                    get: function() {
                        return this._gamepads[2]
                    }
                }), Object.defineProperty(n.Gamepad.prototype, "pad4", {
                    get: function() {
                        return this._gamepads[3]
                    }
                }), n.Gamepad.BUTTON_0 = 0, n.Gamepad.BUTTON_1 = 1, n.Gamepad.BUTTON_2 = 2, n.Gamepad.BUTTON_3 = 3, n.Gamepad.BUTTON_4 = 4, n.Gamepad.BUTTON_5 = 5, n.Gamepad.BUTTON_6 = 6, n.Gamepad.BUTTON_7 = 7, n.Gamepad.BUTTON_8 = 8, n.Gamepad.BUTTON_9 = 9, n.Gamepad.BUTTON_10 = 10, n.Gamepad.BUTTON_11 = 11, n.Gamepad.BUTTON_12 = 12, n.Gamepad.BUTTON_13 = 13, n.Gamepad.BUTTON_14 = 14, n.Gamepad.BUTTON_15 = 15, n.Gamepad.AXIS_0 = 0, n.Gamepad.AXIS_1 = 1, n.Gamepad.AXIS_2 = 2, n.Gamepad.AXIS_3 = 3, n.Gamepad.AXIS_4 = 4, n.Gamepad.AXIS_5 = 5, n.Gamepad.AXIS_6 = 6, n.Gamepad.AXIS_7 = 7, n.Gamepad.AXIS_8 = 8, n.Gamepad.AXIS_9 = 9, n.Gamepad.XBOX360_A = 0, n.Gamepad.XBOX360_B = 1, n.Gamepad.XBOX360_X = 2, n.Gamepad.XBOX360_Y = 3, n.Gamepad.XBOX360_LEFT_BUMPER = 4, n.Gamepad.XBOX360_RIGHT_BUMPER = 5, n.Gamepad.XBOX360_LEFT_TRIGGER = 6, n.Gamepad.XBOX360_RIGHT_TRIGGER = 7, n.Gamepad.XBOX360_BACK = 8, n.Gamepad.XBOX360_START = 9, n.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, n.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, n.Gamepad.XBOX360_DPAD_LEFT = 14, n.Gamepad.XBOX360_DPAD_RIGHT = 15, n.Gamepad.XBOX360_DPAD_UP = 12, n.Gamepad.XBOX360_DPAD_DOWN = 13, n.Gamepad.XBOX360_STICK_LEFT_X = 0, n.Gamepad.XBOX360_STICK_LEFT_Y = 1, n.Gamepad.XBOX360_STICK_RIGHT_X = 2, n.Gamepad.XBOX360_STICK_RIGHT_Y = 3, n.Gamepad.PS3XC_X = 0, n.Gamepad.PS3XC_CIRCLE = 1, n.Gamepad.PS3XC_SQUARE = 2, n.Gamepad.PS3XC_TRIANGLE = 3, n.Gamepad.PS3XC_L1 = 4, n.Gamepad.PS3XC_R1 = 5, n.Gamepad.PS3XC_L2 = 6, n.Gamepad.PS3XC_R2 = 7, n.Gamepad.PS3XC_SELECT = 8, n.Gamepad.PS3XC_START = 9, n.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, n.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, n.Gamepad.PS3XC_DPAD_UP = 12, n.Gamepad.PS3XC_DPAD_DOWN = 13, n.Gamepad.PS3XC_DPAD_LEFT = 14, n.Gamepad.PS3XC_DPAD_RIGHT = 15, n.Gamepad.PS3XC_STICK_LEFT_X = 0, n.Gamepad.PS3XC_STICK_LEFT_Y = 1, n.Gamepad.PS3XC_STICK_RIGHT_X = 2, n.Gamepad.PS3XC_STICK_RIGHT_Y = 3, n.SinglePad = function(t, e) {
                    this.game = t, this.index = null, this.connected = !1, this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this.deadZone = .26, this._padParent = e, this._rawPad = null, this._prevTimestamp = null, this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0
                }, n.SinglePad.prototype = {
                    addCallbacks: function(t, e) {
                        void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t)
                    },
                    getButton: function(t) {
                        return this._buttons[t] ? this._buttons[t] : null
                    },
                    pollStatus: function() {
                        if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && this._rawPad && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                            for (var t = 0; t < this._buttonsLen; t++) {
                                var e = isNaN(this._rawPad.buttons[t]) ? this._rawPad.buttons[t].value : this._rawPad.buttons[t];
                                e !== this._buttons[t].value && (1 === e ? this.processButtonDown(t, e) : 0 === e ? this.processButtonUp(t, e) : this.processButtonFloat(t, e))
                            }
                            for (var i = 0; i < this._axesLen; i++) {
                                var s = this._rawPad.axes[i];
                                s > 0 && s > this.deadZone || s < 0 && s < -this.deadZone ? this.processAxisChange(i, s) : this.processAxisChange(i, 0)
                            }
                            this._prevTimestamp = this._rawPad.timestamp
                        }
                    },
                    connect: function(t) {
                        var e = !this.connected;
                        this.connected = !0, this.index = t.index, this._rawPad = t, this._buttons = [], this._buttonsLen = t.buttons.length, this._axes = [], this._axesLen = t.axes.length;
                        for (var i = 0; i < this._axesLen; i++) this._axes[i] = t.axes[i];
                        for (var s in t.buttons) s = parseInt(s, 10), this._buttons[s] = new n.DeviceButton(this, s);
                        e && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), e && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext)
                    },
                    disconnect: function() {
                        var t = this.connected,
                            e = this.index;
                        this.connected = !1, this.index = null, this._rawPad = void 0;
                        for (var i = 0; i < this._buttonsLen; i++) this._buttons[i].destroy();
                        this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, t && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, e), t && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext)
                    },
                    destroy: function() {
                        this._rawPad = void 0;
                        for (var t = 0; t < this._buttonsLen; t++) this._buttons[t].destroy();
                        this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null
                    },
                    processAxisChange: function(t, e) {
                        this._axes[t] !== e && (this._axes[t] = e, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, t, e), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, t, e))
                    },
                    processButtonDown: function(t, e) {
                        this._buttons[t] && this._buttons[t].start(null, e), this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, t, e, this.index), this.onDownCallback && this.onDownCallback.call(this.callbackContext, t, e)
                    },
                    processButtonUp: function(t, e) {
                        this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, t, e, this.index), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].stop(null, e)
                    },
                    processButtonFloat: function(t, e) {
                        this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, t, e, this.index), this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].padFloat(e)
                    },
                    axis: function(t) {
                        return !!this._axes[t] && this._axes[t]
                    },
                    isDown: function(t) {
                        return !!this._buttons[t] && this._buttons[t].isDown
                    },
                    isUp: function(t) {
                        return !!this._buttons[t] && this._buttons[t].isUp
                    },
                    justReleased: function(t, e) {
                        if (this._buttons[t]) return this._buttons[t].justReleased(e)
                    },
                    justPressed: function(t, e) {
                        if (this._buttons[t]) return this._buttons[t].justPressed(e)
                    },
                    buttonValue: function(t) {
                        return this._buttons[t] ? this._buttons[t].value : null
                    },
                    reset: function() {
                        for (var t = 0; t < this._axes.length; t++) this._axes[t] = 0
                    }
                }, n.SinglePad.prototype.constructor = n.SinglePad, n.Key = function(t, e) {
                    this.game = t, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = -2500, this.durationUp = -2500, this.repeats = 0, this.keyCode = e, this.onDown = new n.Signal, this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new n.Signal, this._justDown = !1, this._justUp = !1
                }, n.Key.prototype = {
                    update: function() {
                        this._enabled && (this.isDown ? (this.duration = this.game.time.time - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this)) : this.durationUp = this.game.time.time - this.timeUp)
                    },
                    processKeyDown: function(t) {
                        this._enabled && (this.event = t, this.isDown || (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.durationUp = this.game.time.time - this.timeUp, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this)))
                    },
                    processKeyUp: function(t) {
                        this._enabled && (this.event = t, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, this.durationUp = 0, this._justUp = !0, this.onUp.dispatch(this)))
                    },
                    reset: function(t) {
                        void 0 === t && (t = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = 0, this.durationUp = -2500, this._enabled = !0, this._justDown = !1, this._justUp = !1, t && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null)
                    },
                    downDuration: function(t) {
                        return void 0 === t && (t = 50), this.isDown && this.duration < t
                    },
                    upDuration: function(t) {
                        return void 0 === t && (t = 50), !this.isDown && this.game.time.time - this.timeUp < t
                    },
                    justPressed: function() {
                        return this.isDown && 0 === this.duration
                    },
                    justReleased: function() {
                        return !this.isDown && 0 === this.durationUp
                    }
                }, Object.defineProperty(n.Key.prototype, "justDown", {
                    get: function() {
                        var t = this._justDown;
                        return this._justDown = !1, t
                    }
                }), Object.defineProperty(n.Key.prototype, "justUp", {
                    get: function() {
                        var t = this._justUp;
                        return this._justUp = !1, t
                    }
                }), Object.defineProperty(n.Key.prototype, "enabled", {
                    get: function() {
                        return this._enabled
                    },
                    set: function(t) {
                        (t = !!t) !== this._enabled && (t || this.reset(!1), this._enabled = t)
                    }
                }), n.Key.prototype.constructor = n.Key, n.Keyboard = function(t) {
                    this.game = t, this.active = !1, this.enabled = !0, this.event = null, this.pressEvent = null, this.callbackContext = this, this.onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0
                }, n.Keyboard.prototype = {
                    addCallbacks: function(t, e, i, s) {
                        this.callbackContext = t, void 0 !== e && null !== e && (this.onDownCallback = e), void 0 !== i && null !== i && (this.onUpCallback = i), void 0 !== s && null !== s && (this.onPressCallback = s)
                    },
                    removeCallbacks: function() {
                        this.callbackContext = this, this.onDownCallback = null, this.onUpCallback = null, this.onPressCallback = null
                    },
                    addKey: function(t) {
                        return this._keys[t] || (this._keys[t] = new n.Key(this.game, t), this.addKeyCapture(t)), this._keys[t]
                    },
                    addKeys: function(t) {
                        var e = {};
                        for (var i in t) e[i] = this.addKey(t[i]);
                        return e
                    },
                    removeKey: function(t) {
                        this._keys[t] && (this._keys[t] = null, this.removeKeyCapture(t))
                    },
                    createCursorKeys: function() {
                        return this.addKeys({
                            up: n.KeyCode.UP,
                            down: n.KeyCode.DOWN,
                            left: n.KeyCode.LEFT,
                            right: n.KeyCode.RIGHT
                        })
                    },
                    start: function() {
                        if (this.game.device.cocoonJS) return !1;
                        if (this.active) return !1;
                        var t = this;
                        return this._onKeyDown = function(e) {
                            return t.processKeyDown(e)
                        }, this._onKeyUp = function(e) {
                            return t.processKeyUp(e)
                        }, this._onKeyPress = function(e) {
                            return t.processKeyPress(e)
                        }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("keypress", this._onKeyPress, !1), this.active = !0, !0
                    },
                    stop: function() {
                        window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, this._onKeyUp = null, this._onKeyPress = null, this.active = !1
                    },
                    destroy: function() {
                        this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0
                    },
                    addKeyCapture: function(t) {
                        if ("object" == typeof t)
                            for (var e in t) this._capture[t[e]] = !0;
                        else this._capture[t] = !0
                    },
                    removeKeyCapture: function(t) {
                        delete this._capture[t]
                    },
                    clearCaptures: function() {
                        this._capture = {}
                    },
                    update: function() {
                        for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update()
                    },
                    processKeyDown: function(t) {
                        if (this.event = t, this.game.input.enabled && this.enabled) {
                            var e = t.keyCode;
                            this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new n.Key(this.game, e)), this._keys[e].processKeyDown(t), this._k = e, this.onDownCallback && this.onDownCallback.call(this.callbackContext, t)
                        }
                    },
                    processKeyPress: function(t) {
                        this.pressEvent = t, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(t.charCode), t)
                    },
                    processKeyUp: function(t) {
                        if (this.event = t, this.game.input.enabled && this.enabled) {
                            var e = t.keyCode;
                            this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new n.Key(this.game, e)), this._keys[e].processKeyUp(t), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t)
                        }
                    },
                    reset: function(t) {
                        void 0 === t && (t = !0), this.event = null;
                        for (var e = this._keys.length; e--;) this._keys[e] && this._keys[e].reset(t)
                    },
                    downDuration: function(t, e) {
                        return this._keys[t] ? this._keys[t].downDuration(e) : null
                    },
                    upDuration: function(t, e) {
                        return this._keys[t] ? this._keys[t].upDuration(e) : null
                    },
                    justPressed: function(t) {
                        return this._keys[t] ? this._keys[t].justPressed() : null
                    },
                    justReleased: function(t) {
                        return this._keys[t] ? this._keys[t].justReleased() : null
                    },
                    isDown: function(t) {
                        return this._keys[t] ? this._keys[t].isDown : null
                    }
                }, Object.defineProperty(n.Keyboard.prototype, "lastChar", {
                    get: function() {
                        return this.event && 32 === this.event.charCode ? "" : this.pressEvent ? String.fromCharCode(this.pressEvent.charCode) : null
                    }
                }), Object.defineProperty(n.Keyboard.prototype, "lastKey", {
                    get: function() {
                        return this._keys[this._k]
                    }
                }), n.Keyboard.prototype.constructor = n.Keyboard, n.KeyCode = {
                    A: "A".charCodeAt(0),
                    B: "B".charCodeAt(0),
                    C: "C".charCodeAt(0),
                    D: "D".charCodeAt(0),
                    E: "E".charCodeAt(0),
                    F: "F".charCodeAt(0),
                    G: "G".charCodeAt(0),
                    H: "H".charCodeAt(0),
                    I: "I".charCodeAt(0),
                    J: "J".charCodeAt(0),
                    K: "K".charCodeAt(0),
                    L: "L".charCodeAt(0),
                    M: "M".charCodeAt(0),
                    N: "N".charCodeAt(0),
                    O: "O".charCodeAt(0),
                    P: "P".charCodeAt(0),
                    Q: "Q".charCodeAt(0),
                    R: "R".charCodeAt(0),
                    S: "S".charCodeAt(0),
                    T: "T".charCodeAt(0),
                    U: "U".charCodeAt(0),
                    V: "V".charCodeAt(0),
                    W: "W".charCodeAt(0),
                    X: "X".charCodeAt(0),
                    Y: "Y".charCodeAt(0),
                    Z: "Z".charCodeAt(0),
                    ZERO: "0".charCodeAt(0),
                    ONE: "1".charCodeAt(0),
                    TWO: "2".charCodeAt(0),
                    THREE: "3".charCodeAt(0),
                    FOUR: "4".charCodeAt(0),
                    FIVE: "5".charCodeAt(0),
                    SIX: "6".charCodeAt(0),
                    SEVEN: "7".charCodeAt(0),
                    EIGHT: "8".charCodeAt(0),
                    NINE: "9".charCodeAt(0),
                    NUMPAD_0: 96,
                    NUMPAD_1: 97,
                    NUMPAD_2: 98,
                    NUMPAD_3: 99,
                    NUMPAD_4: 100,
                    NUMPAD_5: 101,
                    NUMPAD_6: 102,
                    NUMPAD_7: 103,
                    NUMPAD_8: 104,
                    NUMPAD_9: 105,
                    NUMPAD_MULTIPLY: 106,
                    NUMPAD_ADD: 107,
                    NUMPAD_ENTER: 108,
                    NUMPAD_SUBTRACT: 109,
                    NUMPAD_DECIMAL: 110,
                    NUMPAD_DIVIDE: 111,
                    F1: 112,
                    F2: 113,
                    F3: 114,
                    F4: 115,
                    F5: 116,
                    F6: 117,
                    F7: 118,
                    F8: 119,
                    F9: 120,
                    F10: 121,
                    F11: 122,
                    F12: 123,
                    F13: 124,
                    F14: 125,
                    F15: 126,
                    COLON: 186,
                    EQUALS: 187,
                    COMMA: 188,
                    UNDERSCORE: 189,
                    PERIOD: 190,
                    QUESTION_MARK: 191,
                    TILDE: 192,
                    OPEN_BRACKET: 219,
                    BACKWARD_SLASH: 220,
                    CLOSED_BRACKET: 221,
                    QUOTES: 222,
                    BACKSPACE: 8,
                    TAB: 9,
                    CLEAR: 12,
                    ENTER: 13,
                    SHIFT: 16,
                    CONTROL: 17,
                    ALT: 18,
                    CAPS_LOCK: 20,
                    ESC: 27,
                    SPACEBAR: 32,
                    PAGE_UP: 33,
                    PAGE_DOWN: 34,
                    END: 35,
                    HOME: 36,
                    LEFT: 37,
                    UP: 38,
                    RIGHT: 39,
                    DOWN: 40,
                    PLUS: 43,
                    MINUS: 44,
                    INSERT: 45,
                    DELETE: 46,
                    HELP: 47,
                    NUM_LOCK: 144
                };
                for (var o in n.KeyCode) n.KeyCode.hasOwnProperty(o) && !o.match(/[a-z]/) && (n.Keyboard[o] = n.KeyCode[o]);
                n.Component = function() {}, n.Component.Angle = function() {}, n.Component.Angle.prototype = {
                    angle: {
                        get: function() {
                            return n.Math.wrapAngle(n.Math.radToDeg(this.rotation))
                        },
                        set: function(t) {
                            this.rotation = n.Math.degToRad(n.Math.wrapAngle(t))
                        }
                    }
                }, n.Component.Animation = function() {}, n.Component.Animation.prototype = {
                    play: function(t, e, i, s) {
                        if (this.animations) return this.animations.play(t, e, i, s)
                    }
                }, n.Component.AutoCull = function() {}, n.Component.AutoCull.prototype = {
                    autoCull: !1,
                    inCamera: {
                        get: function() {
                            return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds)
                        }
                    }
                }, n.Component.Bounds = function() {}, n.Component.Bounds.prototype = {
                    offsetX: {
                        get: function() {
                            return this.anchor.x * this.width
                        }
                    },
                    offsetY: {
                        get: function() {
                            return this.anchor.y * this.height
                        }
                    },
                    centerX: {
                        get: function() {
                            return this.x - this.offsetX + .5 * this.width
                        },
                        set: function(t) {
                            this.x = t + this.offsetX - .5 * this.width
                        }
                    },
                    centerY: {
                        get: function() {
                            return this.y - this.offsetY + .5 * this.height
                        },
                        set: function(t) {
                            this.y = t + this.offsetY - .5 * this.height
                        }
                    },
                    left: {
                        get: function() {
                            return this.x - this.offsetX
                        },
                        set: function(t) {
                            this.x = t + this.offsetX
                        }
                    },
                    right: {
                        get: function() {
                            return this.x + this.width - this.offsetX
                        },
                        set: function(t) {
                            this.x = t - this.width + this.offsetX
                        }
                    },
                    top: {
                        get: function() {
                            return this.y - this.offsetY
                        },
                        set: function(t) {
                            this.y = t + this.offsetY
                        }
                    },
                    bottom: {
                        get: function() {
                            return this.y + this.height - this.offsetY
                        },
                        set: function(t) {
                            this.y = t - this.height + this.offsetY
                        }
                    },
                    alignIn: function(t, e, i, s) {
                        switch (void 0 === i && (i = 0), void 0 === s && (s = 0), e) {
                            default:
                            case n.TOP_LEFT:
                                this.left = t.left - i, this.top = t.top - s;
                                break;
                            case n.TOP_CENTER:
                                this.centerX = t.centerX + i, this.top = t.top - s;
                                break;
                            case n.TOP_RIGHT:
                                this.right = t.right + i, this.top = t.top - s;
                                break;
                            case n.LEFT_CENTER:
                                this.left = t.left - i, this.centerY = t.centerY + s;
                                break;
                            case n.CENTER:
                                this.centerX = t.centerX + i, this.centerY = t.centerY + s;
                                break;
                            case n.RIGHT_CENTER:
                                this.right = t.right + i, this.centerY = t.centerY + s;
                                break;
                            case n.BOTTOM_LEFT:
                                this.left = t.left - i, this.bottom = t.bottom + s;
                                break;
                            case n.BOTTOM_CENTER:
                                this.centerX = t.centerX + i, this.bottom = t.bottom + s;
                                break;
                            case n.BOTTOM_RIGHT:
                                this.right = t.right + i, this.bottom = t.bottom + s
                        }
                        return this
                    },
                    alignTo: function(t, e, i, s) {
                        switch (void 0 === i && (i = 0), void 0 === s && (s = 0), e) {
                            default:
                            case n.TOP_LEFT:
                                this.left = t.left - i, this.bottom = t.top - s;
                                break;
                            case n.TOP_CENTER:
                                this.centerX = t.centerX + i, this.bottom = t.top - s;
                                break;
                            case n.TOP_RIGHT:
                                this.right = t.right + i, this.bottom = t.top - s;
                                break;
                            case n.LEFT_TOP:
                                this.right = t.left - i, this.top = t.top - s;
                                break;
                            case n.LEFT_CENTER:
                                this.right = t.left - i, this.centerY = t.centerY + s;
                                break;
                            case n.LEFT_BOTTOM:
                                this.right = t.left - i, this.bottom = t.bottom + s;
                                break;
                            case n.RIGHT_TOP:
                                this.left = t.right + i, this.top = t.top - s;
                                break;
                            case n.RIGHT_CENTER:
                                this.left = t.right + i, this.centerY = t.centerY + s;
                                break;
                            case n.RIGHT_BOTTOM:
                                this.left = t.right + i, this.bottom = t.bottom + s;
                                break;
                            case n.BOTTOM_LEFT:
                                this.left = t.left - i, this.top = t.bottom + s;
                                break;
                            case n.BOTTOM_CENTER:
                                this.centerX = t.centerX + i, this.top = t.bottom + s;
                                break;
                            case n.BOTTOM_RIGHT:
                                this.right = t.right + i, this.top = t.bottom + s
                        }
                        return this
                    }
                }, n.Group.prototype.alignIn = n.Component.Bounds.prototype.alignIn, n.Group.prototype.alignTo = n.Component.Bounds.prototype.alignTo, n.Component.BringToTop = function() {}, n.Component.BringToTop.prototype.bringToTop = function() {
                    return this.parent && this.parent.bringChildToTop && this.parent.bringChildToTop(this), this
                }, n.Component.BringToTop.prototype.sendToBack = function() {
                    return this.parent && this.parent.sendChildToBack && this.parent.sendChildToBack(this), this
                }, n.Component.BringToTop.prototype.moveUp = function() {
                    return this.parent && this.parent.moveUp(this), this
                }, n.Component.BringToTop.prototype.moveDown = function() {
                    return this.parent && this.parent.moveDown(this), this
                }, n.Component.Core = function() {}, n.Component.Core.skipTypeChecks = !1, n.Component.Core.install = function(t) {
                    n.Utils.mixinPrototype(this, n.Component.Core.prototype), this.components = {};
                    for (var e = 0; e < t.length; e++) {
                        var i = t[e],
                            s = !1;
                        "Destroy" === i && (s = !0), n.Utils.mixinPrototype(this, n.Component[i].prototype, s), this.components[i] = !0
                    }
                }, n.Component.Core.init = function(t, e, i, s, r) {
                    if (!n.Component.Core.skipTypeChecks) {
                        if (!(t instanceof n.Game)) throw new Error("The value passed as the `game` argument (" + t + ") is not an instance of Phaser.Game.");
                        "number" != typeof e && (console.warn("The `x` argument value (%s) should be a number.", e), e = 0), "number" != typeof i && (console.warn("The `y` argument value (%s) should be a number.", i), i = 0)
                    }
                    this.game = t, this.key = s, this.data = {}, this.position.set(e, i), this.world = new n.Point(e, i), this.previousPosition = new n.Point(e, i), this.events = new n.Events(this), this._bounds = new n.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new n.AnimationManager(this)), this.components.LoadTexture && null !== s && this.loadTexture(s, r), this.components.FixedToCamera && (this.cameraOffset = new n.Point(e, i))
                }, n.Component.Core.preUpdate = function() {
                    return this.pendingDestroy ? (this.destroy(), !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.exists && this.parent.exists ? (this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate(), this.preUpdateChildren(), !0) : (this.renderOrderID = -1, !1))
                }, n.Component.Core.prototype = {
                    game: null,
                    name: "",
                    data: {},
                    components: {},
                    z: 0,
                    events: void 0,
                    animations: void 0,
                    key: "",
                    world: null,
                    debug: !1,
                    previousPosition: null,
                    previousRotation: 0,
                    renderOrderID: 0,
                    fresh: !0,
                    pendingDestroy: !1,
                    _bounds: null,
                    _exists: !0,
                    exists: {
                        get: function() {
                            return this._exists
                        },
                        set: function(t) {
                            t ? (this._exists = !0, this.body && this.body.type === n.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._exists = !1, this.body && this.body.type === n.Physics.P2JS && this.body.removeFromWorld(), this.visible = !1)
                        }
                    },
                    preUpdateChildren: function() {
                        for (var t = 0; t < this.children.length;) {
                            var e = this.children[t];
                            e.preUpdate(), this === e.parent && t++
                        }
                    },
                    update: function() {},
                    postUpdate: function() {
                        this.customRender && this.key.render(), this.components.PhysicsBody && n.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && n.Component.FixedToCamera.postUpdate.call(this);
                        for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
                    }
                }, n.Component.Crop = function() {}, n.Component.Crop.prototype = {
                    cropRect: null,
                    _crop: null,
                    crop: function(t, e) {
                        void 0 === e && (e = !1), t ? (e && null !== this.cropRect ? this.cropRect.setTo(t.x, t.y, t.width, t.height) : e && null === this.cropRect ? this.cropRect = new n.Rectangle(t.x, t.y, t.width, t.height) : this.cropRect = t, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame())
                    },
                    updateCrop: function() {
                        if (this.cropRect) {
                            var t = this.texture.crop.x,
                                e = this.texture.crop.y,
                                i = this.texture.crop.width,
                                s = this.texture.crop.height;
                            this._crop = n.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y;
                            var r = Math.max(this._frame.x, this._crop.x),
                                o = Math.max(this._frame.y, this._crop.y),
                                a = Math.min(this._frame.right, this._crop.right) - r,
                                h = Math.min(this._frame.bottom, this._crop.bottom) - o;
                            this.texture.crop.x = r, this.texture.crop.y = o, this.texture.crop.width = a, this.texture.crop.height = h, this.texture.frame.width = Math.min(a, this.cropRect.width), this.texture.frame.height = Math.min(h, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || t === r && e === o && i === a && s === h || (this.texture.requiresReTint = !0)
                        }
                    }
                }, n.Component.Delta = function() {}, n.Component.Delta.prototype = {
                    deltaX: {
                        get: function() {
                            return this.world.x - this.previousPosition.x
                        }
                    },
                    deltaY: {
                        get: function() {
                            return this.world.y - this.previousPosition.y
                        }
                    },
                    deltaZ: {
                        get: function() {
                            return this.rotation - this.previousRotation
                        }
                    }
                }, n.Component.Destroy = function() {}, n.Component.Destroy.prototype = {
                    destroyPhase: !1,
                    destroy: function(t, e) {
                        if (null !== this.game && !this.destroyPhase) {
                            void 0 === t && (t = !0), void 0 === e && (e = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof n.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this);
                            var i = this.children.length;
                            if (t)
                                for (; i--;) this.children[i].destroy(t);
                            else
                                for (; i--;) this.removeChild(this.children[i]);
                            this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), n.Video && this.key instanceof n.Video && this.key.onChangeSource.remove(this.resizeFrame, this), n.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), this._destroyTintedTexture(), e && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1
                        }
                    }
                }, n.Events = function(t) {
                    this.parent = t
                }, n.Events.prototype = {
                    destroy: function() {
                        this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose()
                    },
                    onAddedToGroup: null,
                    onRemovedFromGroup: null,
                    onDestroy: null,
                    onKilled: null,
                    onRevived: null,
                    onOutOfBounds: null,
                    onEnterBounds: null,
                    onInputOver: null,
                    onInputOut: null,
                    onInputDown: null,
                    onInputUp: null,
                    onDragStart: null,
                    onDragUpdate: null,
                    onDragStop: null,
                    onAnimationStart: null,
                    onAnimationComplete: null,
                    onAnimationLoop: null
                }, n.Events.prototype.constructor = n.Events;
                for (var a in n.Events.prototype) n.Events.prototype.hasOwnProperty(a) && 0 === a.indexOf("on") && null === n.Events.prototype[a] && function(t, e) {
                    "use strict";
                    Object.defineProperty(n.Events.prototype, t, {
                        get: function() {
                            return this[e] || (this[e] = new n.Signal)
                        }
                    }), n.Events.prototype[t + "$dispatch"] = function() {
                        return this[e] ? this[e].dispatch.apply(this[e], arguments) : null
                    }
                }(a, "_" + a);
                n.Component.FixedToCamera = function() {}, n.Component.FixedToCamera.postUpdate = function() {
                    this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
                }, n.Component.FixedToCamera.prototype = {
                    _fixedToCamera: !1,
                    fixedToCamera: {
                        get: function() {
                            return this._fixedToCamera
                        },
                        set: function(t) {
                            t ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1
                        }
                    },
                    cameraOffset: new n.Point
                }, n.Component.Health = function() {}, n.Component.Health.prototype = {
                    health: 1,
                    maxHealth: 100,
                    damage: function(t) {
                        return this.alive && (this.health -= t, this.health <= 0 && this.kill()), this
                    },
                    setHealth: function(t) {
                        return this.health = t, this.health > this.maxHealth && (this.health = this.maxHealth), this
                    },
                    heal: function(t) {
                        return this.alive && (this.health += t, this.health > this.maxHealth && (this.health = this.maxHealth)), this
                    }
                }, n.Component.InCamera = function() {}, n.Component.InCamera.prototype = {
                    inCamera: {
                        get: function() {
                            return this.game.world.camera.view.intersects(this._bounds)
                        }
                    }
                }, n.Component.InputEnabled = function() {}, n.Component.InputEnabled.prototype = {
                    input: null,
                    inputEnabled: {
                        get: function() {
                            return this.input && this.input.enabled
                        },
                        set: function(t) {
                            t ? null === this.input ? (this.input = new n.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                        }
                    }
                }, n.Component.InWorld = function() {}, n.Component.InWorld.preUpdate = function() {
                    if (this.pendingDestroy) return this.destroy(), !1;
                    if (this.autoCull || this.checkWorldBounds) {
                        if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull)
                            if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++;
                            else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(), !1;
                        if (this.checkWorldBounds)
                            if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this);
                            else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1
                    }
                    return !0
                }, n.Component.InWorld.prototype = {
                    checkWorldBounds: !1,
                    outOfBoundsKill: !1,
                    outOfCameraBoundsKill: !1,
                    _outOfBoundsFired: !1,
                    inWorld: {
                        get: function() {
                            return this.game.world.bounds.intersects(this.getBounds())
                        }
                    }
                }, n.Component.LifeSpan = function() {}, n.Component.LifeSpan.preUpdate = function() {
                    return this.pendingDestroy ? (this.destroy(), !1) : !(this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0)) || (this.kill(), !1)
                }, n.Component.LifeSpan.prototype = {
                    alive: !0,
                    lifespan: 0,
                    revive: function(t) {
                        return void 0 === t && (t = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(t), this.events && this.events.onRevived$dispatch(this), this
                    },
                    kill: function() {
                        return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this
                    }
                }, n.Component.LoadTexture = function() {}, n.Component.LoadTexture.prototype = {
                    customRender: !1,
                    _frame: null,
                    loadTexture: function(t, e, i) {
                        t === n.PENDING_ATLAS ? (t = e, e = 0) : e = e || 0, (i || void 0 === i) && this.animations && this.animations.stop(), this.key = t, this.customRender = !1;
                        var s = this.game.cache,
                            r = !0,
                            o = this.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR;
                        if (n.RenderTexture && t instanceof n.RenderTexture) this.key = t.key, this.setTexture(t);
                        else if (n.BitmapData && t instanceof n.BitmapData) this.customRender = !0, this.setTexture(t.texture), r = s.hasFrameData(t.key, n.Cache.BITMAPDATA) ? !this.animations.loadFrameData(s.getFrameData(t.key, n.Cache.BITMAPDATA), e) : !this.animations.loadFrameData(t.frameData, 0);
                        else if (n.Video && t instanceof n.Video) {
                            this.customRender = !0;
                            var a = t.texture.valid;
                            this.setTexture(t.texture), this.setFrame(t.texture.frame.clone()), t.onChangeSource.add(this.resizeFrame, this), this.texture.valid = a
                        } else if (n.Tilemap && t instanceof n.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(t.canvas));
                        else if (t instanceof PIXI.Texture) o = t.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, this.setTexture(t);
                        else {
                            var h = s.getImage(t, !0);
                            this.key = h.key, this.setTexture(new PIXI.Texture(h.base)), this.texture.baseTexture.skipRender = "__default" === t, r = !this.animations.loadFrameData(h.frameData, e)
                        }
                        r && (this._frame = n.Rectangle.clone(this.texture.frame)), o || (this.texture.baseTexture.scaleMode = 1)
                    },
                    setFrame: function(t) {
                        this._frame = t, this.texture.frame.x = t.x, this.texture.frame.y = t.y, this.texture.frame.width = t.width, this.texture.frame.height = t.height, this.texture.crop.x = t.x, this.texture.crop.y = t.y, this.texture.crop.width = t.width, this.texture.crop.height = t.height, t.trimmed ? (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX, this.texture.trim.y = t.spriteSourceSizeY, this.texture.trim.width = t.sourceSizeW, this.texture.trim.height = t.sourceSizeH) : this.texture.trim = {
                            x: t.spriteSourceSizeX,
                            y: t.spriteSourceSizeY,
                            width: t.sourceSizeW,
                            height: t.sourceSizeH
                        }, this.texture.width = t.sourceSizeW, this.texture.height = t.sourceSizeH, this.texture.frame.width = t.sourceSizeW, this.texture.frame.height = t.sourceSizeH) : !t.trimmed && this.texture.trim && (this.texture.trim = null), t.rotated && (this.texture.rotated = !0), this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), this.tilingTexture && (this.refreshTexture = !0)
                    },
                    resizeFrame: function(t, e, i) {
                        this.texture.frame.resize(e, i), this.texture.setFrame(this.texture.frame)
                    },
                    resetFrame: function() {
                        this._frame && this.setFrame(this._frame)
                    },
                    frame: {
                        get: function() {
                            return this.animations.frame
                        },
                        set: function(t) {
                            this.animations.frame = t
                        }
                    },
                    frameName: {
                        get: function() {
                            return this.animations.frameName
                        },
                        set: function(t) {
                            this.animations.frameName = t
                        }
                    }
                }, n.Component.Overlap = function() {}, n.Component.Overlap.prototype = {
                    overlap: function(t) {
                        return n.Rectangle.intersects(this.getBounds(), t.getBounds())
                    }
                }, n.Component.PhysicsBody = function() {}, n.Component.PhysicsBody.preUpdate = function() {
                    return this.pendingDestroy ? (this.destroy(), !1) : this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1, this.preUpdateChildren(), !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1, !1))
                }, n.Component.PhysicsBody.postUpdate = function() {
                    this.exists && this.body && this.body.postUpdate()
                }, n.Component.PhysicsBody.prototype = {
                    body: null,
                    x: {
                        get: function() {
                            return this.position.x
                        },
                        set: function(t) {
                            this.position.x = t, this.body && !this.body.dirty && (this.body._reset = !0)
                        }
                    },
                    y: {
                        get: function() {
                            return this.position.y
                        },
                        set: function(t) {
                            this.position.y = t, this.body && !this.body.dirty && (this.body._reset = !0)
                        }
                    }
                }, n.Component.Reset = function() {}, n.Component.Reset.prototype.reset = function(t, e, i) {
                    return void 0 === i && (i = 1), this.world.set(t, e), this.position.set(t, e), this.fresh = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), this.components.LifeSpan && (this.alive = !0, this.health = i), this.components.PhysicsBody && this.body && this.body.reset(t, e, !1, !1), this
                }, n.Component.ScaleMinMax = function() {}, n.Component.ScaleMinMax.prototype = {
                    transformCallback: null,
                    transformCallbackContext: this,
                    scaleMin: null,
                    scaleMax: null,
                    checkTransform: function(t) {
                        this.scaleMin && (t.a < this.scaleMin.x && (t.a = this.scaleMin.x), t.d < this.scaleMin.y && (t.d = this.scaleMin.y)), this.scaleMax && (t.a > this.scaleMax.x && (t.a = this.scaleMax.x), t.d > this.scaleMax.y && (t.d = this.scaleMax.y))
                    },
                    setScaleMinMax: function(t, e, i, s) {
                        void 0 === e ? e = i = s = t : void 0 === i && (i = s = e, e = t), null === t ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(t, e) : this.scaleMin = new n.Point(t, e), null === i ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(i, s) : this.scaleMax = new n.Point(i, s), null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform, this.transformCallbackContext = this)
                    }
                }, n.Component.Smoothed = function() {}, n.Component.Smoothed.prototype = {
                    smoothed: {
                        get: function() {
                            return !this.texture.baseTexture.scaleMode
                        },
                        set: function(t) {
                            t ? this.texture && 0 !== this.texture.baseTexture.scaleMode && (this.texture.baseTexture.scaleMode = 0, this.texture.baseTexture.dirty()) : this.texture && 1 !== this.texture.baseTexture.scaleMode && (this.texture.baseTexture.scaleMode = 1, this.texture.baseTexture.dirty())
                        }
                    }
                }, n.GameObjectFactory = function(t) {
                    this.game = t, this.world = this.game.world
                }, n.GameObjectFactory.prototype = {
                    existing: function(t) {
                        return this.world.add(t)
                    },
                    weapon: function(t, e, i, s, r) {
                        var o = this.game.plugins.add(n.Weapon);
                        return r && (o.bulletClass = r), o.createBullets(t, e, i, s), o
                    },
                    image: function(t, e, i, s, r) {
                        return void 0 === r && (r = this.world), r.add(new n.Image(this.game, t, e, i, s))
                    },
                    sprite: function(t, e, i, s, r) {
                        return void 0 === r && (r = this.world), r.add(new n.Sprite(this.game, t, e, i, s))
                    },
                    creature: function(t, e, i, s, r, o, a) {
                        void 0 === r && (r = this.world);
                        var h = new n.Creature(this.game, t, e, i, s, o, a);
                        return r.add(h), h
                    },
                    tween: function(t) {
                        return this.game.tweens.create(t)
                    },
                    group: function(t, e, i, s, r) {
                        return new n.Group(this.game, t, e, i, s, r)
                    },
                    physicsGroup: function(t, e, i, s) {
                        return new n.Group(this.game, e, i, s, !0, t)
                    },
                    spriteBatch: function(t, e, i) {
                        return void 0 === t && (t = null), void 0 === e && (e = "group"), void 0 === i && (i = !1), new n.SpriteBatch(this.game, t, e, i)
                    },
                    audio: function(t, e, i, s) {
                        return this.game.sound.add(t, e, i, s)
                    },
                    sound: function(t, e, i, s) {
                        return this.game.sound.add(t, e, i, s)
                    },
                    audioSprite: function(t) {
                        return this.game.sound.addSprite(t)
                    },
                    tileSprite: function(t, e, i, s, r, o, a) {
                        return void 0 === a && (a = this.world), a.add(new n.TileSprite(this.game, t, e, i, s, r, o))
                    },
                    rope: function(t, e, i, s, r, o) {
                        return void 0 === o && (o = this.world), o.add(new n.Rope(this.game, t, e, i, s, r))
                    },
                    text: function(t, e, i, s, r) {
                        return void 0 === r && (r = this.world), r.add(new n.Text(this.game, t, e, i, s))
                    },
                    button: function(t, e, i, s, r, o, a, h, l, c) {
                        return void 0 === c && (c = this.world), c.add(new n.Button(this.game, t, e, i, s, r, o, a, h, l))
                    },
                    graphics: function(t, e, i) {
                        return void 0 === i && (i = this.world), i.add(new n.Graphics(this.game, t, e))
                    },
                    emitter: function(t, e, i) {
                        return this.game.particles.add(new n.Particles.Arcade.Emitter(this.game, t, e, i))
                    },
                    retroFont: function(t, e, i, s, r, o, a, h, l) {
                        return new n.RetroFont(this.game, t, e, i, s, r, o, a, h, l)
                    },
                    bitmapText: function(t, e, i, s, r, o) {
                        return void 0 === o && (o = this.world), o.add(new n.BitmapText(this.game, t, e, i, s, r))
                    },
                    tilemap: function(t, e, i, s, r) {
                        return new n.Tilemap(this.game, t, e, i, s, r)
                    },
                    renderTexture: function(t, e, i, s) {
                        void 0 !== i && "" !== i || (i = this.game.rnd.uuid()), void 0 === s && (s = !1);
                        var r = new n.RenderTexture(this.game, t, e, i);
                        return s && this.game.cache.addRenderTexture(i, r), r
                    },
                    video: function(t, e) {
                        return new n.Video(this.game, t, e)
                    },
                    bitmapData: function(t, e, i, s) {
                        void 0 === s && (s = !1), void 0 !== i && "" !== i || (i = this.game.rnd.uuid());
                        var r = new n.BitmapData(this.game, i, t, e);
                        return s && this.game.cache.addBitmapData(i, r), r
                    },
                    filter: function(t) {
                        var e = Array.prototype.slice.call(arguments, 1);
                        return (t = new n.Filter[t](this.game)).init.apply(t, e), t
                    },
                    plugin: function() {
                        return this.game.plugins.add.apply(this.game.plugins, arguments)
                    }
                }, n.GameObjectFactory.prototype.constructor = n.GameObjectFactory, n.GameObjectCreator = function(t) {
                    this.game = t, this.world = this.game.world
                }, n.GameObjectCreator.prototype = {
                    image: function(t, e, i, s) {
                        return new n.Image(this.game, t, e, i, s)
                    },
                    sprite: function(t, e, i, s) {
                        return new n.Sprite(this.game, t, e, i, s)
                    },
                    tween: function(t) {
                        return new n.Tween(t, this.game, this.game.tweens)
                    },
                    group: function(t, e, i, s, r) {
                        return new n.Group(this.game, t || null, e, i, s, r)
                    },
                    spriteBatch: function(t, e, i) {
                        return void 0 === e && (e = "group"), void 0 === i && (i = !1), new n.SpriteBatch(this.game, t, e, i)
                    },
                    audio: function(t, e, i, s) {
                        return this.game.sound.add(t, e, i, s)
                    },
                    audioSprite: function(t) {
                        return this.game.sound.addSprite(t)
                    },
                    sound: function(t, e, i, s) {
                        return this.game.sound.add(t, e, i, s)
                    },
                    tileSprite: function(t, e, i, s, r, o) {
                        return new n.TileSprite(this.game, t, e, i, s, r, o)
                    },
                    rope: function(t, e, i, s, r) {
                        return new n.Rope(this.game, t, e, i, s, r)
                    },
                    text: function(t, e, i, s) {
                        return new n.Text(this.game, t, e, i, s)
                    },
                    button: function(t, e, i, s, r, o, a, h, l) {
                        return new n.Button(this.game, t, e, i, s, r, o, a, h, l)
                    },
                    graphics: function(t, e) {
                        return new n.Graphics(this.game, t, e)
                    },
                    emitter: function(t, e, i) {
                        return new n.Particles.Arcade.Emitter(this.game, t, e, i)
                    },
                    retroFont: function(t, e, i, s, r, o, a, h, l) {
                        return new n.RetroFont(this.game, t, e, i, s, r, o, a, h, l)
                    },
                    bitmapText: function(t, e, i, s, r, o) {
                        return new n.BitmapText(this.game, t, e, i, s, r, o)
                    },
                    tilemap: function(t, e, i, s, r) {
                        return new n.Tilemap(this.game, t, e, i, s, r)
                    },
                    renderTexture: function(t, e, i, s) {
                        void 0 !== i && "" !== i || (i = this.game.rnd.uuid()), void 0 === s && (s = !1);
                        var r = new n.RenderTexture(this.game, t, e, i);
                        return s && this.game.cache.addRenderTexture(i, r), r
                    },
                    bitmapData: function(t, e, i, s) {
                        void 0 === s && (s = !1), void 0 !== i && "" !== i || (i = this.game.rnd.uuid());
                        var r = new n.BitmapData(this.game, i, t, e);
                        return s && this.game.cache.addBitmapData(i, r), r
                    },
                    filter: function(t) {
                        var e = Array.prototype.slice.call(arguments, 1);
                        return (t = new n.Filter[t](this.game)).init.apply(t, e), t
                    }
                }, n.GameObjectCreator.prototype.constructor = n.GameObjectCreator, n.Sprite = function(t, e, i, s, r) {
                    e = e || 0, i = i || 0, s = s || null, r = r || null, this.type = n.SPRITE, this.physicsType = n.SPRITE, PIXI.Sprite.call(this, n.Cache.DEFAULT), n.Component.Core.init.call(this, t, e, i, s, r)
                }, n.Sprite.prototype = Object.create(PIXI.Sprite.prototype), n.Sprite.prototype.constructor = n.Sprite, n.Component.Core.install.call(n.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), n.Sprite.prototype.preUpdatePhysics = n.Component.PhysicsBody.preUpdate, n.Sprite.prototype.preUpdateLifeSpan = n.Component.LifeSpan.preUpdate, n.Sprite.prototype.preUpdateInWorld = n.Component.InWorld.preUpdate, n.Sprite.prototype.preUpdateCore = n.Component.Core.preUpdate, n.Sprite.prototype.preUpdate = function() {
                    return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                }, n.Image = function(t, e, i, s, r) {
                    e = e || 0, i = i || 0, s = s || null, r = r || null, this.type = n.IMAGE, PIXI.Sprite.call(this, n.Cache.DEFAULT), n.Component.Core.init.call(this, t, e, i, s, r)
                }, n.Image.prototype = Object.create(PIXI.Sprite.prototype), n.Image.prototype.constructor = n.Image, n.Component.Core.install.call(n.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]), n.Image.prototype.preUpdateLifeSpan = n.Component.LifeSpan.preUpdate, n.Image.prototype.preUpdateInWorld = n.Component.InWorld.preUpdate, n.Image.prototype.preUpdateCore = n.Component.Core.preUpdate, n.Image.prototype.preUpdate = function() {
                    return !(!this.preUpdateInWorld() || !this.preUpdateLifeSpan()) && this.preUpdateCore()
                }, n.Button = function(t, e, i, s, r, o, a, h, l, c) {
                    e = e || 0, i = i || 0, s = s || null, r = r || null, o = o || this, n.Image.call(this, t, e, i, s, h), this.type = n.BUTTON, this.physicsType = n.SPRITE, this._onOverFrame = null, this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new n.Signal, this.onInputOut = new n.Signal, this.onInputDown = new n.Signal, this.onInputUp = new n.Signal, this.onOverMouseOnly = !0, this.justReleasedPreventsOver = n.PointerMode.CONTACT, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(a, h, l, c), null !== r && this.onInputUp.add(r, o), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this)
                }, n.Button.prototype = Object.create(n.Image.prototype), n.Button.prototype.constructor = n.Button;
                var h = "Over",
                    l = "Out",
                    c = "Down",
                    u = "Up";
                return n.Button.prototype.clearFrames = function() {
                    this.setFrames(null, null, null, null)
                }, n.Button.prototype.setStateFrame = function(t, e, i) {
                    var s = "_on" + t + "Frame";
                    null !== e ? (this[s] = e, i && this.changeStateFrame(t)) : this[s] = null
                }, n.Button.prototype.changeStateFrame = function(t) {
                    if (this.freezeFrames) return !1;
                    var e = this["_on" + t + "Frame"];
                    return "string" == typeof e ? (this.frameName = e, !0) : "number" == typeof e && (this.frame = e, !0)
                }, n.Button.prototype.setFrames = function(t, e, i, s) {
                    this.setStateFrame(h, t, this.input.pointerOver()), this.setStateFrame(l, e, !this.input.pointerOver()), this.setStateFrame(c, i, this.input.pointerDown()), this.setStateFrame(u, s, this.input.pointerUp())
                }, n.Button.prototype.setStateSound = function(t, e, i) {
                    var s = "on" + t + "Sound",
                        r = "on" + t + "SoundMarker";
                    e instanceof n.Sound || e instanceof n.AudioSprite ? (this[s] = e, this[r] = "string" == typeof i ? i : "") : (this[s] = null, this[r] = "")
                }, n.Button.prototype.playStateSound = function(t) {
                    var e = this["on" + t + "Sound"];
                    if (e) {
                        var i = this["on" + t + "SoundMarker"];
                        return e.play(i), !0
                    }
                    return !1
                }, n.Button.prototype.setSounds = function(t, e, i, s, n, r, o, a) {
                    this.setStateSound(h, t, e), this.setStateSound(l, n, r), this.setStateSound(c, i, s), this.setStateSound(u, o, a)
                }, n.Button.prototype.setOverSound = function(t, e) {
                    this.setStateSound(h, t, e)
                }, n.Button.prototype.setOutSound = function(t, e) {
                    this.setStateSound(l, t, e)
                }, n.Button.prototype.setDownSound = function(t, e) {
                    this.setStateSound(c, t, e)
                }, n.Button.prototype.setUpSound = function(t, e) {
                    this.setStateSound(u, t, e)
                }, n.Button.prototype.onInputOverHandler = function(t, e) {
                    e.justReleased() && (this.justReleasedPreventsOver & e.pointerMode) === e.pointerMode || (this.changeStateFrame(h), this.onOverMouseOnly && !e.isMouse || (this.playStateSound(h), this.onInputOver && this.onInputOver.dispatch(this, e)))
                }, n.Button.prototype.onInputOutHandler = function(t, e) {
                    this.changeStateFrame(l), this.playStateSound(l), this.onInputOut && this.onInputOut.dispatch(this, e)
                }, n.Button.prototype.onInputDownHandler = function(t, e) {
                    this.changeStateFrame(c), this.playStateSound(c), this.onInputDown && this.onInputDown.dispatch(this, e)
                }, n.Button.prototype.onInputUpHandler = function(t, e, i) {
                    (this.playStateSound(u), this.onInputUp && this.onInputUp.dispatch(this, e, i), this.freezeFrames) || (!0 === this.forceOut || (this.forceOut & e.pointerMode) === e.pointerMode ? this.changeStateFrame(l) : this.changeStateFrame(u) || (i ? this.changeStateFrame(h) : this.changeStateFrame(l)))
                }, n.SpriteBatch = function(t, e, i, s) {
                    void 0 !== e && null !== e || (e = t.world), n.Group.call(this, t, e, i, s), this.type = n.SPRITEBATCH, this.fastSpriteBatch = null, this.ready = !1
                }, n.SpriteBatch.prototype = Object.create(n.Group.prototype), n.SpriteBatch.prototype.constructor = n.SpriteBatch, n.SpriteBatch.prototype._renderWebGL = function(t) {
                    !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || (this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(t.gl), this.ready = !0), this.fastSpriteBatch.gl !== t.gl && this.fastSpriteBatch.setContext(t.gl), t.spriteBatch.stop(), t.shaderManager.setShader(t.shaderManager.fastShader), this.fastSpriteBatch.begin(this, t), this.fastSpriteBatch.render(this), t.spriteBatch.start())
                }, n.SpriteBatch.prototype._renderCanvas = function(t) {
                    if (this.visible && !(this.alpha <= 0) && this.children.length) {
                        var e = t.context;
                        e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
                        for (var i = this.worldTransform, s = !0, n = 0; n < this.children.length; n++) {
                            var r = this.children[n];
                            if (r.visible) {
                                var o = r.texture,
                                    a = o.frame;
                                if (e.globalAlpha = this.worldAlpha * r.alpha, r.rotation % (2 * Math.PI) == 0) s && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), s = !1), e.drawImage(o.baseTexture.source, a.x, a.y, a.width, a.height, r.anchor.x * (-a.width * r.scale.x) + r.position.x + .5 + t.shakeX | 0, r.anchor.y * (-a.height * r.scale.y) + r.position.y + .5 + t.shakeY | 0, a.width * r.scale.x, a.height * r.scale.y);
                                else {
                                    s || (s = !0), r.displayObjectUpdateTransform();
                                    var h = r.worldTransform,
                                        l = h.tx * t.resolution + t.shakeX,
                                        c = h.ty * t.resolution + t.shakeY;
                                    t.roundPixels ? e.setTransform(h.a, h.b, h.c, h.d, 0 | l, 0 | c) : e.setTransform(h.a, h.b, h.c, h.d, l, c), e.drawImage(o.baseTexture.source, a.x, a.y, a.width, a.height, r.anchor.x * -a.width + .5 | 0, r.anchor.y * -a.height + .5 | 0, a.width, a.height)
                                }
                            }
                        }
                    }
                }, n.BitmapData = function(t, e, i, s, r) {
                    void 0 !== i && 0 !== i || (i = 256), void 0 !== s && 0 !== s || (s = 256), void 0 === r && (r = !1), this.game = t, this.key = e, this.width = i, this.height = s, this.canvas = n.Canvas.create(this, i, s, null, r), this.context = this.canvas.getContext("2d", {
                        alpha: !0
                    }), this.ctx = this.context, this.smoothProperty = t.renderType === n.CANVAS ? t.renderer.renderSession.smoothProperty : n.Canvas.getSmoothingPrefix(this.context), this.imageData = this.context.getImageData(0, 0, i, s), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data), this.baseTexture = new PIXI.BaseTexture(this.canvas, null, this.game.resolution), this.texture = new PIXI.Texture(this.baseTexture), this.frameData = new n.FrameData, this.textureFrame = this.frameData.addFrame(new n.Frame(0, 0, 0, i, s, "bitmapData")), this.texture.frame = this.textureFrame, this.type = n.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, this._image = null, this._pos = new n.Point, this._size = new n.Point, this._scale = new n.Point, this._rotate = 0, this._alpha = {
                        prev: 1,
                        current: 1
                    }, this._anchor = new n.Point, this._tempR = 0, this._tempG = 0, this._tempB = 0, this._circle = new n.Circle, this._swapCanvas = void 0
                }, n.BitmapData.prototype = {
                    move: function(t, e, i) {
                        return 0 !== t && this.moveH(t, i), 0 !== e && this.moveV(e, i), this
                    },
                    moveH: function(t, e) {
                        void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = n.CanvasPool.create(this, this.width, this.height));
                        var i = this._swapCanvas.getContext("2d"),
                            s = this.height,
                            r = this.canvas;
                        if (i.clearRect(0, 0, this.width, this.height), t < 0) {
                            t = Math.abs(t);
                            var o = this.width - t;
                            e && i.drawImage(r, 0, 0, t, s, o, 0, t, s), i.drawImage(r, t, 0, o, s, 0, 0, o, s)
                        } else {
                            o = this.width - t;
                            e && i.drawImage(r, o, 0, t, s, 0, 0, t, s), i.drawImage(r, 0, 0, o, s, t, 0, o, s)
                        }
                        return this.clear(), this.copy(this._swapCanvas)
                    },
                    moveV: function(t, e) {
                        void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = n.CanvasPool.create(this, this.width, this.height));
                        var i = this._swapCanvas.getContext("2d"),
                            s = this.width,
                            r = this.canvas;
                        if (i.clearRect(0, 0, this.width, this.height), t < 0) {
                            t = Math.abs(t);
                            var o = this.height - t;
                            e && i.drawImage(r, 0, 0, s, t, 0, o, s, t), i.drawImage(r, 0, t, s, o, 0, 0, s, o)
                        } else {
                            o = this.height - t;
                            e && i.drawImage(r, 0, o, s, t, 0, 0, s, t), i.drawImage(r, 0, 0, s, o, 0, t, s, o)
                        }
                        return this.clear(), this.copy(this._swapCanvas)
                    },
                    add: function(t) {
                        if (Array.isArray(t))
                            for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                        else t.loadTexture(this);
                        return this
                    },
                    load: function(t) {
                        if ("string" == typeof t && (t = this.game.cache.getImage(t)), t) return this.resize(t.width, t.height), this.cls(), this.draw(t), this.update(), this
                    },
                    clear: function(t, e, i, s) {
                        return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === s && (s = this.height), this.context.clearRect(t, e, i, s), this.dirty = !0, this
                    },
                    fill: function(t, e, i, s) {
                        return void 0 === s && (s = 1), this.context.fillStyle = "rgba(" + t + "," + e + "," + i + "," + s + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this
                    },
                    generateTexture: function(t, e, i) {
                        var s = this.game.cache,
                            n = new Image;
                        if (e && (n.onload = function() {
                                var r = s.addImage(t, "", n),
                                    o = new PIXI.Texture(r.base);
                                e.call(i || null, o), n.onload = null
                            }), n.src = this.canvas.toDataURL("image/png"), !e) {
                            var r = s.addImage(t, "", n);
                            return new PIXI.Texture(r.base)
                        }
                        return null
                    },
                    resize: function(t, e) {
                        return t === this.width && e === this.height || (this.width = t, this.height = e, this.canvas.width = t, this.canvas.height = e, void 0 !== this._swapCanvas && (this._swapCanvas.width = t, this._swapCanvas.height = e), this.baseTexture.width = t, this.baseTexture.height = e, this.textureFrame.width = t, this.textureFrame.height = e, this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.update(), this.dirty = !0), this
                    },
                    update: function(t, e, i, s) {
                        return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = Math.max(1, this.width)), void 0 === s && (s = Math.max(1, this.height)), this.imageData = this.context.getImageData(t, e, i, s), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this
                    },
                    processPixelRGB: function(t, e, i, s, r, o) {
                        void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === r && (r = this.width), void 0 === o && (o = this.height);
                        for (var a = i + r, h = s + o, l = n.Color.createColor(), c = {
                                r: 0,
                                g: 0,
                                b: 0,
                                a: 0
                            }, u = !1, d = s; d < h; d++)
                            for (var p = i; p < a; p++) n.Color.unpackPixel(this.getPixel32(p, d), l), !1 !== (c = t.call(e, l, p, d)) && null !== c && void 0 !== c && (this.setPixel32(p, d, c.r, c.g, c.b, c.a, !1), u = !0);
                        return u && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
                    },
                    processPixel: function(t, e, i, s, n, r) {
                        void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = this.width), void 0 === r && (r = this.height);
                        for (var o = i + n, a = s + r, h = 0, l = 0, c = !1, u = s; u < a; u++)
                            for (var d = i; d < o; d++) h = this.getPixel32(d, u), (l = t.call(e, h, d, u)) !== h && (this.pixels[u * this.width + d] = l, c = !0);
                        return c && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
                    },
                    replaceRGB: function(t, e, i, s, r, o, a, h, l) {
                        var c = 0,
                            u = 0,
                            d = this.width,
                            p = this.height,
                            f = n.Color.packPixel(t, e, i, s);
                        void 0 !== l && l instanceof n.Rectangle && (c = l.x, u = l.y, d = l.width, p = l.height);
                        for (var g = 0; g < p; g++)
                            for (var m = 0; m < d; m++) this.getPixel32(c + m, u + g) === f && this.setPixel32(c + m, u + g, r, o, a, h, !1);
                        return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                    },
                    setHSL: function(t, e, i, s) {
                        var r = t || 0 === t,
                            o = e || 0 === e,
                            a = i || 0 === i;
                        if (r || o || a) {
                            void 0 === s && (s = new n.Rectangle(0, 0, this.width, this.height));
                            for (var h = n.Color.createColor(), l = s.y; l < s.bottom; l++)
                                for (var c = s.x; c < s.right; c++) n.Color.unpackPixel(this.getPixel32(c, l), h, !0), r && (h.h = t), o && (h.s = e), a && (h.l = i), n.Color.HSLtoRGB(h.h, h.s, h.l, h), this.setPixel32(c, l, h.r, h.g, h.b, h.a, !1);
                            return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                        }
                    },
                    shiftHSL: function(t, e, i, s) {
                        if (void 0 !== t && null !== t || (t = !1), void 0 !== e && null !== e || (e = !1), void 0 !== i && null !== i || (i = !1), t || e || i) {
                            void 0 === s && (s = new n.Rectangle(0, 0, this.width, this.height));
                            for (var r = n.Color.createColor(), o = s.y; o < s.bottom; o++)
                                for (var a = s.x; a < s.right; a++) n.Color.unpackPixel(this.getPixel32(a, o), r, !0), t && (r.h = this.game.math.wrap(r.h + t, 0, 1)), e && (r.s = this.game.math.clamp(r.s + e, 0, 1)), i && (r.l = this.game.math.clamp(r.l + i, 0, 1)), n.Color.HSLtoRGB(r.h, r.s, r.l, r), this.setPixel32(a, o, r.r, r.g, r.b, r.a, !1);
                            return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                        }
                    },
                    setPixel32: function(t, e, i, s, r, o, a) {
                        return void 0 === a && (a = !0), t >= 0 && t <= this.width && e >= 0 && e <= this.height && (n.Device.LITTLE_ENDIAN ? this.pixels[e * this.width + t] = o << 24 | r << 16 | s << 8 | i : this.pixels[e * this.width + t] = i << 24 | s << 16 | r << 8 | o, a && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), this
                    },
                    setPixel: function(t, e, i, s, n, r) {
                        return this.setPixel32(t, e, i, s, n, 255, r)
                    },
                    getPixel: function(t, e, i) {
                        i || (i = n.Color.createColor());
                        var s = ~~(t + e * this.width);
                        return s *= 4, i.r = this.data[s], i.g = this.data[++s], i.b = this.data[++s], i.a = this.data[++s], i
                    },
                    getPixel32: function(t, e) {
                        if (t >= 0 && t <= this.width && e >= 0 && e <= this.height) return this.pixels[e * this.width + t]
                    },
                    getPixelRGB: function(t, e, i, s, r) {
                        return n.Color.unpackPixel(this.getPixel32(t, e), i, s, r)
                    },
                    getPixels: function(t) {
                        return this.context.getImageData(t.x, t.y, t.width, t.height)
                    },
                    getFirstPixel: function(t) {
                        void 0 === t && (t = 0);
                        var e = n.Color.createColor(),
                            i = 0,
                            s = 0,
                            r = 1,
                            o = !1;
                        1 === t ? (r = -1, s = this.height) : 3 === t && (r = -1, i = this.width);
                        do {
                            n.Color.unpackPixel(this.getPixel32(i, s), e), 0 === t || 1 === t ? ++i === this.width && (i = 0, ((s += r) >= this.height || s <= 0) && (o = !0)) : 2 !== t && 3 !== t || ++s === this.height && (s = 0, ((i += r) >= this.width || i <= 0) && (o = !0))
                        } while (0 === e.a && !o);
                        return e.x = i, e.y = s, e
                    },
                    getBounds: function(t) {
                        return void 0 === t && (t = new n.Rectangle), t.x = this.getFirstPixel(2).x, t.x === this.width ? t.setTo(0, 0, 0, 0) : (t.y = this.getFirstPixel(0).y, t.width = this.getFirstPixel(3).x - t.x + 1, t.height = this.getFirstPixel(1).y - t.y + 1, t)
                    },
                    addToWorld: function(t, e, i, s, n, r) {
                        n = n || 1, r = r || 1;
                        var o = this.game.add.image(t, e, this);
                        return o.anchor.set(i, s), o.scale.set(n, r), o
                    },
                    copy: function(t, e, i, s, r, o, a, h, l, c, u, d, p, f, g, m, y) {
                        if (void 0 !== t && null !== t || (t = this), t instanceof n.RenderTexture && (t = t.getCanvas()), this._image = t, t instanceof n.Sprite || t instanceof n.Image || t instanceof n.Text || t instanceof PIXI.Sprite) this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), this._scale.set(t.scale.x, t.scale.y), this._anchor.set(t.anchor.x, t.anchor.y), this._rotate = t.rotation, this._alpha.current = t.alpha, t.texture instanceof n.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source, void 0 !== o && null !== o || (o = t.x), void 0 !== a && null !== a || (a = t.y), t.texture.trim && (o += t.texture.trim.x - t.anchor.x * t.texture.trim.width, a += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0));
                        else {
                            if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, t instanceof n.BitmapData) this._image = t.canvas;
                            else if ("string" == typeof t) {
                                if (null === (t = this.game.cache.getImage(t))) return this;
                                this._image = t
                            }
                            this._size.set(this._image.width, this._image.height)
                        }
                        if (void 0 !== e && null !== e || (e = 0), void 0 !== i && null !== i || (i = 0), s && (this._size.x = s), r && (this._size.y = r), void 0 !== o && null !== o || (o = e), void 0 !== a && null !== a || (a = i), void 0 !== h && null !== h || (h = this._size.x), void 0 !== l && null !== l || (l = this._size.y), "number" == typeof c && (this._rotate = c), "number" == typeof u && (this._anchor.x = u), "number" == typeof d && (this._anchor.y = d), "number" == typeof p && (this._scale.x = p), "number" == typeof f && (this._scale.y = f), "number" == typeof g && (this._alpha.current = g), void 0 === m && (m = null), void 0 === y && (y = !1), this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y) return this;
                        var v = this.context;
                        return this._alpha.prev = v.globalAlpha, v.save(), v.globalAlpha = this._alpha.current, m && (this.op = m), y && (o |= 0, a |= 0), v.translate(o, a), v.scale(this._scale.x, this._scale.y), v.rotate(this._rotate), v.drawImage(this._image, this._pos.x + e, this._pos.y + i, this._size.x, this._size.y, -h * this._anchor.x, -l * this._anchor.y, h, l), v.restore(), v.globalAlpha = this._alpha.prev, this.dirty = !0, this
                    },
                    copyTransform: function(t, e, i) {
                        if (void 0 === e && (e = null), void 0 === i && (i = !1), !t.hasOwnProperty("worldTransform") || !t.worldVisible || 0 === t.worldAlpha) return this;
                        var s = t.worldTransform;
                        if (this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), 0 === s.a || 0 === s.d || 0 === this._size.x || 0 === this._size.y) return this;
                        t.texture instanceof n.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source;
                        var r = s.tx,
                            o = s.ty;
                        t.texture.trim && (r += t.texture.trim.x - t.anchor.x * t.texture.trim.width, o += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0)), i && (r |= 0, o |= 0);
                        var a = this.context;
                        return this._alpha.prev = a.globalAlpha, a.save(), a.globalAlpha = this._alpha.current, e && (this.op = e), a[this.smoothProperty] = t.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, a.setTransform(s.a, s.b, s.c, s.d, r, o), a.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * t.anchor.x, -this._size.y * t.anchor.y, this._size.x, this._size.y), a.restore(), a.globalAlpha = this._alpha.prev, this.dirty = !0, this
                    },
                    copyRect: function(t, e, i, s, n, r, o) {
                        return this.copy(t, e.x, e.y, e.width, e.height, i, s, e.width, e.height, 0, 0, 0, 1, 1, n, r, o)
                    },
                    draw: function(t, e, i, s, n, r, o) {
                        return this.copy(t, null, null, null, null, e, i, s, n, null, null, null, null, null, null, r, o)
                    },
                    drawGroup: function(t, e, i) {
                        return t.total > 0 && t.forEachExists(this.drawGroupProxy, this, e, i), this
                    },
                    drawGroupProxy: function(t, e, i) {
                        if (t.hasOwnProperty("texture") && this.copyTransform(t, e, i), t.type === n.GROUP && t.exists) this.drawGroup(t, e, i);
                        else if (t.hasOwnProperty("children") && t.children.length > 0)
                            for (var s = 0; s < t.children.length; s++) t.children[s].exists && this.copyTransform(t.children[s], e, i)
                    },
                    drawFull: function(t, e, i) {
                        if (!1 === t.worldVisible || 0 === t.worldAlpha || t.hasOwnProperty("exists") && !1 === t.exists) return this;
                        if (t.type !== n.GROUP && t.type !== n.EMITTER && t.type !== n.BITMAPTEXT)
                            if (t.type === n.GRAPHICS) {
                                var s = t.getBounds();
                                this.ctx.save(), this.ctx.translate(s.x, s.y), PIXI.CanvasGraphics.renderGraphics(t, this.ctx), this.ctx.restore()
                            } else this.copy(t, null, null, null, null, t.worldPosition.x, t.worldPosition.y, null, null, t.worldRotation, null, null, t.worldScale.x, t.worldScale.y, t.worldAlpha, e, i);
                        if (t.children)
                            for (var r = 0; r < t.children.length; r++) this.drawFull(t.children[r], e, i);
                        return this
                    },
                    shadow: function(t, e, i, s) {
                        var n = this.context;
                        return void 0 === t || null === t ? n.shadowColor = "rgba(0,0,0,0)" : (n.shadowColor = t, n.shadowBlur = 0 === e ? 0 : e || 5, n.shadowOffsetX = 0 === i ? 0 : i || 10, n.shadowOffsetY = 0 === s ? 0 : s || 10), this
                    },
                    alphaMask: function(t, e, i, s) {
                        return void 0 === s || null === s ? this.draw(e).blendSourceAtop() : this.draw(e, s.x, s.y, s.width, s.height).blendSourceAtop(), void 0 === i || null === i ? this.draw(t).blendReset() : this.draw(t, i.x, i.y, i.width, i.height).blendReset(), this
                    },
                    extract: function(t, e, i, s, n, r, o, a, h) {
                        return void 0 === n && (n = 255), void 0 === r && (r = !1), void 0 === o && (o = e), void 0 === a && (a = i), void 0 === h && (h = s), r && t.resize(this.width, this.height), this.processPixelRGB(function(r, l, c) {
                            return r.r === e && r.g === i && r.b === s && t.setPixel32(l, c, o, a, h, n, !1), !1
                        }, this), t.context.putImageData(t.imageData, 0, 0), t.dirty = !0, t
                    },
                    rect: function(t, e, i, s, n) {
                        return void 0 !== n && (this.context.fillStyle = n), this.context.fillRect(t, e, i, s), this
                    },
                    text: function(t, e, i, s, n, r) {
                        void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = "14px Courier"), void 0 === n && (n = "rgb(255,255,255)"), void 0 === r && (r = !0);
                        var o = this.context,
                            a = o.font;
                        return o.font = s, r && (o.fillStyle = "rgb(0,0,0)", o.fillText(t, e + 1, i + 1)), o.fillStyle = n, o.fillText(t, e, i), o.font = a, this
                    },
                    circle: function(t, e, i, s) {
                        var n = this.context;
                        return void 0 !== s && (n.fillStyle = s), n.beginPath(), n.arc(t, e, i, 0, 2 * Math.PI, !1), n.closePath(), n.fill(), this
                    },
                    line: function(t, e, i, s, n, r) {
                        void 0 === n && (n = "#fff"), void 0 === r && (r = 1);
                        var o = this.context;
                        return o.beginPath(), o.moveTo(t, e), o.lineTo(i, s), o.lineWidth = r, o.strokeStyle = n, o.stroke(), o.closePath(), this
                    },
                    polygon: function(t, e, i, s) {
                        void 0 === s && (s = "#fff"), void 0 === i && (i = 0);
                        var n = this.context;
                        e && (n.fillStyle = e), i && (n.lineWidth = i, n.strokeStyle = s), n.beginPath(), n.moveTo(t[0].x, t[0].y);
                        for (var r = 1, o = t.length; r < o; r++) {
                            var a = t[r];
                            n.lineTo(a.x, a.y)
                        }
                        return n.closePath(), e && n.fill(), i && n.stroke(), this
                    },
                    textureLine: function(t, e, i) {
                        if (void 0 === i && (i = "repeat-x"), "string" != typeof e || (e = this.game.cache.getImage(e))) {
                            var s = t.length;
                            "no-repeat" === i && s > e.width && (s = e.width);
                            var r = this.context;
                            return r.fillStyle = r.createPattern(e, i), this._circle = new n.Circle(t.start.x, t.start.y, e.height), this._circle.circumferencePoint(t.angle - 1.5707963267948966, !1, this._pos), r.save(), r.translate(this._pos.x, this._pos.y), r.rotate(t.angle), r.fillRect(0, 0, s, e.height), r.restore(), this.dirty = !0, this
                        }
                    },
                    render: function() {
                        return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), this
                    },
                    destroy: function() {
                        this.frameData.destroy(), this.texture.destroy(!0), n.CanvasPool.remove(this)
                    },
                    blendReset: function() {
                        return this.op = "source-over", this
                    },
                    blendSourceOver: function() {
                        return this.op = "source-over", this
                    },
                    blendSourceIn: function() {
                        return this.op = "source-in", this
                    },
                    blendSourceOut: function() {
                        return this.op = "source-out", this
                    },
                    blendSourceAtop: function() {
                        return this.op = "source-atop", this
                    },
                    blendDestinationOver: function() {
                        return this.op = "destination-over", this
                    },
                    blendDestinationIn: function() {
                        return this.op = "destination-in", this
                    },
                    blendDestinationOut: function() {
                        return this.op = "destination-out", this
                    },
                    blendDestinationAtop: function() {
                        return this.op = "destination-atop", this
                    },
                    blendXor: function() {
                        return this.op = "xor", this
                    },
                    blendAdd: function() {
                        return this.op = "lighter", this
                    },
                    blendMultiply: function() {
                        return this.op = "multiply", this
                    },
                    blendScreen: function() {
                        return this.op = "screen", this
                    },
                    blendOverlay: function() {
                        return this.op = "overlay", this
                    },
                    blendDarken: function() {
                        return this.op = "darken", this
                    },
                    blendLighten: function() {
                        return this.op = "lighten", this
                    },
                    blendColorDodge: function() {
                        return this.op = "color-dodge", this
                    },
                    blendColorBurn: function() {
                        return this.op = "color-burn", this
                    },
                    blendHardLight: function() {
                        return this.op = "hard-light", this
                    },
                    blendSoftLight: function() {
                        return this.op = "soft-light", this
                    },
                    blendDifference: function() {
                        return this.op = "difference", this
                    },
                    blendExclusion: function() {
                        return this.op = "exclusion", this
                    },
                    blendHue: function() {
                        return this.op = "hue", this
                    },
                    blendSaturation: function() {
                        return this.op = "saturation", this
                    },
                    blendColor: function() {
                        return this.op = "color", this
                    },
                    blendLuminosity: function() {
                        return this.op = "luminosity", this
                    },
                    copyBitmapData: function(t, e, i) {
                        t.update();
                        for (var s, n = 0; n < t.height; n++) {
                            s = (i + n) * this.width + e;
                            for (var r = 0; r < t.width; r++) this.pixels[s + r] = t.pixels[n * t.width + r]
                        }
                        return this
                    }
                }, Object.defineProperty(n.BitmapData.prototype, "smoothed", {
                    get: function() {
                        return n.Canvas.getSmoothingEnabled(this.context)
                    },
                    set: function(t) {
                        n.Canvas.setSmoothingEnabled(this.context, t)
                    }
                }), Object.defineProperty(n.BitmapData.prototype, "op", {
                    get: function() {
                        return this.context.globalCompositeOperation
                    },
                    set: function(t) {
                        this.context.globalCompositeOperation = t
                    }
                }), n.BitmapData.getTransform = function(t, e, i, s, n, r) {
                    return "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), "number" != typeof i && (i = 1), "number" != typeof s && (s = 1), "number" != typeof n && (n = 0), "number" != typeof r && (r = 0), {
                        sx: i,
                        sy: s,
                        scaleX: i,
                        scaleY: s,
                        skewX: n,
                        skewY: r,
                        translateX: t,
                        translateY: e,
                        tx: t,
                        ty: e
                    }
                }, n.BitmapData.prototype.constructor = n.BitmapData, n.EarCut = {}, n.EarCut.Triangulate = function(t, e, i) {
                    i = i || 2;
                    var s, r, o, a, h, l, c, u = e && e.length,
                        d = u ? e[0] * i : t.length,
                        p = n.EarCut.linkedList(t, 0, d, i, !0),
                        f = [];
                    if (!p) return f;
                    if (u && (p = n.EarCut.eliminateHoles(t, e, p, i)), t.length > 80 * i) {
                        s = o = t[0], r = a = t[1];
                        for (var g = i; g < d; g += i) h = t[g], l = t[g + 1], h < s && (s = h), l < r && (r = l), h > o && (o = h), l > a && (a = l);
                        c = Math.max(o - s, a - r)
                    }
                    return n.EarCut.earcutLinked(p, f, i, s, r, c), f
                }, n.EarCut.linkedList = function(t, e, i, s, r) {
                    var o, a, h, l = 0;
                    for (o = e, a = i - s; o < i; o += s) l += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o;
                    if (r === l > 0)
                        for (o = e; o < i; o += s) h = n.EarCut.insertNode(o, t[o], t[o + 1], h);
                    else
                        for (o = i - s; o >= e; o -= s) h = n.EarCut.insertNode(o, t[o], t[o + 1], h);
                    return h
                }, n.EarCut.filterPoints = function(t, e) {
                    if (!t) return t;
                    e || (e = t);
                    var i, s = t;
                    do {
                        if (i = !1, s.steiner || !n.EarCut.equals(s, s.next) && 0 !== n.EarCut.area(s.prev, s, s.next)) s = s.next;
                        else {
                            if (n.EarCut.removeNode(s), (s = e = s.prev) === s.next) return null;
                            i = !0
                        }
                    } while (i || s !== e);
                    return e
                }, n.EarCut.earcutLinked = function(t, e, i, s, r, o, a) {
                    if (t) {
                        !a && o && n.EarCut.indexCurve(t, s, r, o);
                        for (var h, l, c = t; t.prev !== t.next;)
                            if (h = t.prev, l = t.next, o ? n.EarCut.isEarHashed(t, s, r, o) : n.EarCut.isEar(t)) e.push(h.i / i), e.push(t.i / i), e.push(l.i / i), n.EarCut.removeNode(t), t = l.next, c = l.next;
                            else if ((t = l) === c) {
                            a ? 1 === a ? (t = n.EarCut.cureLocalIntersections(t, e, i), n.EarCut.earcutLinked(t, e, i, s, r, o, 2)) : 2 === a && n.EarCut.splitEarcut(t, e, i, s, r, o) : n.EarCut.earcutLinked(n.EarCut.filterPoints(t), e, i, s, r, o, 1);
                            break
                        }
                    }
                }, n.EarCut.isEar = function(t) {
                    var e = t.prev,
                        i = t,
                        s = t.next;
                    if (n.EarCut.area(e, i, s) >= 0) return !1;
                    for (var r = t.next.next; r !== t.prev;) {
                        if (n.EarCut.pointInTriangle(e.x, e.y, i.x, i.y, s.x, s.y, r.x, r.y) && n.EarCut.area(r.prev, r, r.next) >= 0) return !1;
                        r = r.next
                    }
                    return !0
                }, n.EarCut.isEarHashed = function(t, e, i, s) {
                    var r = t.prev,
                        o = t,
                        a = t.next;
                    if (n.EarCut.area(r, o, a) >= 0) return !1;
                    for (var h = r.x < o.x ? r.x < a.x ? r.x : a.x : o.x < a.x ? o.x : a.x, l = r.y < o.y ? r.y < a.y ? r.y : a.y : o.y < a.y ? o.y : a.y, c = r.x > o.x ? r.x > a.x ? r.x : a.x : o.x > a.x ? o.x : a.x, u = r.y > o.y ? r.y > a.y ? r.y : a.y : o.y > a.y ? o.y : a.y, d = n.EarCut.zOrder(h, l, e, i, s), p = n.EarCut.zOrder(c, u, e, i, s), f = t.nextZ; f && f.z <= p;) {
                        if (f !== t.prev && f !== t.next && n.EarCut.pointInTriangle(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && n.EarCut.area(f.prev, f, f.next) >= 0) return !1;
                        f = f.nextZ
                    }
                    for (f = t.prevZ; f && f.z >= d;) {
                        if (f !== t.prev && f !== t.next && n.EarCut.pointInTriangle(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && n.EarCut.area(f.prev, f, f.next) >= 0) return !1;
                        f = f.prevZ
                    }
                    return !0
                }, n.EarCut.cureLocalIntersections = function(t, e, i) {
                    var s = t;
                    do {
                        var r = s.prev,
                            o = s.next.next;
                        n.EarCut.intersects(r, s, s.next, o) && n.EarCut.locallyInside(r, o) && n.EarCut.locallyInside(o, r) && (e.push(r.i / i), e.push(s.i / i), e.push(o.i / i), n.EarCut.removeNode(s), n.EarCut.removeNode(s.next), s = t = o), s = s.next
                    } while (s !== t);
                    return s
                }, n.EarCut.splitEarcut = function(t, e, i, s, r, o) {
                    var a = t;
                    do {
                        for (var h = a.next.next; h !== a.prev;) {
                            if (a.i !== h.i && n.EarCut.isValidDiagonal(a, h)) {
                                var l = n.EarCut.splitPolygon(a, h);
                                return a = n.EarCut.filterPoints(a, a.next), l = n.EarCut.filterPoints(l, l.next), n.EarCut.earcutLinked(a, e, i, s, r, o), void n.EarCut.earcutLinked(l, e, i, s, r, o)
                            }
                            h = h.next
                        }
                        a = a.next
                    } while (a !== t)
                }, n.EarCut.eliminateHoles = function(t, e, i, s) {
                    var r, o, a, h, l, c = [];
                    for (r = 0, o = e.length; r < o; r++) a = e[r] * s, h = r < o - 1 ? e[r + 1] * s : t.length, (l = n.EarCut.linkedList(t, a, h, s, !1)) === l.next && (l.steiner = !0), c.push(n.EarCut.getLeftmost(l));
                    for (c.sort(n.EarCut.compareX), r = 0; r < c.length; r++) n.EarCut.eliminateHole(c[r], i), i = n.EarCut.filterPoints(i, i.next);
                    return i
                }, n.EarCut.compareX = function(t, e) {
                    return t.x - e.x
                }, n.EarCut.eliminateHole = function(t, e) {
                    if (e = n.EarCut.findHoleBridge(t, e)) {
                        var i = n.EarCut.splitPolygon(e, t);
                        n.EarCut.filterPoints(i, i.next)
                    }
                }, n.EarCut.findHoleBridge = function(t, e) {
                    var i, s = e,
                        r = t.x,
                        o = t.y,
                        a = -1 / 0;
                    do {
                        if (o <= s.y && o >= s.next.y) {
                            var h = s.x + (o - s.y) * (s.next.x - s.x) / (s.next.y - s.y);
                            h <= r && h > a && (a = h, i = s.x < s.next.x ? s : s.next)
                        }
                        s = s.next
                    } while (s !== e);
                    if (!i) return null;
                    if (t.x === i.x) return i.prev;
                    var l, c = i,
                        u = 1 / 0;
                    for (s = i.next; s !== c;) r >= s.x && s.x >= i.x && n.EarCut.pointInTriangle(o < i.y ? r : a, o, i.x, i.y, o < i.y ? a : r, o, s.x, s.y) && ((l = Math.abs(o - s.y) / (r - s.x)) < u || l === u && s.x > i.x) && n.EarCut.locallyInside(s, t) && (i = s, u = l), s = s.next;
                    return i
                }, n.EarCut.indexCurve = function(t, e, i, s) {
                    var r = t;
                    do {
                        null === r.z && (r.z = n.EarCut.zOrder(r.x, r.y, e, i, s)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                    } while (r !== t);
                    r.prevZ.nextZ = null, r.prevZ = null, n.EarCut.sortLinked(r)
                }, n.EarCut.sortLinked = function(t) {
                    var e, i, s, n, r, o, a, h, l = 1;
                    do {
                        for (i = t, t = null, r = null, o = 0; i;) {
                            for (o++, s = i, a = 0, e = 0; e < l && (a++, s = s.nextZ); e++);
                            for (h = l; a > 0 || h > 0 && s;) 0 === a ? (n = s, s = s.nextZ, h--) : 0 !== h && s ? i.z <= s.z ? (n = i, i = i.nextZ, a--) : (n = s, s = s.nextZ, h--) : (n = i, i = i.nextZ, a--), r ? r.nextZ = n : t = n, n.prevZ = r, r = n;
                            i = s
                        }
                        r.nextZ = null, l *= 2
                    } while (o > 1);
                    return t
                }, n.EarCut.zOrder = function(t, e, i, s, n) {
                    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) / n) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - s) / n) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
                }, n.EarCut.getLeftmost = function(t) {
                    var e = t,
                        i = t;
                    do {
                        e.x < i.x && (i = e), e = e.next
                    } while (e !== t);
                    return i
                }, n.EarCut.pointInTriangle = function(t, e, i, s, n, r, o, a) {
                    return (n - o) * (e - a) - (t - o) * (r - a) >= 0 && (t - o) * (s - a) - (i - o) * (e - a) >= 0 && (i - o) * (r - a) - (n - o) * (s - a) >= 0
                }, n.EarCut.isValidDiagonal = function(t, e) {
                    return n.EarCut.equals(t, e) || t.next.i !== e.i && t.prev.i !== e.i && !n.EarCut.intersectsPolygon(t, e) && n.EarCut.locallyInside(t, e) && n.EarCut.locallyInside(e, t) && n.EarCut.middleInside(t, e)
                }, n.EarCut.area = function(t, e, i) {
                    return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
                }, n.EarCut.equals = function(t, e) {
                    return t.x === e.x && t.y === e.y
                }, n.EarCut.intersects = function(t, e, i, s) {
                    return n.EarCut.area(t, e, i) > 0 != n.EarCut.area(t, e, s) > 0 && n.EarCut.area(i, s, t) > 0 != n.EarCut.area(i, s, e) > 0
                }, n.EarCut.intersectsPolygon = function(t, e) {
                    var i = t;
                    do {
                        if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && n.EarCut.intersects(i, i.next, t, e)) return !0;
                        i = i.next
                    } while (i !== t);
                    return !1
                }, n.EarCut.locallyInside = function(t, e) {
                    return n.EarCut.area(t.prev, t, t.next) < 0 ? n.EarCut.area(t, e, t.next) >= 0 && n.EarCut.area(t, t.prev, e) >= 0 : n.EarCut.area(t, e, t.prev) < 0 || n.EarCut.area(t, t.next, e) < 0
                }, n.EarCut.middleInside = function(t, e) {
                    var i = t,
                        s = !1,
                        n = (t.x + e.x) / 2,
                        r = (t.y + e.y) / 2;
                    do {
                        i.y > r != i.next.y > r && n < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (s = !s), i = i.next
                    } while (i !== t);
                    return s
                }, n.EarCut.splitPolygon = function(t, e) {
                    var i = new n.EarCut.Node(t.i, t.x, t.y),
                        s = new n.EarCut.Node(e.i, e.x, e.y),
                        r = t.next,
                        o = e.prev;
                    return t.next = e, e.prev = t, i.next = r, r.prev = i, s.next = i, i.prev = s, o.next = s, s.prev = o, s
                }, n.EarCut.insertNode = function(t, e, i, s) {
                    var r = new n.EarCut.Node(t, e, i);
                    return s ? (r.next = s.next, r.prev = s, s.next.prev = r, s.next = r) : (r.prev = r, r.next = r), r
                }, n.EarCut.removeNode = function(t) {
                    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
                }, n.EarCut.Node = function(t, e, i) {
                    this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
                }, PIXI.WebGLGraphics = function() {}, PIXI.WebGLGraphics.stencilBufferLimit = 6, PIXI.WebGLGraphics.renderGraphics = function(t, e) {
                    var i, s = e.gl,
                        r = e.projection,
                        o = e.offset,
                        a = e.shaderManager.primitiveShader;
                    t.dirty && PIXI.WebGLGraphics.updateGraphics(t, s);
                    var h = t._webGL[s.id];
                    if (h)
                        for (var l = 0; l < h.data.length; l++) 1 === h.data[l].mode ? (i = h.data[l], e.stencilManager.pushStencil(t, i, e), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (i.indices.length - 4)), e.stencilManager.popStencil(t, i, e)) : (i = h.data[l], e.shaderManager.setShader(a), a = e.shaderManager.primitiveShader, s.uniformMatrix3fv(a.translationMatrix, !1, t.worldTransform.toArray(!0)), s.uniform1f(a.flipY, 1), s.uniform2f(a.projectionVector, r.x, -r.y), s.uniform2f(a.offsetVector, -o.x, -o.y), s.uniform3fv(a.tintColor, n.Color.hexToRGBArray(t.tint)), s.uniform1f(a.alpha, t.worldAlpha), s.bindBuffer(s.ARRAY_BUFFER, i.buffer), s.vertexAttribPointer(a.aVertexPosition, 2, s.FLOAT, !1, 24, 0), s.vertexAttribPointer(a.colorAttribute, 4, s.FLOAT, !1, 24, 8), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, i.indexBuffer), s.drawElements(s.TRIANGLE_STRIP, i.indices.length, s.UNSIGNED_SHORT, 0))
                }, PIXI.WebGLGraphics.updateGraphics = function(t, e) {
                    var i, s, r = t._webGL[e.id];
                    if (r || (r = t._webGL[e.id] = {
                            lastIndex: 0,
                            data: [],
                            gl: e
                        }), t.dirty = !1, t.clearDirty) {
                        for (t.clearDirty = !1, i = 0; i < r.data.length; i++) {
                            var o = r.data[i];
                            o.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(o)
                        }
                        r.data = [], r.lastIndex = 0
                    }
                    for (i = r.lastIndex; i < t.graphicsData.length; i++) {
                        var a = t.graphicsData[i];
                        if (a.type === n.POLYGON) {
                            if (a.points = a.shape.points.slice(), a.shape.closed && (a.points[0] === a.points[a.points.length - 2] && a.points[1] === a.points[a.points.length - 1] || a.points.push(a.points[0], a.points[1])), a.fill)
                                if (a.points.length >= PIXI.WebGLGraphics.stencilBufferLimit)
                                    if (a.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit) s = PIXI.WebGLGraphics.switchMode(r, 0), PIXI.WebGLGraphics.buildPoly(a, s) || (s = PIXI.WebGLGraphics.switchMode(r, 1), PIXI.WebGLGraphics.buildComplexPoly(a, s));
                                    else s = PIXI.WebGLGraphics.switchMode(r, 1), PIXI.WebGLGraphics.buildComplexPoly(a, s);
                            a.lineWidth > 0 && (s = PIXI.WebGLGraphics.switchMode(r, 0), PIXI.WebGLGraphics.buildLine(a, s))
                        } else s = PIXI.WebGLGraphics.switchMode(r, 0), a.type === n.RECTANGLE ? PIXI.WebGLGraphics.buildRectangle(a, s) : a.type === n.CIRCLE || a.type === n.ELLIPSE ? PIXI.WebGLGraphics.buildCircle(a, s) : a.type === n.ROUNDEDRECTANGLE && PIXI.WebGLGraphics.buildRoundedRectangle(a, s);
                        r.lastIndex++
                    }
                    for (i = 0; i < r.data.length; i++)(s = r.data[i]).dirty && s.upload()
                }, PIXI.WebGLGraphics.switchMode = function(t, e) {
                    var i;
                    return t.data.length && (i = t.data[t.data.length - 1]).mode === e && 1 !== e || ((i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl)).mode = e, t.data.push(i)), i.dirty = !0, i
                }, PIXI.WebGLGraphics.buildRectangle = function(t, e) {
                    var i = t.shape,
                        s = i.x,
                        r = i.y,
                        o = i.width,
                        a = i.height;
                    if (t.fill) {
                        var h = n.Color.hexToRGBArray(t.fillColor),
                            l = t.fillAlpha,
                            c = h[0] * l,
                            u = h[1] * l,
                            d = h[2] * l,
                            p = e.points,
                            f = e.indices,
                            g = p.length / 6;
                        p.push(s, r), p.push(c, u, d, l), p.push(s + o, r), p.push(c, u, d, l), p.push(s, r + a), p.push(c, u, d, l), p.push(s + o, r + a), p.push(c, u, d, l), f.push(g, g, g + 1, g + 2, g + 3, g + 3)
                    }
                    if (t.lineWidth) {
                        var m = t.points;
                        t.points = [s, r, s + o, r, s + o, r + a, s, r + a, s, r], PIXI.WebGLGraphics.buildLine(t, e), t.points = m
                    }
                }, PIXI.WebGLGraphics.buildRoundedRectangle = function(t, e) {
                    var i = t.shape,
                        s = i.x,
                        r = i.y,
                        o = i.width,
                        a = i.height,
                        h = i.radius,
                        l = [];
                    if (l.push(s, r + h), l = (l = (l = (l = l.concat(PIXI.WebGLGraphics.quadraticBezierCurve(s, r + a - h, s, r + a, s + h, r + a))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + o - h, r + a, s + o, r + a, s + o, r + a - h))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + o, r + h, s + o, r, s + o - h, r))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + h, r, s, r, s, r + h)), t.fill) {
                        var c = n.Color.hexToRGBArray(t.fillColor),
                            u = t.fillAlpha,
                            d = c[0] * u,
                            p = c[1] * u,
                            f = c[2] * u,
                            g = e.points,
                            m = e.indices,
                            y = g.length / 6,
                            v = n.EarCut.Triangulate(l, null, 2),
                            x = 0;
                        for (x = 0; x < v.length; x += 3) m.push(v[x] + y), m.push(v[x] + y), m.push(v[x + 1] + y), m.push(v[x + 2] + y), m.push(v[x + 2] + y);
                        for (x = 0; x < l.length; x++) g.push(l[x], l[++x], d, p, f, u)
                    }
                    if (t.lineWidth) {
                        var b = t.points;
                        t.points = l, PIXI.WebGLGraphics.buildLine(t, e), t.points = b
                    }
                }, PIXI.WebGLGraphics.quadraticBezierCurve = function(t, e, i, s, n, r) {
                    var o, a, h, l, c, u, d = [];

                    function p(t, e, i) {
                        return t + (e - t) * i
                    }
                    for (var f = 0, g = 0; g <= 20; g++) o = p(t, i, f = g / 20), a = p(e, s, f), h = p(i, n, f), l = p(s, r, f), c = p(o, h, f), u = p(a, l, f), d.push(c, u);
                    return d
                }, PIXI.WebGLGraphics.buildCircle = function(t, e) {
                    var i, s, r = t.shape,
                        o = r.x,
                        a = r.y;
                    t.type === n.CIRCLE ? (i = r.radius, s = r.radius) : (i = r.width, s = r.height);
                    var h = 2 * Math.PI / 40,
                        l = 0;
                    if (t.fill) {
                        var c = n.Color.hexToRGBArray(t.fillColor),
                            u = t.fillAlpha,
                            d = c[0] * u,
                            p = c[1] * u,
                            f = c[2] * u,
                            g = e.points,
                            m = e.indices,
                            y = g.length / 6;
                        for (m.push(y), l = 0; l < 41; l++) g.push(o, a, d, p, f, u), g.push(o + Math.sin(h * l) * i, a + Math.cos(h * l) * s, d, p, f, u), m.push(y++, y++);
                        m.push(y - 1)
                    }
                    if (t.lineWidth) {
                        var v = t.points;
                        for (t.points = [], l = 0; l < 41; l++) t.points.push(o + Math.sin(h * l) * i, a + Math.cos(h * l) * s);
                        PIXI.WebGLGraphics.buildLine(t, e), t.points = v
                    }
                }, PIXI.WebGLGraphics.buildLine = function(t, e) {
                    var i = 0,
                        s = t.points;
                    if (0 !== s.length) {
                        if (t.lineWidth % 2)
                            for (i = 0; i < s.length; i++) s[i] += .5;
                        var r = new PIXI.Point(s[0], s[1]),
                            o = new PIXI.Point(s[s.length - 2], s[s.length - 1]);
                        if (r.x === o.x && r.y === o.y) {
                            (s = s.slice()).pop(), s.pop();
                            var a = (o = new PIXI.Point(s[s.length - 2], s[s.length - 1])).x + .5 * (r.x - o.x),
                                h = o.y + .5 * (r.y - o.y);
                            s.unshift(a, h), s.push(a, h)
                        }
                        var l, c, u, d, p, f, g, m, y, v, x, b, _, T, w, S, C, E, P, A, M, k, R = e.points,
                            O = e.indices,
                            I = s.length / 2,
                            L = s.length,
                            B = R.length / 6,
                            D = t.lineWidth / 2,
                            F = n.Color.hexToRGBArray(t.lineColor),
                            U = t.lineAlpha,
                            N = F[0] * U,
                            G = F[1] * U,
                            j = F[2] * U;
                        for (u = s[0], d = s[1], p = s[2], y = -(d - (f = s[3])), v = u - p, y /= k = Math.sqrt(y * y + v * v), v /= k, y *= D, v *= D, R.push(u - y, d - v, N, G, j, U), R.push(u + y, d + v, N, G, j, U), i = 1; i < I - 1; i++) u = s[2 * (i - 1)], d = s[2 * (i - 1) + 1], p = s[2 * i], f = s[2 * i + 1], g = s[2 * (i + 1)], m = s[2 * (i + 1) + 1], y = -(d - f), v = u - p, y /= k = Math.sqrt(y * y + v * v), v /= k, y *= D, v *= D, x = -(f - m), b = p - g, x /= k = Math.sqrt(x * x + b * b), b /= k, C = (-y + u) * (-v + f) - (-y + p) * (-v + d), A = (-(x *= D) + g) * (-(b *= D) + f) - (-x + p) * (-b + m), M = (w = -v + d - (-v + f)) * (P = -x + p - (-x + g)) - (E = -b + m - (-b + f)) * (S = -y + p - (-y + u)), Math.abs(M) < .1 ? (M += 10.1, R.push(p - y, f - v, N, G, j, U), R.push(p + y, f + v, N, G, j, U)) : ((l = (S * A - P * C) / M) - p) * (l - p) + ((c = (E * C - w * A) / M) - f) + (c - f) > 19600 ? (_ = y - x, T = v - b, _ /= k = Math.sqrt(_ * _ + T * T), T /= k, _ *= D, T *= D, R.push(p - _, f - T), R.push(N, G, j, U), R.push(p + _, f + T), R.push(N, G, j, U), R.push(p - _, f - T), R.push(N, G, j, U), L++) : (R.push(l, c), R.push(N, G, j, U), R.push(p - (l - p), f - (c - f)), R.push(N, G, j, U));
                        for (u = s[2 * (I - 2)], d = s[2 * (I - 2) + 1], p = s[2 * (I - 1)], y = -(d - (f = s[2 * (I - 1) + 1])), v = u - p, y /= k = Math.sqrt(y * y + v * v), v /= k, y *= D, v *= D, R.push(p - y, f - v), R.push(N, G, j, U), R.push(p + y, f + v), R.push(N, G, j, U), O.push(B), i = 0; i < L; i++) O.push(B++);
                        O.push(B - 1)
                    }
                }, PIXI.WebGLGraphics.buildComplexPoly = function(t, e) {
                    var i = t.points.slice();
                    if (!(i.length < 6)) {
                        var s = e.indices;
                        e.points = i, e.alpha = t.fillAlpha, e.color = n.Color.hexToRGBArray(t.fillColor);
                        for (var r, o, a = 1 / 0, h = -1 / 0, l = 1 / 0, c = -1 / 0, u = 0; u < i.length; u += 2) r = i[u], o = i[u + 1], a = r < a ? r : a, h = r > h ? r : h, l = o < l ? o : l, c = o > c ? o : c;
                        i.push(a, l, h, l, h, c, a, c);
                        var d = i.length / 2;
                        for (u = 0; u < d; u++) s.push(u)
                    }
                }, PIXI.WebGLGraphics.buildPoly = function(t, e) {
                    var i = t.points;
                    if (!(i.length < 6)) {
                        var s = e.points,
                            r = e.indices,
                            o = i.length / 2,
                            a = n.Color.hexToRGBArray(t.fillColor),
                            h = t.fillAlpha,
                            l = a[0] * h,
                            c = a[1] * h,
                            u = a[2] * h,
                            d = n.EarCut.Triangulate(i, null, 2);
                        if (!d) return !1;
                        var p = s.length / 6,
                            f = 0;
                        for (f = 0; f < d.length; f += 3) r.push(d[f] + p), r.push(d[f] + p), r.push(d[f + 1] + p), r.push(d[f + 2] + p), r.push(d[f + 2] + p);
                        for (f = 0; f < o; f++) s.push(i[2 * f], i[2 * f + 1], l, c, u, h);
                        return !0
                    }
                }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function(t) {
                    this.gl = t, this.color = [0, 0, 0], this.points = [], this.indices = [], this.buffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0
                }, PIXI.WebGLGraphicsData.prototype.reset = function() {
                    this.points = [], this.indices = []
                }, PIXI.WebGLGraphicsData.prototype.upload = function() {
                    var t = this.gl;
                    this.glPoints = new Float32Array(this.points), t.bindBuffer(t.ARRAY_BUFFER, this.buffer), t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW), this.glIndicies = new Uint16Array(this.indices), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndicies, t.STATIC_DRAW), this.dirty = !1
                }, PIXI.CanvasGraphics = function() {}, PIXI.CanvasGraphics.renderGraphics = function(t, e) {
                    var i = t.worldAlpha;
                    t.dirty && (this.updateGraphicsTint(t), t.dirty = !1);
                    for (var s = 0; s < t.graphicsData.length; s++) {
                        var r = t.graphicsData[s],
                            o = r.shape,
                            a = r._fillTint,
                            h = r._lineTint;
                        if (e.lineWidth = r.lineWidth, r.type === n.POLYGON) {
                            e.beginPath();
                            var l = o.points;
                            e.moveTo(l[0], l[1]);
                            for (var c = 1; c < l.length / 2; c++) e.lineTo(l[2 * c], l[2 * c + 1]);
                            o.closed && e.lineTo(l[0], l[1]), l[0] === l[l.length - 2] && l[1] === l[l.length - 1] && e.closePath(), r.fill && (e.globalAlpha = r.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fill()), r.lineWidth && (e.globalAlpha = r.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), e.stroke())
                        } else if (r.type === n.RECTANGLE)(r.fillColor || 0 === r.fillColor) && (e.globalAlpha = r.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fillRect(o.x, o.y, o.width, o.height)), r.lineWidth && (e.globalAlpha = r.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), e.strokeRect(o.x, o.y, o.width, o.height));
                        else if (r.type === n.CIRCLE) e.beginPath(), e.arc(o.x, o.y, o.radius, 0, 2 * Math.PI), e.closePath(), r.fill && (e.globalAlpha = r.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fill()), r.lineWidth && (e.globalAlpha = r.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), e.stroke());
                        else if (r.type === n.ELLIPSE) {
                            var u = 2 * o.width,
                                d = 2 * o.height,
                                p = o.x - u / 2,
                                f = o.y - d / 2;
                            e.beginPath();
                            var g = u / 2 * .5522848,
                                m = d / 2 * .5522848,
                                y = p + u,
                                v = f + d,
                                x = p + u / 2,
                                b = f + d / 2;
                            e.moveTo(p, b), e.bezierCurveTo(p, b - m, x - g, f, x, f), e.bezierCurveTo(x + g, f, y, b - m, y, b), e.bezierCurveTo(y, b + m, x + g, v, x, v), e.bezierCurveTo(x - g, v, p, b + m, p, b), e.closePath(), r.fill && (e.globalAlpha = r.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fill()), r.lineWidth && (e.globalAlpha = r.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), e.stroke())
                        } else if (r.type === n.ROUNDEDRECTANGLE) {
                            var _ = o.x,
                                T = o.y,
                                w = o.width,
                                S = o.height,
                                C = o.radius,
                                E = Math.min(w, S) / 2 | 0;
                            C = C > E ? E : C, e.beginPath(), e.moveTo(_, T + C), e.lineTo(_, T + S - C), e.quadraticCurveTo(_, T + S, _ + C, T + S), e.lineTo(_ + w - C, T + S), e.quadraticCurveTo(_ + w, T + S, _ + w, T + S - C), e.lineTo(_ + w, T + C), e.quadraticCurveTo(_ + w, T, _ + w - C, T), e.lineTo(_ + C, T), e.quadraticCurveTo(_, T, _, T + C), e.closePath(), (r.fillColor || 0 === r.fillColor) && (e.globalAlpha = r.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fill()), r.lineWidth && (e.globalAlpha = r.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), e.stroke())
                        }
                    }
                }, PIXI.CanvasGraphics.renderGraphicsMask = function(t, e) {
                    var i = t.graphicsData.length;
                    if (0 !== i) {
                        e.beginPath();
                        for (var s = 0; s < i; s++) {
                            var r = t.graphicsData[s],
                                o = r.shape;
                            if (r.type === n.POLYGON) {
                                var a = o.points;
                                e.moveTo(a[0], a[1]);
                                for (var h = 1; h < a.length / 2; h++) e.lineTo(a[2 * h], a[2 * h + 1]);
                                a[0] === a[a.length - 2] && a[1] === a[a.length - 1] && e.closePath()
                            } else if (r.type === n.RECTANGLE) e.rect(o.x, o.y, o.width, o.height), e.closePath();
                            else if (r.type === n.CIRCLE) e.arc(o.x, o.y, o.radius, 0, 2 * Math.PI), e.closePath();
                            else if (r.type === n.ELLIPSE) {
                                var l = 2 * o.width,
                                    c = 2 * o.height,
                                    u = o.x - l / 2,
                                    d = o.y - c / 2,
                                    p = l / 2 * .5522848,
                                    f = c / 2 * .5522848,
                                    g = u + l,
                                    m = d + c,
                                    y = u + l / 2,
                                    v = d + c / 2;
                                e.moveTo(u, v), e.bezierCurveTo(u, v - f, y - p, d, y, d), e.bezierCurveTo(y + p, d, g, v - f, g, v), e.bezierCurveTo(g, v + f, y + p, m, y, m), e.bezierCurveTo(y - p, m, u, v + f, u, v), e.closePath()
                            } else if (r.type === n.ROUNDEDRECTANGLE) {
                                var x = o.x,
                                    b = o.y,
                                    _ = o.width,
                                    T = o.height,
                                    w = o.radius,
                                    S = Math.min(_, T) / 2 | 0;
                                w = w > S ? S : w, e.moveTo(x, b + w), e.lineTo(x, b + T - w), e.quadraticCurveTo(x, b + T, x + w, b + T), e.lineTo(x + _ - w, b + T), e.quadraticCurveTo(x + _, b + T, x + _, b + T - w), e.lineTo(x + _, b + w), e.quadraticCurveTo(x + _, b, x + _ - w, b), e.lineTo(x + w, b), e.quadraticCurveTo(x, b, x, b + w), e.closePath()
                            }
                        }
                    }
                }, PIXI.CanvasGraphics.updateGraphicsTint = function(t) {
                    if (16777215 !== t.tint)
                        for (var e = (t.tint >> 16 & 255) / 255, i = (t.tint >> 8 & 255) / 255, s = (255 & t.tint) / 255, n = 0; n < t.graphicsData.length; n++) {
                            var r = t.graphicsData[n],
                                o = 0 | r.fillColor,
                                a = 0 | r.lineColor;
                            r._fillTint = ((o >> 16 & 255) / 255 * e * 255 << 16) + ((o >> 8 & 255) / 255 * i * 255 << 8) + (255 & o) / 255 * s * 255, r._lineTint = ((a >> 16 & 255) / 255 * e * 255 << 16) + ((a >> 8 & 255) / 255 * i * 255 << 8) + (255 & a) / 255 * s * 255
                        }
                }, n.GraphicsData = function(t, e, i, s, n, r, o) {
                    this.lineWidth = t, this.lineColor = e, this.lineAlpha = i, this._lineTint = e, this.fillColor = s, this.fillAlpha = n, this._fillTint = s, this.fill = r, this.shape = o, this.type = o.type
                }, n.GraphicsData.prototype.constructor = n.GraphicsData, n.GraphicsData.prototype.clone = function() {
                    return new n.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape)
                }, n.Graphics = function(t, e, i) {
                    void 0 === e && (e = 0), void 0 === i && (i = 0), this.type = n.GRAPHICS, this.physicsType = n.SPRITE, this.anchor = new n.Point, PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, this._localBounds = new n.Rectangle(0, 0, 1, 1), this.dirty = !0, this._boundsDirty = !1, this.webGLDirty = !1, this.cachedSpriteDirty = !1, n.Component.Core.init.call(this, t, e, i, "", null)
                }, n.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), n.Graphics.prototype.constructor = n.Graphics, n.Component.Core.install.call(n.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), n.Graphics.prototype.preUpdatePhysics = n.Component.PhysicsBody.preUpdate, n.Graphics.prototype.preUpdateLifeSpan = n.Component.LifeSpan.preUpdate, n.Graphics.prototype.preUpdateInWorld = n.Component.InWorld.preUpdate, n.Graphics.prototype.preUpdateCore = n.Component.Core.preUpdate, n.Graphics.prototype.preUpdate = function() {
                    return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                }, n.Graphics.prototype.postUpdate = function() {
                    n.Component.PhysicsBody.postUpdate.call(this), n.Component.FixedToCamera.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1);
                    for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
                }, n.Graphics.prototype.destroy = function(t) {
                    this.clear(), n.Component.Destroy.prototype.destroy.call(this, t)
                }, n.Graphics.prototype.drawTriangle = function(t, e) {
                    void 0 === e && (e = !1);
                    var i = new n.Polygon(t);
                    if (e) {
                        var s = new n.Point(this.game.camera.x - t[0].x, this.game.camera.y - t[0].y),
                            r = new n.Point(t[1].x - t[0].x, t[1].y - t[0].y),
                            o = new n.Point(t[1].x - t[2].x, t[1].y - t[2].y).cross(r);
                        s.dot(o) > 0 && this.drawPolygon(i)
                    } else this.drawPolygon(i)
                }, n.Graphics.prototype.drawTriangles = function(t, e, i) {
                    void 0 === i && (i = !1);
                    var s, r = new n.Point,
                        o = new n.Point,
                        a = new n.Point,
                        h = [];
                    if (e)
                        if (t[0] instanceof n.Point)
                            for (s = 0; s < e.length / 3; s++) h.push(t[e[3 * s]]), h.push(t[e[3 * s + 1]]), h.push(t[e[3 * s + 2]]), 3 === h.length && (this.drawTriangle(h, i), h = []);
                        else
                            for (s = 0; s < e.length; s++) r.x = t[2 * e[s]], r.y = t[2 * e[s] + 1], h.push(r.copyTo({})), 3 === h.length && (this.drawTriangle(h, i), h = []);
                    else if (t[0] instanceof n.Point)
                        for (s = 0; s < t.length / 3; s++) this.drawTriangle([t[3 * s], t[3 * s + 1], t[3 * s + 2]], i);
                    else
                        for (s = 0; s < t.length / 6; s++) r.x = t[6 * s + 0], r.y = t[6 * s + 1], o.x = t[6 * s + 2], o.y = t[6 * s + 3], a.x = t[6 * s + 4], a.y = t[6 * s + 5], this.drawTriangle([r, o, a], i)
                }, n.Graphics.prototype.lineStyle = function(t, e, i) {
                    return this.lineWidth = t || 0, this.lineColor = e || 0, this.lineAlpha = void 0 === i ? 1 : i, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new n.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this
                }, n.Graphics.prototype.moveTo = function(t, e) {
                    return this.drawShape(new n.Polygon([t, e])), this
                }, n.Graphics.prototype.lineTo = function(t, e) {
                    return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(t, e), this.dirty = !0, this._boundsDirty = !0, this
                }, n.Graphics.prototype.quadraticCurveTo = function(t, e, i, s) {
                    this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
                    var n, r, o = this.currentPath.shape.points;
                    0 === o.length && this.moveTo(0, 0);
                    for (var a = o[o.length - 2], h = o[o.length - 1], l = 0, c = 1; c <= 20; ++c) n = a + (t - a) * (l = c / 20), r = h + (e - h) * l, o.push(n + (t + (i - t) * l - n) * l, r + (e + (s - e) * l - r) * l);
                    return this.dirty = !0, this._boundsDirty = !0, this
                }, n.Graphics.prototype.bezierCurveTo = function(t, e, i, s, n, r) {
                    this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
                    for (var o, a, h, l, c, u = this.currentPath.shape.points, d = u[u.length - 2], p = u[u.length - 1], f = 0, g = 1; g <= 20; ++g) h = (a = (o = 1 - (f = g / 20)) * o) * o, c = (l = f * f) * f, u.push(h * d + 3 * a * f * t + 3 * o * l * i + c * n, h * p + 3 * a * f * e + 3 * o * l * s + c * r);
                    return this.dirty = !0, this._boundsDirty = !0, this
                }, n.Graphics.prototype.arcTo = function(t, e, i, s, n) {
                    this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(t, e) : this.moveTo(t, e);
                    var r = this.currentPath.shape.points,
                        o = r[r.length - 2],
                        a = r[r.length - 1] - e,
                        h = o - t,
                        l = s - e,
                        c = i - t,
                        u = Math.abs(a * c - h * l);
                    if (u < 1e-8 || 0 === n) r[r.length - 2] === t && r[r.length - 1] === e || r.push(t, e);
                    else {
                        var d = a * a + h * h,
                            p = l * l + c * c,
                            f = a * l + h * c,
                            g = n * Math.sqrt(d) / u,
                            m = n * Math.sqrt(p) / u,
                            y = g * f / d,
                            v = m * f / p,
                            x = g * c + m * h,
                            b = g * l + m * a,
                            _ = h * (m + y),
                            T = a * (m + y),
                            w = c * (g + v),
                            S = l * (g + v),
                            C = Math.atan2(T - b, _ - x),
                            E = Math.atan2(S - b, w - x);
                        this.arc(x + t, b + e, n, C, E, h * l > c * a)
                    }
                    return this.dirty = !0, this._boundsDirty = !0, this
                }, n.Graphics.prototype.arc = function(t, e, i, s, n, r, o) {
                    if (s === n) return this;
                    void 0 === r && (r = !1), void 0 === o && (o = 40), !r && n <= s ? n += 2 * Math.PI : r && s <= n && (s += 2 * Math.PI);
                    var a = r ? -1 * (s - n) : n - s,
                        h = Math.ceil(Math.abs(a) / (2 * Math.PI)) * o;
                    if (0 === a) return this;
                    var l = t + Math.cos(s) * i,
                        c = e + Math.sin(s) * i;
                    r && this.filling ? this.moveTo(t, e) : this.moveTo(l, c);
                    for (var u = this.currentPath.shape.points, d = a / (2 * h), p = 2 * d, f = Math.cos(d), g = Math.sin(d), m = h - 1, y = m % 1 / m, v = 0; v <= m; v++) {
                        var x = d + s + p * (v + y * v),
                            b = Math.cos(x),
                            _ = -Math.sin(x);
                        u.push((f * b + g * _) * i + t, (f * -_ + g * b) * i + e)
                    }
                    return this.dirty = !0, this._boundsDirty = !0, this
                }, n.Graphics.prototype.beginFill = function(t, e) {
                    return this.filling = !0, this.fillColor = t || 0, this.fillAlpha = void 0 === e ? 1 : e, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this
                }, n.Graphics.prototype.endFill = function() {
                    return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this
                }, n.Graphics.prototype.drawRect = function(t, e, i, s) {
                    return this.drawShape(new n.Rectangle(t, e, i, s)), this
                }, n.Graphics.prototype.drawRoundedRect = function(t, e, i, s, r) {
                    return this.drawShape(new n.RoundedRectangle(t, e, i, s, r)), this
                }, n.Graphics.prototype.drawCircle = function(t, e, i) {
                    return this.drawShape(new n.Circle(t, e, i)), this
                }, n.Graphics.prototype.drawEllipse = function(t, e, i, s) {
                    return this.drawShape({
                        x: t,
                        y: e,
                        width: i,
                        height: s,
                        type: n.ELLIPSE
                    }), this
                }, n.Graphics.prototype.drawPolygon = function(t) {
                    t instanceof n.Polygon && (t = t.points);
                    var e = t;
                    if (!Array.isArray(e)) {
                        e = new Array(arguments.length);
                        for (var i = 0; i < e.length; ++i) e[i] = arguments[i]
                    }
                    return this.drawShape(new n.Polygon(e)), this
                }, n.Graphics.prototype.clear = function() {
                    return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this._boundsDirty = !0, this.clearDirty = !0, this.graphicsData = [], this.updateLocalBounds(), this
                }, n.Graphics.prototype.generateTexture = function(t, e, i) {
                    void 0 === t && (t = 1), void 0 === e && (e = PIXI.scaleModes.DEFAULT), void 0 === i && (i = 0);
                    var s = this.getBounds();
                    s.width += i, s.height += i;
                    var n = new PIXI.CanvasBuffer(s.width * t, s.height * t),
                        r = PIXI.Texture.fromCanvas(n.canvas, e);
                    return r.baseTexture.resolution = t, n.context.scale(t, t), n.context.translate(-s.x, -s.y), PIXI.CanvasGraphics.renderGraphics(this, n.context), r
                }, n.Graphics.prototype._renderWebGL = function(t) {
                    if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                        if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, t);
                        if (t.spriteBatch.stop(), t.blendModeManager.setBlendMode(this.blendMode), this._mask && t.maskManager.pushMask(this._mask, t), this._filters && t.filterManager.pushFilter(this._filterBlock), this.blendMode !== t.spriteBatch.currentBlendMode) {
                            t.spriteBatch.currentBlendMode = this.blendMode;
                            var e = PIXI.blendModesWebGL[t.spriteBatch.currentBlendMode];
                            t.spriteBatch.gl.blendFunc(e[0], e[1])
                        }
                        if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, t), this.children.length) {
                            t.spriteBatch.start();
                            for (var i = 0; i < this.children.length; i++) this.children[i]._renderWebGL(t);
                            t.spriteBatch.stop()
                        }
                        this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this.mask, t), t.drawCount++, t.spriteBatch.start()
                    }
                }, n.Graphics.prototype._renderCanvas = function(t) {
                    if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                        if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, t);
                        var e = t.context,
                            i = this.worldTransform;
                        this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t);
                        var s = t.resolution,
                            n = i.tx * t.resolution + t.shakeX,
                            r = i.ty * t.resolution + t.shakeY;
                        e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, n, r), PIXI.CanvasGraphics.renderGraphics(this, e);
                        for (var o = 0; o < this.children.length; o++) this.children[o]._renderCanvas(t);
                        this._mask && t.maskManager.popMask(t)
                    }
                }, n.Graphics.prototype.getBounds = function(t) {
                    if (this._currentBounds) return this._currentBounds;
                    if (this.isMask) return n.EmptyRectangle;
                    this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1);
                    var e = this._localBounds,
                        i = e.x,
                        s = e.width + e.x,
                        r = e.y,
                        o = e.height + e.y,
                        a = t || this.worldTransform,
                        h = a.a,
                        l = a.b,
                        c = a.c,
                        u = a.d,
                        d = a.tx,
                        p = a.ty,
                        f = h * s + c * o + d,
                        g = u * o + l * s + p,
                        m = h * i + c * o + d,
                        y = u * o + l * i + p,
                        v = h * i + c * r + d,
                        x = u * r + l * i + p,
                        b = h * s + c * r + d,
                        _ = u * r + l * s + p,
                        T = f,
                        w = g,
                        S = f,
                        C = g;
                    return S = b < (S = v < (S = m < S ? m : S) ? v : S) ? b : S, C = _ < (C = x < (C = y < C ? y : C) ? x : C) ? _ : C, T = b > (T = v > (T = m > T ? m : T) ? v : T) ? b : T, w = _ > (w = x > (w = y > w ? y : w) ? x : w) ? _ : w, this._bounds.x = S, this._bounds.width = T - S, this._bounds.y = C, this._bounds.height = w - C, this._currentBounds = this._bounds, this._currentBounds
                }, n.Graphics.prototype.getLocalBounds = function() {
                    var t = this.worldTransform;
                    this.worldTransform = n.identityMatrix;
                    for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
                    var i = this.getBounds();
                    for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
                    return i
                }, n.Graphics.prototype.containsPoint = function(t, e) {
                    void 0 === e && (e = new n.Point), this.worldTransform.applyInverse(t, e);
                    for (var i = this.graphicsData, s = 0; s < i.length; s++) {
                        var r = i[s];
                        if (r.fill && (r.shape && r.shape.contains(e.x, e.y))) return !0
                    }
                    return !1
                }, n.Graphics.prototype.getVisualBounds = function(t) {
                    return this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1), this._localBounds.clone(t)
                }, n.Graphics.prototype.updateLocalBounds = function() {
                    var t = 1 / 0,
                        e = -1 / 0,
                        i = 1 / 0,
                        s = -1 / 0;
                    if (this.graphicsData.length)
                        for (var r, o, a, h, l, c, u = 0; u < this.graphicsData.length; u++) {
                            var d = this.graphicsData[u],
                                p = d.type,
                                f = d.lineWidth;
                            if (r = d.shape, p === n.RECTANGLE || p === n.ROUNDEDRECTANGLE) a = r.x - f / 2, h = r.y - f / 2, l = r.width + f, c = r.height + f, t = a < t ? a : t, e = a + l > e ? a + l : e, i = h < i ? h : i, s = h + c > s ? h + c : s;
                            else if (p === n.CIRCLE) a = r.x, h = r.y, l = r.radius + f / 2, c = r.radius + f / 2, t = a - l < t ? a - l : t, e = a + l > e ? a + l : e, i = h - c < i ? h - c : i, s = h + c > s ? h + c : s;
                            else if (p === n.ELLIPSE) a = r.x, h = r.y, l = r.width + f / 2, c = r.height + f / 2, t = a - l < t ? a - l : t, e = a + l > e ? a + l : e, i = h - c < i ? h - c : i, s = h + c > s ? h + c : s;
                            else {
                                o = r.points;
                                for (var g = 0; g < o.length; g++) o[g] instanceof n.Point ? (a = o[g].x, h = o[g].y) : (a = o[g], h = o[g + 1], g < o.length - 1 && g++), t = a - f < t ? a - f : t, e = a + f > e ? a + f : e, i = h - f < i ? h - f : i, s = h + f > s ? h + f : s
                            }
                        } else t = 0, e = 0, i = 0, s = 0;
                    var m = this.boundsPadding;
                    this._localBounds.x = t - m, this._localBounds.width = e - t + 2 * m, this._localBounds.y = i - m, this._localBounds.height = s - i + 2 * m
                }, n.Graphics.prototype._generateCachedSprite = function() {
                    var t = this.getLocalBounds();
                    if (this._cachedSprite) this._cachedSprite.buffer.resize(t.width, t.height);
                    else {
                        var e = new PIXI.CanvasBuffer(t.width, t.height),
                            i = PIXI.Texture.fromCanvas(e.canvas);
                        this._cachedSprite = new PIXI.Sprite(i), this._cachedSprite.buffer = e, this._cachedSprite.worldTransform = this.worldTransform
                    }
                    this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._cachedSprite.buffer.context.translate(-t.x, -t.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha
                }, n.Graphics.prototype.updateCachedSpriteTexture = function() {
                    var t = this._cachedSprite,
                        e = t.texture,
                        i = t.buffer.canvas;
                    e.baseTexture.width = i.width, e.baseTexture.height = i.height, e.crop.width = e.frame.width = i.width, e.crop.height = e.frame.height = i.height, t._width = i.width, t._height = i.height, e.baseTexture.dirty()
                }, n.Graphics.prototype.destroyCachedSprite = function() {
                    this._cachedSprite.texture.destroy(!0), this._cachedSprite = null
                }, n.Graphics.prototype.drawShape = function(t) {
                    this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null, t instanceof n.Polygon && (t = t.clone()).flatten();
                    var e = new n.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, t);
                    return this.graphicsData.push(e), e.type === n.POLYGON && (e.shape.closed = this.filling, this.currentPath = e), this.dirty = !0, this._boundsDirty = !0, e
                }, Object.defineProperty(n.Graphics.prototype, "cacheAsBitmap", {
                    get: function() {
                        return this._cacheAsBitmap
                    },
                    set: function(t) {
                        this._cacheAsBitmap = t, this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), this.dirty = !0, this.webGLDirty = !0
                    }
                }), n.RenderTexture = function(t, e, i, s, r, o, a, h) {
                    if (void 0 === e && (e = 100), void 0 === i && (i = 100), void 0 === s && (s = ""), void 0 === r && (r = n.scaleModes.DEFAULT), void 0 === o && (o = 1), void 0 === a && (a = PIXI.defaultRenderer), void 0 === h && (h = 0), this.game = t, this.key = s, this.type = n.RENDERTEXTURE, this._tempMatrix = new n.Matrix, this.width = e, this.height = i, this.resolution = o, this.frame = new n.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = this.frame.clone(), this.baseTexture = new PIXI.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = r, this.baseTexture.hasLoaded = !0, PIXI.Texture.call(this, this.baseTexture, this.frame.clone()), this.renderer = a, this.renderer.type === n.WEBGL) {
                        var l = this.renderer.gl;
                        this.baseTexture.textureIndex = h, this.baseTexture._dirty[l.id] = !1, this.textureBuffer = new PIXI.FilterTexture(l, this.width, this.height, this.baseTexture.scaleMode, h), this.baseTexture._glTextures[l.id] = this.textureBuffer.texture, this.projection = new n.Point(.5 * this.width, .5 * -this.height)
                    } else this.textureBuffer = new PIXI.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas;
                    this.valid = !0, this.tempMatrix = new n.Matrix, this._updateUvs()
                }, n.RenderTexture.prototype = Object.create(PIXI.Texture.prototype), n.RenderTexture.prototype.constructor = n.RenderTexture, n.RenderTexture.prototype.renderXY = function(t, e, i, s) {
                    t.updateTransform(), this._tempMatrix.copyFrom(t.worldTransform), this._tempMatrix.tx = e, this._tempMatrix.ty = i, this.renderer.type === n.WEBGL ? this._renderWebGL(t, this._tempMatrix, s) : this._renderCanvas(t, this._tempMatrix, s)
                }, n.RenderTexture.prototype.renderRawXY = function(t, e, i, s) {
                    this._tempMatrix.identity().translate(e, i), this.renderer.type === n.WEBGL ? this._renderWebGL(t, this._tempMatrix, s) : this._renderCanvas(t, this._tempMatrix, s)
                }, n.RenderTexture.prototype.render = function(t, e, i) {
                    void 0 === e || null === e ? this._tempMatrix.copyFrom(t.worldTransform) : this._tempMatrix.copyFrom(e), this.renderer.type === n.WEBGL ? this._renderWebGL(t, this._tempMatrix, i) : this._renderCanvas(t, this._tempMatrix, i)
                }, n.RenderTexture.prototype.resize = function(t, e, i) {
                    t === this.width && e === this.height || (this.valid = t > 0 && e > 0, this.width = t, this.height = e, this.frame.width = this.crop.width = t * this.resolution, this.frame.height = this.crop.height = e * this.resolution, i && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === n.WEBGL && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height))
                }, n.RenderTexture.prototype.clear = function() {
                    this.valid && (this.renderer.type === n.WEBGL && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear())
                }, n.RenderTexture.prototype._renderWebGL = function(t, e, i) {
                    if (this.valid && 0 !== t.alpha) {
                        var s = t.worldTransform;
                        s.identity(), s.translate(0, 2 * this.projection.y), e && s.append(e), s.scale(1, -1);
                        for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
                        var r = this.renderer.gl;
                        r.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), r.bindFramebuffer(r.FRAMEBUFFER, this.textureBuffer.frameBuffer), i && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer, e), this.renderer.spriteBatch.dirty = !0, r.bindFramebuffer(r.FRAMEBUFFER, null)
                    }
                }, n.RenderTexture.prototype._renderCanvas = function(t, e, i) {
                    if (this.valid && 0 !== t.alpha) {
                        var s = t.worldTransform;
                        s.identity(), e && s.append(e);
                        for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
                        i && this.textureBuffer.clear();
                        var r = this.renderer.resolution;
                        this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(t, this.textureBuffer.context, e), this.renderer.resolution = r
                    }
                }, n.RenderTexture.prototype.getImage = function() {
                    var t = new Image;
                    return t.src = this.getBase64(), t
                }, n.RenderTexture.prototype.getBase64 = function() {
                    return this.getCanvas().toDataURL()
                }, n.RenderTexture.prototype.getCanvas = function() {
                    if (this.renderer.type === n.WEBGL) {
                        var t = this.renderer.gl,
                            e = this.textureBuffer.width,
                            i = this.textureBuffer.height,
                            s = new Uint8Array(4 * e * i);
                        t.bindFramebuffer(t.FRAMEBUFFER, this.textureBuffer.frameBuffer), t.readPixels(0, 0, e, i, t.RGBA, t.UNSIGNED_BYTE, s), t.bindFramebuffer(t.FRAMEBUFFER, null);
                        var r = new PIXI.CanvasBuffer(e, i),
                            o = r.context.getImageData(0, 0, e, i);
                        return o.data.set(s), r.context.putImageData(o, 0, 0), r.canvas
                    }
                    return this.textureBuffer.canvas
                }, n.Text = function(t, e, i, s, r) {
                    e = e || 0, i = i || 0, s = void 0 === s || null === s ? "" : s.toString(), this.canvas = n.CanvasPool.create(this), n.Sprite.call(this, t, e, i, PIXI.Texture.fromCanvas(this.canvas)), this.type = n.TEXT, this.physicsType = n.SPRITE, this.padding = new n.Point, this.textBounds = null, this.context = this.canvas.getContext("2d"), this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], this.autoRound = !1, this.useAdvancedWrap = !1, this.splitRegExp = /(?:\r\n|\r|\n)/, this.characterLimitSize = -1, this.characterLimitSuffix = "", this._testString = "|Mq", this._res = t.renderer.resolution, this._text = s, this._fontComponents = null, this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, this.style = {}, this.setStyle(r || {}), "" !== s && this.updateText()
                }, n.Text.prototype = Object.create(n.Sprite.prototype), n.Text.prototype.constructor = n.Text, n.Text.prototype.preUpdate = function() {
                    return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                }, n.Text.prototype.update = function() {}, n.Text.prototype.destroy = function(t) {
                    this.texture.destroy(!0), n.Component.Destroy.prototype.destroy.call(this, t)
                }, n.Text.prototype.setShadow = function(t, e, i, s, n, r) {
                    return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = "rgba(0, 0, 0, 1)"), void 0 === s && (s = 0), void 0 === n && (n = !0), void 0 === r && (r = !0), this.style.shadowOffsetX = t, this.style.shadowOffsetY = e, this.style.shadowColor = i, this.style.shadowBlur = s, this.style.shadowStroke = n, this.style.shadowFill = r, this.dirty = !0, this
                }, n.Text.prototype.setStyle = function(t, e) {
                    void 0 === e && (e = !1);
                    var i = Object.assign({}, t);
                    i.font = t.font || "bold 20pt Arial", i.backgroundColor = t.backgroundColor || null, i.fill = t.fill || "black", i.align = (t.align || "left").toLowerCase(), i.boundsAlignH = (t.boundsAlignH || "left").toLowerCase(), i.boundsAlignV = (t.boundsAlignV || "top").toLowerCase(), i.stroke = t.stroke || "black", i.strokeThickness = Number(t.strokeThickness) || 0, i.wordWrap = t.wordWrap || !1, i.wordWrapWidth = t.wordWrapWidth || 100, i.maxLines = t.maxLines || 0, i.shadowOffsetX = t.shadowOffsetX || 0, i.shadowOffsetY = t.shadowOffsetY || 0, i.shadowColor = t.shadowColor || "rgba(0,0,0,0)", i.shadowBlur = t.shadowBlur || 0, i.tabs = t.tabs || 0;
                    var s = this.fontToComponents(i.font);
                    return i.fontStyle && (s.fontStyle = i.fontStyle), i.fontVariant && (s.fontVariant = i.fontVariant), i.fontWeight && (s.fontWeight = i.fontWeight), i.fontSize && ("number" == typeof i.fontSize && (i.fontSize = i.fontSize + "px"), s.fontSize = i.fontSize), this._fontComponents = s, i.font = this.componentsToFont(this._fontComponents), this.style = i, this.dirty = !0, e && this.updateText(), this
                }, n.Text.prototype.updateText = function() {
                    this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
                    var t = this.text;
                    this.characterLimitSize > -1 && this.characterLimitSize < t.length && (t = this.text.substring(0, this.characterLimitSize) + this.characterLimitSuffix), this.style.wordWrap && (t = this.runWordWrap(this.text));
                    var e = t.split(this.splitRegExp),
                        i = this.style.tabs,
                        s = [],
                        n = 0,
                        r = this.determineFontProperties(this.style.font),
                        o = e.length;
                    this.style.maxLines > 0 && this.style.maxLines < e.length && (o = this.style.maxLines), this._charCount = 0;
                    for (var a = 0; a < o; a++) {
                        if (0 === i) {
                            var h = this.style.strokeThickness + this.padding.x;
                            this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? h += this.measureLine(e[a]) : h += this.context.measureText(e[a]).width, this.style.wordWrap && (h -= this.context.measureText(" ").width)
                        } else {
                            var l = e[a].split(/(?:\t)/);
                            h = this.padding.x + this.style.strokeThickness;
                            if (Array.isArray(i))
                                for (var c = 0, u = 0; u < l.length; u++) {
                                    var d = 0;
                                    d = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(l[u]) : Math.ceil(this.context.measureText(l[u]).width), u > 0 && (c += i[u - 1]), h = c + d
                                } else
                                    for (u = 0; u < l.length; u++) {
                                        this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? h += this.measureLine(l[u]) : h += Math.ceil(this.context.measureText(l[u]).width), h += this.game.math.snapToCeil(h, i) - h
                                    }
                        }
                        s[a] = Math.ceil(h), n = Math.max(n, s[a])
                    }
                    this.canvas.width = n * this._res;
                    var p, f, g = r.fontSize + this.style.strokeThickness + this.padding.y,
                        m = g * o,
                        y = this._lineSpacing;
                    for (y < 0 && Math.abs(y) > g && (y = -g), 0 !== y && (m += y > 0 ? y * e.length : y * (e.length - 1)), this.canvas.height = m * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round", this._charCount = 0, a = 0; a < o; a++) p = this.style.strokeThickness / 2, f = this.style.strokeThickness / 2 + a * g + r.ascent, a > 0 && (f += y * a), "right" === this.style.align ? p += n - s[a] : "center" === this.style.align && (p += (n - s[a]) / 2), this.autoRound && (p = Math.round(p), f = Math.round(f)), this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.updateLine(e[a], p, f) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === i ? this.context.strokeText(e[a], p, f) : this.renderTabLine(e[a], p, f, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === i ? this.context.fillText(e[a], p, f) : this.renderTabLine(e[a], p, f, !0)));
                    this.updateTexture(), this.dirty = !1
                }, n.Text.prototype.renderTabLine = function(t, e, i, s) {
                    var n = t.split(/(?:\t)/),
                        r = this.style.tabs,
                        o = 0;
                    if (Array.isArray(r))
                        for (var a = 0, h = 0; h < n.length; h++) h > 0 && (a += r[h - 1]), o = e + a, s ? this.context.fillText(n[h], o, i) : this.context.strokeText(n[h], o, i);
                    else
                        for (h = 0; h < n.length; h++) {
                            var l = Math.ceil(this.context.measureText(n[h]).width);
                            o = this.game.math.snapToCeil(e, r), s ? this.context.fillText(n[h], o, i) : this.context.strokeText(n[h], o, i), e = o + l
                        }
                }, n.Text.prototype.updateShadow = function(t) {
                    t ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0, this.context.shadowBlur = 0)
                }, n.Text.prototype.measureLine = function(t) {
                    for (var e = 0, i = 0; i < t.length; i++) {
                        var s = t[i];
                        if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                            var n = this.fontToComponents(this.context.font);
                            this.fontStyles[this._charCount] && (n.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (n.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(n)
                        }
                        this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)), e += this.context.measureText(s).width, this._charCount++
                    }
                    return Math.ceil(e)
                }, n.Text.prototype.updateLine = function(t, e, i) {
                    for (var s = 0; s < t.length; s++) {
                        var n = t[s];
                        if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                            var r = this.fontToComponents(this.context.font);
                            this.fontStyles[this._charCount] && (r.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (r.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(r)
                        }
                        this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(n, e, i)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(n, e, i)), e += this.context.measureText(n).width, this._charCount++
                    }
                }, n.Text.prototype.clearColors = function() {
                    return this.colors = [], this.strokeColors = [], this.dirty = !0, this
                }, n.Text.prototype.clearFontValues = function() {
                    return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this
                }, n.Text.prototype.addColor = function(t, e) {
                    return this.colors[e] = t, this.dirty = !0, this
                }, n.Text.prototype.addStrokeColor = function(t, e) {
                    return this.strokeColors[e] = t, this.dirty = !0, this
                }, n.Text.prototype.addFontStyle = function(t, e) {
                    return this.fontStyles[e] = t, this.dirty = !0, this
                }, n.Text.prototype.addFontWeight = function(t, e) {
                    return this.fontWeights[e] = t, this.dirty = !0, this
                }, n.Text.prototype.precalculateWordWrap = function(t) {
                    return this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font, this.runWordWrap(t).split(/(?:\r\n|\r|\n)/)
                }, n.Text.prototype.runWordWrap = function(t) {
                    return this.useAdvancedWrap ? this.advancedWordWrap(t) : this.basicWordWrap(t)
                }, n.Text.prototype.advancedWordWrap = function(t) {
                    for (var e = this.context, i = this.style.wordWrapWidth, s = "", n = t.replace(/ +/gi, " ").split(/\r?\n/gi), r = n.length, o = 0; o < r; o++) {
                        var a = n[o],
                            h = "";
                        if (a = a.replace(/^ *|\s*$/gi, ""), e.measureText(a).width < i) s += a + "\n";
                        else {
                            for (var l = i, c = a.split(" "), u = 0; u < c.length; u++) {
                                var d = c[u],
                                    p = d + " ",
                                    f = e.measureText(p).width;
                                if (f > l) {
                                    if (0 === u) {
                                        for (var g = p; g.length && (g = g.slice(0, -1), !((f = e.measureText(g).width) <= l)););
                                        if (!g.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                                        var m = d.substr(g.length);
                                        c[u] = m, h += g
                                    }
                                    var y = c[u].length ? u : u + 1,
                                        v = c.slice(y).join(" ").replace(/[ \n]*$/gi, "");
                                    n[o + 1] = v + " " + (n[o + 1] || ""), r = n.length;
                                    break
                                }
                                h += p, l -= f
                            }
                            s += h.replace(/[ \n]*$/gi, "") + "\n"
                        }
                    }
                    return s = s.replace(/[\s|\n]*$/gi, "")
                }, n.Text.prototype.basicWordWrap = function(t) {
                    for (var e = "", i = t.split("\n"), s = 0; s < i.length; s++) {
                        for (var n = this.style.wordWrapWidth, r = i[s].split(" "), o = 0; o < r.length; o++) {
                            var a = this.context.measureText(r[o]).width,
                                h = a + this.context.measureText(" ").width;
                            h > n ? (o > 0 && (e += "\n"), e += r[o] + " ", n = this.style.wordWrapWidth - a) : (n -= h, e += r[o] + " ")
                        }
                        s < i.length - 1 && (e += "\n")
                    }
                    return e
                }, n.Text.prototype.updateFont = function(t) {
                    var e = this.componentsToFont(t);
                    this.style.font !== e && (this.style.font = e, this.dirty = !0, this.parent && this.updateTransform())
                }, n.Text.prototype.fontToComponents = function(t) {
                    var e = t.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
                    if (e) {
                        var i = e[5].trim();
                        return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(i) || /['",]/.exec(i) || (i = "'" + i + "'"), {
                            font: t,
                            fontStyle: e[1] || "normal",
                            fontVariant: e[2] || "normal",
                            fontWeight: e[3] || "normal",
                            fontSize: e[4] || "medium",
                            fontFamily: i
                        }
                    }
                    return console.warn("Phaser.Text - unparsable CSS font: " + t), {
                        font: t
                    }
                }, n.Text.prototype.componentsToFont = function(t) {
                    var e, i = [];
                    return (e = t.fontStyle) && "normal" !== e && i.push(e), (e = t.fontVariant) && "normal" !== e && i.push(e), (e = t.fontWeight) && "normal" !== e && i.push(e), (e = t.fontSize) && "medium" !== e && i.push(e), (e = t.fontFamily) && i.push(e), i.length || i.push(t.font), i.join(" ")
                }, n.Text.prototype.setText = function(t, e) {
                    return void 0 === e && (e = !1), (t = t.toString() || "") === this._text ? this : (this.text = t, e ? this.updateText() : this.dirty = !0, this)
                }, n.Text.prototype.parseList = function(t) {
                    if (!Array.isArray(t)) return this;
                    for (var e = "", i = 0; i < t.length; i++) Array.isArray(t[i]) ? (e += t[i].join("\t"), i < t.length - 1 && (e += "\n")) : (e += t[i], i < t.length - 1 && (e += "\t"));
                    return this.text = e, this.dirty = !0, this
                }, n.Text.prototype.setTextBounds = function(t, e, i, s) {
                    return void 0 === t ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(t, e, i, s) : this.textBounds = new n.Rectangle(t, e, i, s), this.style.wordWrapWidth > i && (this.style.wordWrapWidth = i)), this.updateTexture(), this
                }, n.Text.prototype.updateTexture = function() {
                    var t = this.texture.baseTexture,
                        e = this.texture.crop,
                        i = this.texture.frame,
                        s = this.canvas.width,
                        n = this.canvas.height;
                    if (t.width = s, t.height = n, e.width = s, e.height = n, i.width = s, i.height = n, this.texture.width = s, this.texture.height = n, this._width = s, this._height = n, this.textBounds) {
                        var r = this.textBounds.x,
                            o = this.textBounds.y;
                        "right" === this.style.boundsAlignH ? r += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (r += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2), "bottom" === this.style.boundsAlignV ? o += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (o += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2), this.pivot.x = -r, this.pivot.y = -o
                    }
                    this.renderable = 0 !== s && 0 !== n, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty()
                }, n.Text.prototype._renderWebGL = function(t) {
                    this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderWebGL.call(this, t)
                }, n.Text.prototype._renderCanvas = function(t) {
                    this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, t)
                }, n.Text.prototype.determineFontProperties = function(t) {
                    var e = n.Text.fontPropertiesCache[t],
                        i = this.testString || "|Mq";
                    if (!e) {
                        e = {};
                        var s = n.Text.fontPropertiesCanvas,
                            r = n.Text.fontPropertiesContext;
                        r.font = t;
                        var o = Math.ceil(r.measureText(i).width),
                            a = Math.ceil(r.measureText(i).width),
                            h = 2 * a;
                        if (a = 1.4 * a | 0, s.width = o, s.height = h, r.fillStyle = "#f00", r.fillRect(0, 0, o, h), r.font = t, r.textBaseline = "alphabetic", r.fillStyle = "#000", r.fillText(i, 0, a), !r.getImageData(0, 0, o, h)) return e.ascent = a, e.descent = a + 6, e.fontSize = e.ascent + e.descent, n.Text.fontPropertiesCache[t] = e, e;
                        var l, c, u = r.getImageData(0, 0, o, h).data,
                            d = u.length,
                            p = 4 * o,
                            f = 0,
                            g = !1;
                        for (l = 0; l < a; l++) {
                            for (c = 0; c < p; c += 4)
                                if (255 !== u[f + c]) {
                                    g = !0;
                                    break
                                } if (g) break;
                            f += p
                        }
                        for (e.ascent = a - l, f = d - p, g = !1, l = h; l > a; l--) {
                            for (c = 0; c < p; c += 4)
                                if (255 !== u[f + c]) {
                                    g = !0;
                                    break
                                } if (g) break;
                            f -= p
                        }
                        e.descent = l - a, e.descent += 6, e.fontSize = e.ascent + e.descent, n.Text.fontPropertiesCache[t] = e
                    }
                    return e
                }, n.Text.prototype.getBounds = function(t) {
                    return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, t)
                }, n.Text.prototype.setCharacterLimit = function(t, e) {
                    this.characterLimitSuffix = void 0 === e ? "" : e, this.characterLimitSize = t, this.updateText()
                }, Object.defineProperty(n.Text.prototype, "text", {
                    get: function() {
                        return this._text
                    },
                    set: function(t) {
                        t !== this._text && (this._text = t.toString() || "", this.dirty = !0, this.parent && this.updateTransform())
                    }
                }), Object.defineProperty(n.Text.prototype, "cssFont", {
                    get: function() {
                        return this.componentsToFont(this._fontComponents)
                    },
                    set: function(t) {
                        t = t || "bold 20pt Arial", this._fontComponents = this.fontToComponents(t), this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(n.Text.prototype, "font", {
                    get: function() {
                        return this._fontComponents.fontFamily
                    },
                    set: function(t) {
                        t = (t = t || "Arial").trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(t) || /['",]/.exec(t) || (t = "'" + t + "'"), this._fontComponents.fontFamily = t, this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(n.Text.prototype, "fontSize", {
                    get: function() {
                        var t = this._fontComponents.fontSize;
                        return t && /(?:^0$|px$)/.exec(t) ? parseInt(t, 10) : t
                    },
                    set: function(t) {
                        "number" == typeof(t = t || "0") && (t += "px"), this._fontComponents.fontSize = t, this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(n.Text.prototype, "fontWeight", {
                    get: function() {
                        return this._fontComponents.fontWeight || "normal"
                    },
                    set: function(t) {
                        t = t || "normal", this._fontComponents.fontWeight = t, this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(n.Text.prototype, "fontStyle", {
                    get: function() {
                        return this._fontComponents.fontStyle || "normal"
                    },
                    set: function(t) {
                        t = t || "normal", this._fontComponents.fontStyle = t, this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(n.Text.prototype, "fontVariant", {
                    get: function() {
                        return this._fontComponents.fontVariant || "normal"
                    },
                    set: function(t) {
                        t = t || "normal", this._fontComponents.fontVariant = t, this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(n.Text.prototype, "fill", {
                    get: function() {
                        return this.style.fill
                    },
                    set: function(t) {
                        t !== this.style.fill && (this.style.fill = t, this.dirty = !0)
                    }
                }), Object.defineProperty(n.Text.prototype, "align", {
                    get: function() {
                        return this.style.align
                    },
                    set: function(t) {
                        (t = t.toLowerCase()) !== this.style.align && (this.style.align = t, this.dirty = !0)
                    }
                }), Object.defineProperty(n.Text.prototype, "resolution", {
                    get: function() {
                        return this._res
                    },
                    set: function(t) {
                        t !== this._res && (this._res = t, this.dirty = !0)
                    }
                }), Object.defineProperty(n.Text.prototype, "tabs", {
                    get: function() {
                        return this.style.tabs
                    },
                    set: function(t) {
                        t !== this.style.tabs && (this.style.tabs = t, this.dirty = !0)
                    }
                }), Object.defineProperty(n.Text.prototype, "boundsAlignH", {
                    get: function() {
                        return this.style.boundsAlignH
                    },
                    set: function(t) {
                        (t = t.toLowerCase()) !== this.style.boundsAlignH && (this.style.boundsAlignH = t, this.dirty = !0)
                    }
                }), Object.defineProperty(n.Text.prototype, "boundsAlignV", {
                    get: function() {
                        return this.style.boundsAlignV
                    },
                    set: function(t) {
                        (t = t.toLowerCase()) !== this.style.boundsAlignV && (this.style.boundsAlignV = t, this.dirty = !0)
                    }
                }), Object.defineProperty(n.Text.prototype, "stroke", {
                    get: function() {
                        return this.style.stroke
                    },
                    set: function(t) {
                        t !== this.style.stroke && (this.style.stroke = t, this.dirty = !0)
                    }
                }), Object.defineProperty(n.Text.prototype, "strokeThickness", {
                    get: function() {
                        return this.style.strokeThickness
                    },
                    set: function(t) {
                        t !== this.style.strokeThickness && (this.style.strokeThickness = Number(t), this.dirty = !0)
                    }
                }), Object.defineProperty(n.Text.prototype, "wordWrap", {
                    get: function() {
                        return this.style.wordWrap
                    },
                    set: function(t) {
                        t !== this.style.wordWrap && (this.style.wordWrap = t, this.dirty = !0)
                    }
                }), Object.defineProperty(n.Text.prototype, "wordWrapWidth", {
                    get: function() {
                        return this.style.wordWrapWidth
                    },
                    set: function(t) {
                        t !== this.style.wordWrapWidth && (this.style.wordWrapWidth = t, this.dirty = !0)
                    }
                }), Object.defineProperty(n.Text.prototype, "lineSpacing", {
                    get: function() {
                        return this._lineSpacing
                    },
                    set: function(t) {
                        t !== this._lineSpacing && (this._lineSpacing = parseFloat(t), this.dirty = !0, this.parent && this.updateTransform())
                    }
                }), Object.defineProperty(n.Text.prototype, "shadowOffsetX", {
                    get: function() {
                        return this.style.shadowOffsetX
                    },
                    set: function(t) {
                        t !== this.style.shadowOffsetX && (this.style.shadowOffsetX = t, this.dirty = !0)
                    }
                }), Object.defineProperty(n.Text.prototype, "shadowOffsetY", {
                    get: function() {
                        return this.style.shadowOffsetY
                    },
                    set: function(t) {
                        t !== this.style.shadowOffsetY && (this.style.shadowOffsetY = t, this.dirty = !0)
                    }
                }), Object.defineProperty(n.Text.prototype, "shadowColor", {
                    get: function() {
                        return this.style.shadowColor
                    },
                    set: function(t) {
                        t !== this.style.shadowColor && (this.style.shadowColor = t, this.dirty = !0)
                    }
                }), Object.defineProperty(n.Text.prototype, "shadowBlur", {
                    get: function() {
                        return this.style.shadowBlur
                    },
                    set: function(t) {
                        t !== this.style.shadowBlur && (this.style.shadowBlur = t, this.dirty = !0)
                    }
                }), Object.defineProperty(n.Text.prototype, "shadowStroke", {
                    get: function() {
                        return this.style.shadowStroke
                    },
                    set: function(t) {
                        t !== this.style.shadowStroke && (this.style.shadowStroke = t, this.dirty = !0)
                    }
                }), Object.defineProperty(n.Text.prototype, "shadowFill", {
                    get: function() {
                        return this.style.shadowFill
                    },
                    set: function(t) {
                        t !== this.style.shadowFill && (this.style.shadowFill = t, this.dirty = !0)
                    }
                }), Object.defineProperty(n.Text.prototype, "width", {
                    get: function() {
                        return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * (this.texture.frame.width / this.resolution)
                    },
                    set: function(t) {
                        this.scale.x = t / this.texture.frame.width, this._width = t
                    }
                }), Object.defineProperty(n.Text.prototype, "height", {
                    get: function() {
                        return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * (this.texture.frame.height / this.resolution)
                    },
                    set: function(t) {
                        this.scale.y = t / this.texture.frame.height, this._height = t
                    }
                }), Object.defineProperty(n.Text.prototype, "testString", {
                    get: function() {
                        return this._testString
                    },
                    set: function(t) {
                        this._testString = t, this.updateText()
                    }
                }), n.Text.fontPropertiesCache = {}, n.Text.fontPropertiesCanvas = document.createElement("canvas"), n.Text.fontPropertiesContext = n.Text.fontPropertiesCanvas.getContext("2d"), n.BitmapText = function(t, e, i, s, r, o, a) {
                    e = e || 0, i = i || 0, s = s || "", r = r || "", o = o || 32, a = a || "left", PIXI.DisplayObjectContainer.call(this), this.type = n.BITMAPTEXT, this.physicsType = n.SPRITE, this.textWidth = 0, this.textHeight = 0, this.anchor = new n.Point, this._prevAnchor = new n.Point, this._glyphs = [], this._maxWidth = 0, this._text = r.toString() || "", this._data = t.cache.getBitmapFont(s), this._font = s, this._fontSize = o, this._align = a, this._letterSpacing = 0, this._tint = 16777215, this.updateText(), this.dirty = !1, n.Component.Core.init.call(this, t, e, i, "", null)
                }, n.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), n.BitmapText.prototype.constructor = n.BitmapText, n.Component.Core.install.call(n.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), n.BitmapText.prototype.preUpdatePhysics = n.Component.PhysicsBody.preUpdate, n.BitmapText.prototype.preUpdateLifeSpan = n.Component.LifeSpan.preUpdate, n.BitmapText.prototype.preUpdateInWorld = n.Component.InWorld.preUpdate, n.BitmapText.prototype.preUpdateCore = n.Component.Core.preUpdate, n.BitmapText.prototype.preUpdate = function() {
                    return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                }, n.BitmapText.prototype.postUpdate = function() {
                    n.Component.PhysicsBody.postUpdate.call(this), n.Component.FixedToCamera.postUpdate.call(this), this.body && this.body.type === n.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight))
                }, n.BitmapText.prototype.setText = function(t) {
                    this.text = t
                }, n.BitmapText.prototype.scanLine = function(t, e, i) {
                    for (var s = 0, n = 0, r = -1, o = 0, a = null, h = this._maxWidth > 0 ? this._maxWidth : null, l = [], c = 0; c < i.length; c++) {
                        var u = c === i.length - 1;
                        if (/(?:\r\n|\r|\n)/.test(i.charAt(c))) return {
                            width: n,
                            text: i.substr(0, c),
                            end: u,
                            chars: l
                        };
                        var d, p = i.charCodeAt(c),
                            f = t.chars[p];
                        void 0 === f && (p = 32, f = t.chars[p]);
                        var g = a && f.kerning[a] ? f.kerning[a] : 0;
                        if (/(\s)/.test(i.charAt(c)) && (r = c, o = n), d = (g + f.texture.width + f.xOffset) * e, h && n + d >= h && r > -1) return {
                            width: o || n,
                            text: i.substr(0, c - (c - r)),
                            end: !1,
                            chars: l
                        };
                        n += (f.xAdvance + g + this.letterSpacing) * e, l.push(s + (f.xOffset + g + this.letterSpacing) * e), s += (f.xAdvance + g + this.letterSpacing) * e, a = p
                    }
                    return {
                        width: n,
                        text: i,
                        end: u,
                        chars: l
                    }
                }, n.BitmapText.prototype.cleanText = function(t, e) {
                    void 0 === e && (e = "");
                    var i = this._data.font;
                    if (!i) return "";
                    for (var s = t.replace(/\r\n|\n\r|\n|\r/g, "\n").split("\n"), n = 0; n < s.length; n++) {
                        for (var r = "", o = s[n], a = 0; a < o.length; a++) r = i.chars[o.charCodeAt(a)] ? r.concat(o[a]) : r.concat(e);
                        s[n] = r
                    }
                    return s.join("\n")
                }, n.BitmapText.prototype.updateText = function() {
                    var t = this._data.font;
                    if (t) {
                        var e = this.text,
                            i = this._fontSize / t.size,
                            s = [],
                            n = 0;
                        this.textWidth = 0;
                        do {
                            (c = this.scanLine(t, i, e)).y = n, s.push(c), c.width > this.textWidth && (this.textWidth = c.width), n += t.lineHeight * i, e = e.substr(c.text.length + 1)
                        } while (!1 === c.end);
                        this.textHeight = n;
                        for (var r = 0, o = 0, a = this.textWidth * this.anchor.x, h = this.textHeight * this.anchor.y, l = 0; l < s.length; l++) {
                            var c = s[l];
                            "right" === this._align ? o = this.textWidth - c.width : "center" === this._align && (o = (this.textWidth - c.width) / 2);
                            for (var u = 0; u < c.text.length; u++) {
                                var d = c.text.charCodeAt(u),
                                    p = t.chars[d];
                                void 0 === p && (d = 32, p = t.chars[d]);
                                var f = this._glyphs[r];
                                f ? f.texture = p.texture : ((f = new PIXI.Sprite(p.texture)).name = c.text[u], this._glyphs.push(f)), f.position.x = c.chars[u] + o - a, f.position.y = c.y + p.yOffset * i - h, f.scale.set(i), f.tint = this.tint, f.texture.requiresReTint = !0, f.cachedTint = 16777215, f.parent || this.addChild(f), r++
                            }
                        }
                        for (l = r; l < this._glyphs.length; l++) this.removeChild(this._glyphs[l])
                    }
                }, n.BitmapText.prototype.purgeGlyphs = function() {
                    for (var t = this._glyphs.length, e = [], i = 0; i < this._glyphs.length; i++) this._glyphs[i].parent !== this ? this._glyphs[i].destroy() : e.push(this._glyphs[i]);
                    return this._glyphs = [], this._glyphs = e, this.updateText(), t - e.length
                }, n.BitmapText.prototype.updateTransform = function() {
                    !this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(), this.dirty = !1, this._prevAnchor.copyFrom(this.anchor)), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
                }, Object.defineProperty(n.BitmapText.prototype, "letterSpacing", {
                    get: function() {
                        return this._letterSpacing
                    },
                    set: function(t) {
                        "number" == typeof t && (this._letterSpacing = t, this.updateText())
                    }
                }), Object.defineProperty(n.BitmapText.prototype, "align", {
                    get: function() {
                        return this._align
                    },
                    set: function(t) {
                        t === this._align || "left" !== t && "center" !== t && "right" !== t || (this._align = t, this.updateText())
                    }
                }), Object.defineProperty(n.BitmapText.prototype, "tint", {
                    get: function() {
                        return this._tint
                    },
                    set: function(t) {
                        t !== this._tint && (this._tint = t, this.updateText())
                    }
                }), Object.defineProperty(n.BitmapText.prototype, "font", {
                    get: function() {
                        return this._font
                    },
                    set: function(t) {
                        t !== this._font && (this._font = t.trim(), this._data = this.game.cache.getBitmapFont(this._font), this.updateText())
                    }
                }), Object.defineProperty(n.BitmapText.prototype, "fontSize", {
                    get: function() {
                        return this._fontSize
                    },
                    set: function(t) {
                        (t = parseInt(t, 10)) !== this._fontSize && t > 0 && (this._fontSize = t, this.updateText())
                    }
                }), Object.defineProperty(n.BitmapText.prototype, "text", {
                    get: function() {
                        return this._text
                    },
                    set: function(t) {
                        t !== this._text && (this._text = t.toString() || "", this.updateText())
                    }
                }), Object.defineProperty(n.BitmapText.prototype, "maxWidth", {
                    get: function() {
                        return this._maxWidth
                    },
                    set: function(t) {
                        t !== this._maxWidth && (this._maxWidth = t, this.updateText())
                    }
                }), Object.defineProperty(n.BitmapText.prototype, "smoothed", {
                    get: function() {
                        return !this._data.base.scaleMode
                    },
                    set: function(t) {
                        this._data.base.scaleMode = t ? 0 : 1, this._data.base.dirty()
                    }
                }), n.RetroFont = function(t, e, i, s, r, o, a, h, l, c) {
                    if (!t.cache.checkImageKey(e)) return !1;
                    void 0 !== o && null !== o || (o = t.cache.getImage(e).width / i), this.characterWidth = i, this.characterHeight = s, this.characterSpacingX = a || 0, this.characterSpacingY = h || 0, this.characterPerRow = o, this.offsetX = l || 0, this.offsetY = c || 0, this.align = "left", this.multiLine = !1, this.autoUpperCase = !0, this.customSpacingX = 0, this.customSpacingY = 0, this.fixedWidth = 0, this.fontSet = t.cache.getImage(e), this._text = "", this.grabData = [], this.frameData = new n.FrameData;
                    for (var u = this.offsetX, d = this.offsetY, p = 0, f = 0; f < r.length; f++) {
                        var g = this.frameData.addFrame(new n.Frame(f, u, d, this.characterWidth, this.characterHeight));
                        this.grabData[r.charCodeAt(f)] = g.index, ++p === this.characterPerRow ? (p = 0, u = this.offsetX, d += this.characterHeight + this.characterSpacingY) : u += this.characterWidth + this.characterSpacingX
                    }
                    t.cache.updateFrameData(e, this.frameData), this.stamp = new n.Image(t, 0, 0, e, 0), n.RenderTexture.call(this, t, 100, 100, "", n.scaleModes.NEAREST), this.type = n.RETROFONT
                }, n.RetroFont.prototype = Object.create(n.RenderTexture.prototype), n.RetroFont.prototype.constructor = n.RetroFont, n.RetroFont.ALIGN_LEFT = "left", n.RetroFont.ALIGN_RIGHT = "right", n.RetroFont.ALIGN_CENTER = "center", n.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", n.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", n.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", n.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789", n.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", n.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", n.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", n.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ", n.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", n.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", n.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789", n.RetroFont.prototype.setFixedWidth = function(t, e) {
                    void 0 === e && (e = "left"), this.fixedWidth = t, this.align = e
                }, n.RetroFont.prototype.setText = function(t, e, i, s, n, r) {
                    this.multiLine = e || !1, this.customSpacingX = i || 0, this.customSpacingY = s || 0, this.align = n || "left", this.autoUpperCase = !r, t.length > 0 && (this.text = t)
                }, n.RetroFont.prototype.buildRetroFontText = function() {
                    var t = 0,
                        e = 0;
                    if (this.clear(), this.multiLine) {
                        var i = this._text.split("\n");
                        this.fixedWidth > 0 ? this.resize(this.fixedWidth, i.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), i.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
                        for (var s = 0; s < i.length; s++) t = 0, this.align === n.RetroFont.ALIGN_RIGHT ? t = this.width - i[s].length * (this.characterWidth + this.customSpacingX) : this.align === n.RetroFont.ALIGN_CENTER && (t = this.width / 2 - i[s].length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2), t < 0 && (t = 0), this.pasteLine(i[s], t, e, this.customSpacingX), e += this.characterHeight + this.customSpacingY
                    } else this.fixedWidth > 0 ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0), t = 0, this.align === n.RetroFont.ALIGN_RIGHT ? t = this.width - this._text.length * (this.characterWidth + this.customSpacingX) : this.align === n.RetroFont.ALIGN_CENTER && (t = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2), t < 0 && (t = 0), this.pasteLine(this._text, t, 0, this.customSpacingX);
                    this.requiresReTint = !0
                }, n.RetroFont.prototype.pasteLine = function(t, e, i, s) {
                    for (var n = 0; n < t.length; n++)
                        if (" " === t.charAt(n)) e += this.characterWidth + s;
                        else if (this.grabData[t.charCodeAt(n)] >= 0 && (this.stamp.frame = this.grabData[t.charCodeAt(n)], this.renderXY(this.stamp, e, i, !1), (e += this.characterWidth + s) > this.width)) break
                }, n.RetroFont.prototype.getLongestLine = function() {
                    var t = 0;
                    if (this._text.length > 0)
                        for (var e = this._text.split("\n"), i = 0; i < e.length; i++) e[i].length > t && (t = e[i].length);
                    return t
                }, n.RetroFont.prototype.removeUnsupportedCharacters = function(t) {
                    for (var e = "", i = 0; i < this._text.length; i++) {
                        var s = this._text[i],
                            n = s.charCodeAt(0);
                        (this.grabData[n] >= 0 || !t && "\n" === s) && (e = e.concat(s))
                    }
                    return e
                }, n.RetroFont.prototype.updateOffset = function(t, e) {
                    if (this.offsetX !== t || this.offsetY !== e) {
                        for (var i = t - this.offsetX, s = e - this.offsetY, n = this.game.cache.getFrameData(this.stamp.key).getFrames(), r = n.length; r--;) n[r].x += i, n[r].y += s;
                        this.buildRetroFontText()
                    }
                }, Object.defineProperty(n.RetroFont.prototype, "text", {
                    get: function() {
                        return this._text
                    },
                    set: function(t) {
                        var e;
                        (e = this.autoUpperCase ? t.toUpperCase() : t) !== this._text && (this._text = e, this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText())
                    }
                }), Object.defineProperty(n.RetroFont.prototype, "smoothed", {
                    get: function() {
                        return this.stamp.smoothed
                    },
                    set: function(t) {
                        this.stamp.smoothed = t, this.buildRetroFontText()
                    }
                }), n.Rope = function(t, e, i, s, r, o) {
                    this.points = o || [], this._hasUpdateAnimation = !1, this._updateAnimationCallback = null, e = e || 0, i = i || 0, s = s || null, r = r || null, this.type = n.ROPE, PIXI.DisplayObjectContainer.call(this), this.texture = n.Cache.DEFAULT, this.uvs = new Float32Array([0, 1, 1, 1, 1, 0, 0, 1]), this.vertices = new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]), this.colors = new Float32Array([1, 1, 1, 1]), this.indices = new Uint16Array([0, 1, 2, 3]), o && (this.vertices = new Float32Array(4 * o.length), this.uvs = new Float32Array(4 * o.length), this.colors = new Float32Array(2 * o.length), this.indices = new Uint16Array(2 * o.length)), this.dirty = !0, this.canvasPadding = 0, this.drawMode = n.Rope.TRIANGLE_STRIP, n.Component.Core.init.call(this, t, e, i, s, r), this.refresh()
                }, n.Rope.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), n.Rope.prototype.constructor = n.Rope, n.Component.Core.install.call(n.Rope.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), n.Rope.prototype.preUpdatePhysics = n.Component.PhysicsBody.preUpdate, n.Rope.prototype.preUpdateLifeSpan = n.Component.LifeSpan.preUpdate, n.Rope.prototype.preUpdateInWorld = n.Component.InWorld.preUpdate, n.Rope.prototype.preUpdateCore = n.Component.Core.preUpdate, n.Rope.TRIANGLE_STRIP = 0, n.Rope.TRIANGLES = 1, n.Rope.prototype.preUpdate = function() {
                    return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                }, n.Rope.prototype.update = function() {
                    this._hasUpdateAnimation && this.updateAnimation.call(this)
                }, n.Rope.prototype.reset = function(t, e) {
                    return n.Component.Reset.prototype.reset.call(this, t, e), this
                }, n.Rope.prototype.refresh = function() {
                    var t = this.points;
                    if (!(t.length < 1)) {
                        var e = this.uvs,
                            i = this.indices,
                            s = this.colors;
                        this.count -= .2;
                        for (var n = t.length, r = 0, o = 0, a = 0; a < n; a++) o = a / (n - 1), e[r = 4 * a] = o, e[r + 1] = 0, e[r + 2] = o, e[r + 3] = 1, s[r = 2 * a] = 1, s[r + 1] = 1, i[r = 2 * a] = r, i[r + 1] = r + 1
                    }
                }, n.Rope.prototype.updateTransform = function() {
                    var t = this.points;
                    if (!(t.length < 1)) {
                        var e, i = t[0],
                            s = {
                                x: 0,
                                y: 0
                            };
                        this.count -= .2;
                        for (var n, r, o, a, h = this.vertices, l = t.length, c = this.texture.height / 2, u = 0; u < l; u++) n = t[u], r = 4 * u, e = u < l - 1 ? t[u + 1] : n, s.y = -(e.x - i.x), s.x = e.y - i.y, o = Math.sqrt(s.x * s.x + s.y * s.y), a = c, s.x /= o, s.y /= o, s.x *= a, s.y *= a, h[r] = n.x + s.x, h[r + 1] = n.y + s.y, h[r + 2] = n.x - s.x, h[r + 3] = n.y - s.y, i = n;
                        PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
                    }
                }, n.Rope.prototype.setTexture = function(t) {
                    this.texture = t
                }, n.Rope.prototype._renderWebGL = function(t) {
                    !this.visible || this.alpha <= 0 || (t.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(t), t.shaderManager.setShader(t.shaderManager.stripShader), this._renderStrip(t), t.spriteBatch.start())
                }, n.Rope.prototype._initWebGL = function(t) {
                    var e = t.gl;
                    this._vertexBuffer = e.createBuffer(), this._indexBuffer = e.createBuffer(), this._uvBuffer = e.createBuffer(), this._colorBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.vertices, e.DYNAMIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._colorBuffer), e.bufferData(e.ARRAY_BUFFER, this.colors, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)
                }, n.Rope.prototype._renderStrip = function(t) {
                    var e = t.gl,
                        i = t.projection,
                        s = t.offset,
                        r = t.shaderManager.stripShader,
                        o = this.drawMode === n.Rope.TRIANGLE_STRIP ? e.TRIANGLE_STRIP : e.TRIANGLES;
                    t.blendModeManager.setBlendMode(this.blendMode), e.uniformMatrix3fv(r.translationMatrix, !1, this.worldTransform.toArray(!0)), e.uniform2f(r.projectionVector, i.x, -i.y), e.uniform2f(r.offsetVector, -s.x, -s.y), e.uniform1f(r.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.vertices, e.STATIC_DRAW), e.vertexAttribPointer(r.aVertexPosition, 2, e.FLOAT, !1, 0, 0), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW), e.vertexAttribPointer(r.aTextureCoord, 2, e.FLOAT, !1, 0, 0), e.activeTexture(e.TEXTURE0), this.texture.baseTexture._dirty[e.id] ? t.renderer.updateTexture(this.texture.baseTexture) : e.bindTexture(e.TEXTURE_2D, this.texture.baseTexture._glTextures[e.id]), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)) : (e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertices), e.vertexAttribPointer(r.aVertexPosition, 2, e.FLOAT, !1, 0, 0), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.vertexAttribPointer(r.aTextureCoord, 2, e.FLOAT, !1, 0, 0), e.activeTexture(e.TEXTURE0), this.texture.baseTexture._dirty[e.id] ? t.renderer.updateTexture(this.texture.baseTexture) : e.bindTexture(e.TEXTURE_2D, this.texture.baseTexture._glTextures[e.id]), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), e.drawElements(o, this.indices.length, e.UNSIGNED_SHORT, 0)
                }, n.Rope.prototype._renderCanvas = function(t) {
                    var e = t.context,
                        i = this.worldTransform,
                        s = i.tx * t.resolution + t.shakeX,
                        r = i.ty * t.resolution + t.shakeY;
                    t.roundPixels ? e.setTransform(i.a, i.b, i.c, i.d, 0 | s, 0 | r) : e.setTransform(i.a, i.b, i.c, i.d, s, r), this.drawMode === n.Rope.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(e) : this._renderCanvasTriangles(e)
                }, n.Rope.prototype._renderCanvasTriangleStrip = function(t) {
                    var e = this.vertices,
                        i = this.uvs,
                        s = e.length / 2;
                    this.count++;
                    for (var n = 0; n < s - 2; n++) {
                        var r = 2 * n;
                        this._renderCanvasDrawTriangle(t, e, i, r, r + 2, r + 4)
                    }
                }, n.Rope.prototype._renderCanvasTriangles = function(t) {
                    var e = this.vertices,
                        i = this.uvs,
                        s = this.indices,
                        n = s.length;
                    this.count++;
                    for (var r = 0; r < n; r += 3) {
                        var o = 2 * s[r],
                            a = 2 * s[r + 1],
                            h = 2 * s[r + 2];
                        this._renderCanvasDrawTriangle(t, e, i, o, a, h)
                    }
                }, n.Rope.prototype._renderCanvasDrawTriangle = function(t, e, i, s, n, r) {
                    var o = this.texture.baseTexture.source,
                        a = this.texture.width,
                        h = this.texture.height,
                        l = e[s],
                        c = e[n],
                        u = e[r],
                        d = e[s + 1],
                        p = e[n + 1],
                        f = e[r + 1],
                        g = i[s] * a,
                        m = i[n] * a,
                        y = i[r] * a,
                        v = i[s + 1] * h,
                        x = i[n + 1] * h,
                        b = i[r + 1] * h;
                    if (this.canvasPadding > 0) {
                        var _ = this.canvasPadding / this.worldTransform.a,
                            T = this.canvasPadding / this.worldTransform.d,
                            w = (l + c + u) / 3,
                            S = (d + p + f) / 3,
                            C = l - w,
                            E = d - S,
                            P = Math.sqrt(C * C + E * E);
                        l = w + C / P * (P + _), d = S + E / P * (P + T), E = p - S, c = w + (C = c - w) / (P = Math.sqrt(C * C + E * E)) * (P + _), p = S + E / P * (P + T), E = f - S, u = w + (C = u - w) / (P = Math.sqrt(C * C + E * E)) * (P + _), f = S + E / P * (P + T)
                    }
                    t.save(), t.beginPath(), t.moveTo(l, d), t.lineTo(c, p), t.lineTo(u, f), t.closePath(), t.clip();
                    var A = g * x + v * y + m * b - x * y - v * m - g * b,
                        M = l * x + v * u + c * b - x * u - v * c - l * b,
                        k = g * c + l * y + m * u - c * y - l * m - g * u,
                        R = g * x * u + v * c * y + l * m * b - l * x * y - v * m * u - g * c * b,
                        O = d * x + v * f + p * b - x * f - v * p - d * b,
                        I = g * p + d * y + m * f - p * y - d * m - g * f,
                        L = g * x * f + v * p * y + d * m * b - d * x * y - v * m * f - g * p * b;
                    t.transform(M / A, O / A, k / A, I / A, R / A, L / A), t.drawImage(o, 0, 0), t.restore()
                }, n.Rope.prototype.renderStripFlat = function(t) {
                    var e = this.context,
                        i = t.vertices,
                        s = i.length / 2;
                    this.count++, e.beginPath();
                    for (var n = 1; n < s - 2; n++) {
                        var r = 2 * n,
                            o = i[r],
                            a = i[r + 2],
                            h = i[r + 4],
                            l = i[r + 1],
                            c = i[r + 3],
                            u = i[r + 5];
                        e.moveTo(o, l), e.lineTo(a, c), e.lineTo(h, u)
                    }
                    e.fillStyle = "#FF0000", e.fill(), e.closePath()
                }, n.Rope.prototype.getBounds = function(t) {
                    for (var e = t || this.worldTransform, i = e.a, s = e.b, r = e.c, o = e.d, a = e.tx, h = e.ty, l = -1 / 0, c = -1 / 0, u = 1 / 0, d = 1 / 0, p = this.vertices, f = 0; f < p.length; f += 2) {
                        var g = p[f],
                            m = p[f + 1],
                            y = i * g + r * m + a,
                            v = o * m + s * g + h;
                        u = y < u ? y : u, d = v < d ? v : d, l = y > l ? y : l, c = v > c ? v : c
                    }
                    if (u === -1 / 0 || c === 1 / 0) return n.EmptyRectangle;
                    var x = this._bounds;
                    return x.x = u, x.width = l - u, x.y = d, x.height = c - d, this._currentBounds = x, x
                }, Object.defineProperty(n.Rope.prototype, "updateAnimation", {
                    get: function() {
                        return this._updateAnimation
                    },
                    set: function(t) {
                        t && "function" == typeof t ? (this._hasUpdateAnimation = !0, this._updateAnimation = t) : (this._hasUpdateAnimation = !1, this._updateAnimation = null)
                    }
                }), Object.defineProperty(n.Rope.prototype, "segments", {
                    get: function() {
                        for (var t, e, i, s, r, o, a, h, l = [], c = 0; c < this.points.length; c++) t = 4 * c, e = this.vertices[t] * this.scale.x, i = this.vertices[t + 1] * this.scale.y, s = this.vertices[t + 4] * this.scale.x, r = this.vertices[t + 3] * this.scale.y, o = n.Math.difference(e, s), a = n.Math.difference(i, r), e += this.world.x, i += this.world.y, h = new n.Rectangle(e, i, o, a), l.push(h);
                        return l
                    }
                }), n.TileSprite = function(t, e, i, s, r, o, a) {
                    e = e || 0, i = i || 0, s = s || 256, r = r || 256, o = o || null, a = a || null, PIXI.Sprite.call(this, new PIXI.Texture(n.Cache.DEFAULT.baseTexture), s, r), this.type = n.TILESPRITE, this.physicsType = n.SPRITE, this._scroll = new n.Point, this.tileScale = new n.Point(1, 1), this.tileScaleOffset = new n.Point(1, 1), this.tilePosition = new n.Point, this.textureDebug = !1, this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, this.frameWidth = 0, this.frameHeight = 0, this._width = s, this._height = r, n.Component.Core.init.call(this, t, e, i, o, a)
                }, n.TileSprite.prototype = Object.create(PIXI.Sprite.prototype), n.TileSprite.prototype.constructor = n.TileSprite, n.Component.Core.install.call(n.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]), n.TileSprite.prototype.preUpdatePhysics = n.Component.PhysicsBody.preUpdate, n.TileSprite.prototype.preUpdateLifeSpan = n.Component.LifeSpan.preUpdate, n.TileSprite.prototype.preUpdateInWorld = n.Component.InWorld.preUpdate, n.TileSprite.prototype.preUpdateCore = n.Component.Core.preUpdate, n.TileSprite.prototype.preUpdate = function() {
                    return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                }, n.TileSprite.prototype.autoScroll = function(t, e) {
                    return this._scroll.set(t, e), this
                }, n.TileSprite.prototype.stopScroll = function() {
                    return this._scroll.set(0, 0), this
                }, n.TileSprite.prototype.destroy = function(t) {
                    n.Component.Destroy.prototype.destroy.call(this, t), PIXI.Sprite.prototype.destroy.call(this), this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null), this.tileScale = null, this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null)
                }, n.TileSprite.prototype.reset = function(t, e) {
                    return n.Component.Reset.prototype.reset.call(this, t, e), this.tilePosition.x = 0, this.tilePosition.y = 0, this
                }, n.TileSprite.prototype.setTexture = function(t) {
                    return this.texture !== t && (this.texture = t, this.refreshTexture = !0, this.cachedTint = 16777215), this
                }, n.TileSprite.prototype._renderWebGL = function(t) {
                    if (this.visible && this.renderable && 0 !== this.alpha) {
                        if (this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) {
                            if (this.generateTilingTexture(!0, t), !this.tilingTexture) return;
                            this.tilingTexture.needsUpdate && (this.tilingTexture.baseTexture.textureIndex = this.texture.baseTexture.textureIndex, t.renderer.updateTexture(this.tilingTexture.baseTexture), this.tilingTexture.needsUpdate = !1)
                        }
                        t.spriteBatch.renderTilingSprite(this);
                        for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                        var i = !1;
                        this._filters && (i = !0, t.spriteBatch.stop(), t.filterManager.popFilter()), this._mask && (i || t.spriteBatch.stop(), t.maskManager.popMask(this._mask, t)), i && t.spriteBatch.start()
                    }
                }, n.TileSprite.prototype._renderCanvas = function(t) {
                    if (this.visible && this.renderable && 0 !== this.alpha) {
                        var e = t.context;
                        this._mask && t.maskManager.pushMask(this._mask, t), e.globalAlpha = this.worldAlpha;
                        var i = this.worldTransform,
                            s = t.resolution,
                            n = i.tx * s + t.shakeX,
                            r = i.ty * s + t.shakeY;
                        if (e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, n, r), 16777215 === this.tint || !this.texture.requiresReTint && this.cachedTint === this.tint || (this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1, this.refreshTexture = !0), this.refreshTexture) {
                            if (this.generateTilingTexture(!1, t), !this.tilingTexture) return;
                            this.tilePattern = e.createPattern(this.tilingTexture.baseTexture.source, "repeat")
                        }
                        var o = t.currentBlendMode;
                        this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]);
                        var a = this.tilePosition,
                            h = this.tileScale;
                        a.x %= this.tilingTexture.baseTexture.width, a.y %= this.tilingTexture.baseTexture.height, e.scale(h.x, h.y), e.translate(a.x + this.anchor.x * -this._width, a.y + this.anchor.y * -this._height), e.fillStyle = this.tilePattern, n = -a.x, r = -a.y;
                        var l = this._width / h.x,
                            c = this._height / h.y;
                        t.roundPixels && (n |= 0, r |= 0, l |= 0, c |= 0), e.fillRect(n, r, l, c), e.scale(1 / h.x, 1 / h.y), e.translate(-a.x + this.anchor.x * this._width, -a.y + this.anchor.y * this._height), this._mask && t.maskManager.popMask(t);
                        for (var u = 0; u < this.children.length; u++) this.children[u]._renderCanvas(t);
                        o !== this.blendMode && (t.currentBlendMode = o, e.globalCompositeOperation = PIXI.blendModesCanvas[o])
                    }
                }, n.TileSprite.prototype.onTextureUpdate = function() {}, n.TileSprite.prototype.generateTilingTexture = function(t) {
                    if (this.texture.baseTexture.hasLoaded) {
                        var e = this.texture,
                            i = e.frame,
                            s = this._frame.sourceSizeW || this._frame.width,
                            r = this._frame.sourceSizeH || this._frame.height,
                            o = 0,
                            a = 0;
                        this._frame.trimmed && (o = this._frame.spriteSourceSizeX, a = this._frame.spriteSourceSizeY), t && (s = n.Math.getNextPowerOfTwo(s), r = n.Math.getNextPowerOfTwo(r)), this.canvasBuffer ? (this.canvasBuffer.resize(s, r), this.tilingTexture.baseTexture.width = s, this.tilingTexture.baseTexture.height = r, this.tilingTexture.needsUpdate = !0) : (this.canvasBuffer = new PIXI.CanvasBuffer(s, r), this.tilingTexture = PIXI.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0, this.tilingTexture.needsUpdate = !0), this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, s, r));
                        var h = e.crop.width,
                            l = e.crop.height;
                        h === s && l === r || (h = s, l = r);
                        var c = this.tintedTexture ? this.tintedTexture : e.baseTexture.source;
                        this.canvasBuffer.context.drawImage(c, e.crop.x, e.crop.y, e.crop.width, e.crop.height, o, a, h, l), this.tileScaleOffset.x = i.width / s, this.tileScaleOffset.y = i.height / r, this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0
                    }
                }, n.TileSprite.prototype.getBounds = function() {
                    var t = this._width,
                        e = this._height,
                        i = t * (1 - this.anchor.x),
                        s = t * -this.anchor.x,
                        n = e * (1 - this.anchor.y),
                        r = e * -this.anchor.y,
                        o = this.worldTransform,
                        a = o.a,
                        h = o.b,
                        l = o.c,
                        c = o.d,
                        u = o.tx,
                        d = o.ty,
                        p = a * s + l * r + u,
                        f = c * r + h * s + d,
                        g = a * i + l * r + u,
                        m = c * r + h * i + d,
                        y = a * i + l * n + u,
                        v = c * n + h * i + d,
                        x = a * s + l * n + u,
                        b = c * n + h * s + d,
                        _ = -1 / 0,
                        T = -1 / 0,
                        w = 1 / 0,
                        S = 1 / 0;
                    w = x < (w = y < (w = g < (w = p < w ? p : w) ? g : w) ? y : w) ? x : w, S = b < (S = v < (S = m < (S = f < S ? f : S) ? m : S) ? v : S) ? b : S, _ = x > (_ = y > (_ = g > (_ = p > _ ? p : _) ? g : _) ? y : _) ? x : _, T = b > (T = v > (T = m > (T = f > T ? f : T) ? m : T) ? v : T) ? b : T;
                    var C = this._bounds;
                    return C.x = w, C.width = _ - w, C.y = S, C.height = T - S, this._currentBounds = C, C
                }, Object.defineProperty(n.TileSprite.prototype, "width", {
                    get: function() {
                        return this._width
                    },
                    set: function(t) {
                        this._width = t
                    }
                }), Object.defineProperty(n.TileSprite.prototype, "height", {
                    get: function() {
                        return this._height
                    },
                    set: function(t) {
                        this._height = t
                    }
                }), n.CanvasPool = {
                    create: function(t, e, i) {
                        var s, r = n.CanvasPool.getFirst();
                        if (-1 === r) {
                            var o = {
                                parent: t,
                                canvas: document.createElement("canvas")
                            };
                            n.CanvasPool.pool.push(o), s = o.canvas
                        } else n.CanvasPool.pool[r].parent = t, s = n.CanvasPool.pool[r].canvas;
                        return void 0 !== e && (s.width = e, s.height = i), s
                    },
                    getFirst: function() {
                        for (var t = n.CanvasPool.pool, e = 0; e < t.length; e++)
                            if (!t[e].parent) return e;
                        return -1
                    },
                    remove: function(t) {
                        for (var e = n.CanvasPool.pool, i = 0; i < e.length; i++) e[i].parent === t && (e[i].parent = null, e[i].canvas.width = 1, e[i].canvas.height = 1)
                    },
                    removeByCanvas: function(t) {
                        for (var e = n.CanvasPool.pool, i = 0; i < e.length; i++) e[i].canvas === t && (e[i].parent = null, e[i].canvas.width = 1, e[i].canvas.height = 1)
                    },
                    getTotal: function() {
                        for (var t = n.CanvasPool.pool, e = 0, i = 0; i < t.length; i++) t[i].parent && e++;
                        return e
                    },
                    getFree: function() {
                        for (var t = n.CanvasPool.pool, e = 0, i = 0; i < t.length; i++) t[i].parent || e++;
                        return e
                    },
                    log: function() {
                        console.log("CanvasPool: %s used, %s free, %s total", n.CanvasPool.getTotal(), n.CanvasPool.getFree(), n.CanvasPool.pool.length)
                    }
                }, n.CanvasPool.pool = [], Object.defineProperty(n.CanvasPool, "length", {
                    get: function() {
                        return this.pool.length
                    }
                }), n.Device = function() {
                    this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, this.iOSVersion = 0, this.cocoonJS = !1, this.cocoonJSApp = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, this.canHandleAlpha = !1, this.canUseMultiply = !1, this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.edge = !1, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.safariVersion = 0, this.webApp = !1, this.silk = !1, this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.dolby = !1, this.oggVideo = !1, this.h264Video = !1, this.mp4Video = !1, this.webmVideo = !1, this.vp9Video = !1, this.hlsVideo = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", this.fullscreenKeyboard = !1
                }, n.Device = new n.Device, n.Device.onInitialized = new n.Signal, n.Device.whenReady = function(t, e, i) {
                    var s = this._readyCheck;
                    if (this.deviceReadyAt || !s) t.call(e, this);
                    else if (s._monitor || i) s._queue = s._queue || [], s._queue.push([t, e]);
                    else {
                        s._monitor = s.bind(this), s._queue = s._queue || [], s._queue.push([t, e]);
                        var n = void 0 !== window.cordova,
                            r = navigator.isCocoonJS;
                        "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(s._monitor, 0) : n && !r ? document.addEventListener("deviceready", s._monitor, !1) : (document.addEventListener("DOMContentLoaded", s._monitor, !1), window.addEventListener("load", s._monitor, !1))
                    }
                }, n.Device._readyCheck = function() {
                    var t = this._readyCheck;
                    if (document.body) {
                        if (!this.deviceReadyAt) {
                            var e;
                            for (this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", t._monitor), document.removeEventListener("DOMContentLoaded", t._monitor), window.removeEventListener("load", t._monitor), this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this); e = t._queue.shift();) {
                                var i = e[0],
                                    s = e[1];
                                i.call(s, this)
                            }
                            this._readyCheck = null, this._initialize = null, this.onInitialized = null
                        }
                    } else window.setTimeout(t._monitor, 20)
                }, n.Device._initialize = function() {
                    var t, e, s, r = this;
                    ! function() {
                        var t = navigator.userAgent;
                        /Playstation Vita/.test(t) ? r.vita = !0 : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? r.kindle = !0 : /Android/.test(t) ? r.android = !0 : /CrOS/.test(t) ? r.chromeOS = !0 : /iP[ao]d|iPhone/i.test(t) ? (r.iOS = !0, navigator.appVersion.match(/OS (\d+)/), r.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(t) ? r.linux = !0 : /Mac OS/.test(t) ? r.macOS = !0 : /Windows/.test(t) && (r.windows = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (r.android = !1, r.iOS = !1, r.macOS = !1, r.windows = !0, r.windowsPhone = !0);
                        var e = /Silk/.test(t);
                        (r.windows || r.macOS || r.linux && !e || r.chromeOS) && (r.desktop = !0), (r.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (r.desktop = !1)
                    }(),
                    function() {
                        var t = navigator.userAgent;
                        if (/Arora/.test(t) ? r.arora = !0 : /Edge\/\d+/.test(t) ? r.edge = !0 : /Chrome\/(\d+)/.test(t) && !r.windowsPhone ? (r.chrome = !0, r.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(t) ? r.epiphany = !0 : /Firefox\D+(\d+)/.test(t) ? (r.firefox = !0, r.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(t) && r.iOS ? r.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(t) ? (r.ie = !0, r.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(t) ? r.midori = !0 : /Opera/.test(t) ? r.opera = !0 : /Safari\/(\d+)/.test(t) && !r.windowsPhone ? (r.safari = !0, /Version\/(\d+)\./.test(t) && (r.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(t) && (r.ie = !0, r.trident = !0, r.tridentVersion = parseInt(RegExp.$1, 10), r.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(t) && (r.silk = !0), navigator.standalone && (r.webApp = !0), void 0 !== window.cordova && (r.cordova = !0), void 0 !== i && (r.node = !0), r.node && "object" == typeof i.versions && (r.nodeWebkit = !!i.versions["node-webkit"], r.electron = !!i.versions.electron), navigator.isCocoonJS && (r.cocoonJS = !0), r.cocoonJS) try {
                            r.cocoonJSApp = "undefined" != typeof CocoonJS
                        } catch (t) {
                            r.cocoonJSApp = !1
                        }
                        void 0 !== window.ejecta && (r.ejecta = !0), /Crosswalk/.test(t) && (r.crosswalk = !0)
                    }(),
                    function() {
                        r.audioData = !!window.Audio, r.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
                        var t = document.createElement("audio");
                        try {
                            if (t.canPlayType && (t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (r.ogg = !0), (t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || t.canPlayType("audio/opus;").replace(/^no$/, "")) && (r.opus = !0), t.canPlayType("audio/mpeg;").replace(/^no$/, "") && (r.mp3 = !0), t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (r.wav = !0), (t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/aac;").replace(/^no$/, "")) && (r.m4a = !0), t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (r.webm = !0), "" !== t.canPlayType('audio/mp4;codecs="ec-3"')))
                                if (r.edge) r.dolby = !0;
                                else if (r.safari && r.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                                var e = parseInt(RegExp.$1, 10),
                                    i = parseInt(RegExp.$2, 10);
                                (10 === e && i >= 11 || e > 10) && (r.dolby = !0)
                            }
                        } catch (t) {}
                    }(),
                    function() {
                        var t = document.createElement("video");
                        try {
                            t.canPlayType && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (r.oggVideo = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (r.h264Video = !0, r.mp4Video = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (r.webmVideo = !0), t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (r.vp9Video = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (r.hlsVideo = !0))
                        } catch (t) {}
                    }(),
                    function() {
                        var t, e = document.createElement("p"),
                            i = {
                                webkitTransform: "-webkit-transform",
                                OTransform: "-o-transform",
                                msTransform: "-ms-transform",
                                MozTransform: "-moz-transform",
                                transform: "transform"
                            };
                        document.body.insertBefore(e, null);
                        for (var s in i) void 0 !== e.style[s] && (e.style[s] = "translate3d(1px,1px,1px)", t = window.getComputedStyle(e).getPropertyValue(i[s]));
                        document.body.removeChild(e), r.css3D = void 0 !== t && t.length > 0 && "none" !== t
                    }(), r.pixelRatio = window.devicePixelRatio || 1, r.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf("iphone"), r.iPhone4 = 2 === r.pixelRatio && r.iPhone, r.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad"), "undefined" != typeof Int8Array ? r.typedArray = !0 : r.typedArray = !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (r.littleEndian = (t = new ArrayBuffer(4), e = new Uint8Array(t), s = new Uint32Array(t), e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, 3569595041 === s[0] || 2712847316 !== s[0] && null), r.LITTLE_ENDIAN = r.littleEndian), r.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== r.littleEndian && function() {
                            if (void 0 === Uint8ClampedArray) return !1;
                            var t = n.CanvasPool.create(this, 1, 1).getContext("2d");
                            if (!t) return !1;
                            var e = t.createImageData(1, 1);
                            return n.CanvasPool.remove(this), e.data instanceof Uint8ClampedArray
                        }(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (r.vibration = !0),
                        function() {
                            r.canvas = !!window.CanvasRenderingContext2D || r.cocoonJS;
                            try {
                                r.localStorage = !!localStorage.getItem
                            } catch (t) {
                                r.localStorage = !1
                            }
                            r.file = !!(window.File && window.FileReader && window.FileList && window.Blob), r.fileSystem = !!window.requestFileSystem, r.webGL = !!window.WebGLRenderingContext, r.worker = !!window.Worker, r.pointerLockElement = ("pointerLockElement" in document ? "pointerLockElement" : "mozPointerLockElement" in document && "mozPointerLockElement") || "webkitPointerLockElement" in document && "webkitPointerLockElement", r.pointerlockchange = ("onpointerlockchange" in document ? "pointerlockchange" : "onmozpointerlockchange" in document && "mozpointerlockchange") || "onwebkitpointerlockchange" in document && "webkitpointerlockchange", r.pointerlockerror = ("onpointerlockerror" in document ? "pointerlockerror" : "onmozpointerlockerror" in document && "mozpointerlockerror") || "onwebkitpointerlockerror" in document && "webkitpointerlockerror", r.pointerLock = !!r.pointerLockElement, r.quirksMode = "CSS1Compat" !== document.compatMode, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, r.getUserMedia = r.getUserMedia && !!navigator.getUserMedia && !!window.URL, r.firefox && r.firefoxVersion < 21 && (r.getUserMedia = !1), !r.iOS && (r.ie || r.firefox || r.chrome) && (r.canvasBitBltShift = !0), (r.safari || r.mobileSafari) && (r.canvasBitBltShift = !1)
                        }(),
                        function() {
                            var t = n.CanvasPool.create(this, 6, 1),
                                e = t.getContext("2d");
                            e.fillStyle = "rgba(10, 20, 30, 0.5)", e.fillRect(0, 0, 1, 1);
                            var i = e.getImageData(0, 0, 1, 1);
                            if (i) {
                                e.putImageData(i, 1, 0);
                                var s = e.getImageData(1, 0, 1, 1);
                                r.canHandleAlpha = s.data[0] === i.data[0] && s.data[1] === i.data[1] && s.data[2] === i.data[2] && s.data[3] === i.data[3]
                            }
                            e.globalCompositeOperation = "multiply", r.canUseMultiply = "multiply" === e.globalCompositeOperation, n.CanvasPool.removeByCanvas(t), PIXI.CanvasTinter.tintMethod = r.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply : PIXI.CanvasTinter.tintWithPerPixel
                        }(),
                        function() {
                            for (var t = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], e = document.createElement("div"), i = 0; i < t.length; i++)
                                if (e[t[i]]) {
                                    r.fullscreen = !0, r.requestFullscreen = t[i];
                                    break
                                } var s = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
                            if (r.fullscreen)
                                for (i = 0; i < s.length; i++)
                                    if (document[s[i]]) {
                                        r.cancelFullscreen = s[i];
                                        break
                                    } window.Element && Element.ALLOW_KEYBOARD_INPUT && (r.fullscreenKeyboard = !0)
                        }(), ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) && (r.touch = !0), (window.PointerEvent || window.MSPointerEvent || window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (r.mspointer = !0), r.cocoonJS || ("onwheel" in window || r.ie && "WheelEvent" in window ? r.wheelEvent = "wheel" : "onmousewheel" in window ? r.wheelEvent = "mousewheel" : r.firefox && "MouseScrollEvent" in window && (r.wheelEvent = "DOMMouseScroll"))
                }, n.Device.canPlayAudio = function(t) {
                    return !("mp3" !== t || !this.mp3) || (!("ogg" !== t || !this.ogg && !this.opus) || (!("m4a" !== t || !this.m4a) || (!("opus" !== t || !this.opus) || (!("wav" !== t || !this.wav) || (!("webm" !== t || !this.webm) || !("mp4" !== t || !this.dolby))))))
                }, n.Device.canPlayVideo = function(t) {
                    return !("webm" !== t || !this.webmVideo && !this.vp9Video) || (!("mp4" !== t || !this.mp4Video && !this.h264Video) || (!("ogg" !== t && "ogv" !== t || !this.oggVideo) || !("mpeg" !== t || !this.hlsVideo)))
                }, n.Device.needsTouchUnlock = function() {
                    return !!(!this.cocoonJS && (this.iOS || this.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock)
                }, n.Device.isAndroidStockBrowser = function() {
                    var t = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
                    return t && t[1] < 537
                }, n.Canvas = {
                    create: function(t, e, i, s, r) {
                        e = e || 256, i = i || 256;
                        var o = r ? document.createElement("canvas") : n.CanvasPool.create(t, e, i);
                        return "string" == typeof s && "" !== s && (o.id = s), o.width = e, o.height = i, o.style.display = "block", o
                    },
                    setBackgroundColor: function(t, e) {
                        return e = e || "rgb(0,0,0)", t.style.backgroundColor = e, t
                    },
                    setTouchAction: function(t, e) {
                        return e = e || "none", t.style.msTouchAction = e, t.style["ms-touch-action"] = e, t.style["touch-action"] = e, t
                    },
                    setUserSelect: function(t, e) {
                        return e = e || "none", t.style["-webkit-touch-callout"] = e, t.style["-webkit-user-select"] = e, t.style["-khtml-user-select"] = e, t.style["-moz-user-select"] = e, t.style["-ms-user-select"] = e, t.style["user-select"] = e, t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", t
                    },
                    addToDOM: function(t, e, i) {
                        var s;
                        return void 0 === i && (i = !0), e && ("string" == typeof e ? s = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (s = e)), s || (s = document.body), i && s.style && (s.style.overflow = "hidden"), s.appendChild(t), t
                    },
                    removeFromDOM: function(t) {
                        t.parentNode && t.parentNode.removeChild(t)
                    },
                    setTransform: function(t, e, i, s, n, r, o) {
                        return t.setTransform(s, r, o, n, e, i), t
                    },
                    setSmoothingEnabled: function(t, e) {
                        var i = n.Canvas.getSmoothingPrefix(t);
                        return i && (t[i] = e), t
                    },
                    getSmoothingPrefix: function(t) {
                        var e = ["i", "webkitI", "msI", "mozI", "oI"];
                        for (var i in e) {
                            var s = e[i] + "mageSmoothingEnabled";
                            if (s in t) return s
                        }
                        return null
                    },
                    getSmoothingEnabled: function(t) {
                        var e = n.Canvas.getSmoothingPrefix(t);
                        if (e) return t[e]
                    },
                    setImageRenderingCrisp: function(t) {
                        for (var e = ["-webkit-optimize-contrast", "-moz-crisp-edges", "crisp-edges", "pixelated"], i = 0; i < e.length; i++) t.style["image-rendering"] = e[i];
                        return t.style.msInterpolationMode = "nearest-neighbor", t
                    },
                    setImageRenderingBicubic: function(t) {
                        return t.style["image-rendering"] = "auto", t.style.msInterpolationMode = "bicubic", t
                    }
                }, n.RequestAnimationFrame = function(t, e) {
                    void 0 === e && (e = !1), this.game = t, this.isRunning = !1, this.forceSetTimeOut = e;
                    for (var i = ["ms", "moz", "webkit", "o"], s = 0; s < i.length && !window.requestAnimationFrame; s++) window.requestAnimationFrame = window[i[s] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[i[s] + "CancelAnimationFrame"] || window[i[s] + "CancelRequestAnimationFrame"];
                    this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null
                }, n.RequestAnimationFrame.prototype = {
                    start: function() {
                        this.isRunning = !0;
                        var t = this;
                        !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
                            return t.updateSetTimeout()
                        }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(e) {
                            return t.updateRAF(e)
                        }, this._timeOutID = window.requestAnimationFrame(this._onLoop))
                    },
                    updateRAF: function(t) {
                        this.isRunning && (this.game.update(Math.floor(t)), this._timeOutID = window.requestAnimationFrame(this._onLoop))
                    },
                    updateSetTimeout: function() {
                        this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall))
                    },
                    stop: function() {
                        this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1
                    },
                    isSetTimeOut: function() {
                        return this._isSetTimeOut
                    },
                    isRAF: function() {
                        return !1 === this._isSetTimeOut
                    }
                }, n.RequestAnimationFrame.prototype.constructor = n.RequestAnimationFrame, n.Math = {
                    PI2: 2 * Math.PI,
                    HALF_PI: .5 * Math.PI,
                    DEG_TO_RAD: Math.PI / 180,
                    RAD_TO_DEG: 180 / Math.PI,
                    degToRad: function(t) {
                        return t * n.Math.DEG_TO_RAD
                    },
                    radToDeg: function(t) {
                        return t * n.Math.RAD_TO_DEG
                    },
                    getNextPowerOfTwo: function(t) {
                        if (t > 0 && 0 == (t & t - 1)) return t;
                        for (var e = 1; e < t;) e <<= 1;
                        return e
                    },
                    isPowerOfTwo: function(t, e) {
                        return t > 0 && 0 == (t & t - 1) && e > 0 && 0 == (e & e - 1)
                    },
                    random: function(t, e) {
                        if (void 0 === t && (t = 0), void 0 === e && (e = 1), t === e) return t;
                        if (t > e) {
                            var i = t;
                            t = e, e = i
                        }
                        return Math.random() * (e - t) + t
                    },
                    between: function(t, e) {
                        if (void 0 === t && (t = 0), void 0 === e && (e = 1), t === e) return t;
                        if (t > e) {
                            var i = t;
                            t = e, e = i
                        }
                        return t = Math.ceil(t), e = Math.floor(e), Math.floor(Math.random() * (e - t + 1)) + t
                    },
                    fuzzyEqual: function(t, e, i) {
                        return void 0 === i && (i = 1e-4), Math.abs(t - e) < i
                    },
                    fuzzyLessThan: function(t, e, i) {
                        return void 0 === i && (i = 1e-4), t < e + i
                    },
                    fuzzyGreaterThan: function(t, e, i) {
                        return void 0 === i && (i = 1e-4), t > e - i
                    },
                    fuzzyCeil: function(t, e) {
                        return void 0 === e && (e = 1e-4), Math.ceil(t - e)
                    },
                    fuzzyFloor: function(t, e) {
                        return void 0 === e && (e = 1e-4), Math.floor(t + e)
                    },
                    average: function() {
                        for (var t = 0, e = arguments.length, i = 0; i < e; i++) t += +arguments[i];
                        return t / e
                    },
                    shear: function(t) {
                        return t % 1
                    },
                    snapTo: function(t, e, i) {
                        return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.round(t / e)))
                    },
                    snapToFloor: function(t, e, i) {
                        return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.floor(t / e)))
                    },
                    snapToCeil: function(t, e, i) {
                        return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.ceil(t / e)))
                    },
                    roundTo: function(t, e, i) {
                        void 0 === e && (e = 0), void 0 === i && (i = 10);
                        var s = Math.pow(i, -e);
                        return Math.round(t * s) / s
                    },
                    floorTo: function(t, e, i) {
                        void 0 === e && (e = 0), void 0 === i && (i = 10);
                        var s = Math.pow(i, -e);
                        return Math.floor(t * s) / s
                    },
                    ceilTo: function(t, e, i) {
                        void 0 === e && (e = 0), void 0 === i && (i = 10);
                        var s = Math.pow(i, -e);
                        return Math.ceil(t * s) / s
                    },
                    trunc: function(t) {
                        return isFinite(t) ? t - t % 1 || (t < 0 ? -0 : 0 === t ? t : 0) : t
                    },
                    rotateToAngle: function(t, e, i) {
                        return void 0 === i && (i = .05), t === e ? t : (Math.abs(e - t) <= i || Math.abs(e - t) >= n.Math.PI2 - i ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += n.Math.PI2 : e -= n.Math.PI2), e > t ? t += i : e < t && (t -= i)), t)
                    },
                    getShortestAngle: function(t, e) {
                        var i = e - t;
                        return 0 === i ? 0 : i - 360 * Math.floor((i - -180) / 360)
                    },
                    angleBetween: function(t, e, i, s) {
                        return Math.atan2(s - e, i - t)
                    },
                    angleBetweenY: function(t, e, i, s) {
                        return Math.atan2(i - t, s - e)
                    },
                    angleBetweenPoints: function(t, e) {
                        return Math.atan2(e.y - t.y, e.x - t.x)
                    },
                    angleBetweenPointsY: function(t, e) {
                        return Math.atan2(e.x - t.x, e.y - t.y)
                    },
                    reverseAngle: function(t) {
                        return this.normalizeAngle(t + Math.PI, !0)
                    },
                    normalizeAngle: function(t) {
                        return (t %= 2 * Math.PI) >= 0 ? t : t + 2 * Math.PI
                    },
                    maxAdd: function(t, e, i) {
                        return Math.min(t + e, i)
                    },
                    minSub: function(t, e, i) {
                        return Math.max(t - e, i)
                    },
                    wrap: function(t, e, i) {
                        var s = i - e;
                        if (s <= 0) return 0;
                        var n = (t - e) % s;
                        return n < 0 && (n += s), n + e
                    },
                    wrapValue: function(t, e, i) {
                        return ((t = Math.abs(t)) + (e = Math.abs(e))) % (i = Math.abs(i))
                    },
                    isOdd: function(t) {
                        return !!(1 & t)
                    },
                    isEven: function(t) {
                        return !(1 & t)
                    },
                    min: function() {
                        if (1 === arguments.length && "object" == typeof arguments[0]) var t = arguments[0];
                        else t = arguments;
                        for (var e = 1, i = 0, s = t.length; e < s; e++) t[e] < t[i] && (i = e);
                        return t[i]
                    },
                    max: function() {
                        if (1 === arguments.length && "object" == typeof arguments[0]) var t = arguments[0];
                        else t = arguments;
                        for (var e = 1, i = 0, s = t.length; e < s; e++) t[e] > t[i] && (i = e);
                        return t[i]
                    },
                    minProperty: function(t) {
                        if (2 === arguments.length && "object" == typeof arguments[1]) var e = arguments[1];
                        else e = arguments.slice(1);
                        for (var i = 1, s = 0, n = e.length; i < n; i++) e[i][t] < e[s][t] && (s = i);
                        return e[s][t]
                    },
                    maxProperty: function(t) {
                        if (2 === arguments.length && "object" == typeof arguments[1]) var e = arguments[1];
                        else e = arguments.slice(1);
                        for (var i = 1, s = 0, n = e.length; i < n; i++) e[i][t] > e[s][t] && (s = i);
                        return e[s][t]
                    },
                    wrapAngle: function(t, e) {
                        return e ? this.wrap(t, -Math.PI, Math.PI) : this.wrap(t, -180, 180)
                    },
                    linearInterpolation: function(t, e) {
                        var i = t.length - 1,
                            s = i * e,
                            n = Math.floor(s);
                        return e < 0 ? this.linear(t[0], t[1], s) : e > 1 ? this.linear(t[i], t[i - 1], i - s) : this.linear(t[n], t[n + 1 > i ? i : n + 1], s - n)
                    },
                    bezierInterpolation: function(t, e) {
                        for (var i = 0, s = t.length - 1, n = 0; n <= s; n++) i += Math.pow(1 - e, s - n) * Math.pow(e, n) * t[n] * this.bernstein(s, n);
                        return i
                    },
                    catmullRomInterpolation: function(t, e) {
                        var i = t.length - 1,
                            s = i * e,
                            n = Math.floor(s);
                        return t[0] === t[i] ? (e < 0 && (n = Math.floor(s = i * (1 + e))), this.catmullRom(t[(n - 1 + i) % i], t[n], t[(n + 1) % i], t[(n + 2) % i], s - n)) : e < 0 ? t[0] - (this.catmullRom(t[0], t[0], t[1], t[1], -s) - t[0]) : e > 1 ? t[i] - (this.catmullRom(t[i], t[i], t[i - 1], t[i - 1], s - i) - t[i]) : this.catmullRom(t[n ? n - 1 : 0], t[n], t[i < n + 1 ? i : n + 1], t[i < n + 2 ? i : n + 2], s - n)
                    },
                    linear: function(t, e, i) {
                        return (e - t) * i + t
                    },
                    bernstein: function(t, e) {
                        return this.factorial(t) / this.factorial(e) / this.factorial(t - e)
                    },
                    factorial: function(t) {
                        if (0 === t) return 1;
                        for (var e = t; --t;) e *= t;
                        return e
                    },
                    catmullRom: function(t, e, i, s, n) {
                        var r = .5 * (i - t),
                            o = .5 * (s - e),
                            a = n * n;
                        return (2 * e - 2 * i + r + o) * (n * a) + (-3 * e + 3 * i - 2 * r - o) * a + r * n + e
                    },
                    difference: function(t, e) {
                        return Math.abs(t - e)
                    },
                    roundAwayFromZero: function(t) {
                        return t > 0 ? Math.ceil(t) : Math.floor(t)
                    },
                    sinCosGenerator: function(t, e, i, s) {
                        void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = 1);
                        for (var n = e, r = i, o = s * Math.PI / t, a = [], h = [], l = 0; l < t; l++) n += (r -= n * o) * o, a[l] = r, h[l] = n;
                        return {
                            sin: h,
                            cos: a,
                            length: t
                        }
                    },
                    hypot: function(t, e) {
                        return Math.sqrt(t * t + e * e)
                    },
                    distance: function(t, e, i, s) {
                        var n = t - i,
                            r = e - s;
                        return Math.sqrt(n * n + r * r)
                    },
                    distanceSq: function(t, e, i, s) {
                        var n = t - i,
                            r = e - s;
                        return n * n + r * r
                    },
                    distancePow: function(t, e, i, s, n) {
                        return void 0 === n && (n = 2), Math.sqrt(Math.pow(i - t, n) + Math.pow(s - e, n))
                    },
                    clamp: function(t, e, i) {
                        return t < e ? e : i < t ? i : t
                    },
                    clampBottom: function(t, e) {
                        return t < e ? e : t
                    },
                    within: function(t, e, i) {
                        return Math.abs(t - e) <= i
                    },
                    mapLinear: function(t, e, i, s, n) {
                        return s + (t - e) * (n - s) / (i - e)
                    },
                    smoothstep: function(t, e, i) {
                        return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * (3 - 2 * t)
                    },
                    smootherstep: function(t, e, i) {
                        return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10)
                    },
                    sign: function(t) {
                        return t < 0 ? -1 : t > 0 ? 1 : 0
                    },
                    percent: function(t, e, i) {
                        return void 0 === i && (i = 0), t > e || i > e ? 1 : t < i || i > t ? 0 : (t - i) / e
                    }
                }, n.RandomDataGenerator = function(t) {
                    void 0 === t && (t = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, "string" == typeof t ? this.state(t) : this.sow(t)
                }, n.RandomDataGenerator.prototype = {
                    rnd: function() {
                        var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
                        return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2
                    },
                    sow: function(t) {
                        if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, t)
                            for (var e = 0; e < t.length && null != t[e]; e++) {
                                var i = t[e];
                                this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0)
                            }
                    },
                    hash: function(t) {
                        var e, i, s;
                        for (s = 4022871197, t = t.toString(), i = 0; i < t.length; i++) e = .02519603282416938 * (s += t.charCodeAt(i)), e -= s = e >>> 0, s = (e *= s) >>> 0, s += 4294967296 * (e -= s);
                        return 2.3283064365386963e-10 * (s >>> 0)
                    },
                    integer: function() {
                        return 4294967296 * this.rnd.apply(this)
                    },
                    frac: function() {
                        return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0)
                    },
                    real: function() {
                        return this.integer() + this.frac()
                    },
                    integerInRange: function(t, e) {
                        return Math.floor(this.realInRange(0, e - t + 1) + t)
                    },
                    between: function(t, e) {
                        return this.integerInRange(t, e)
                    },
                    realInRange: function(t, e) {
                        return this.frac() * (e - t) + t
                    },
                    normal: function() {
                        return 1 - 2 * this.frac()
                    },
                    uuid: function() {
                        var t = "",
                            e = "";
                        for (e = t = ""; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : "-");
                        return e
                    },
                    pick: function(t) {
                        return t[this.integerInRange(0, t.length - 1)]
                    },
                    sign: function() {
                        return this.pick([-1, 1])
                    },
                    weightedPick: function(t) {
                        return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + .5)]
                    },
                    timestamp: function(t, e) {
                        return this.realInRange(t || 9466848e5, e || 1577862e6)
                    },
                    angle: function() {
                        return this.integerInRange(-180, 180)
                    },
                    state: function(t) {
                        return "string" == typeof t && t.match(/^!rnd/) && (t = t.split(","), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
                    }
                }, n.RandomDataGenerator.prototype.constructor = n.RandomDataGenerator, n.QuadTree = function(t, e, i, s, n, r, o) {
                    this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(t, e, i, s, n, r, o)
                }, n.QuadTree.prototype = {
                    reset: function(t, e, i, s, n, r, o) {
                        this.maxObjects = n || 10, this.maxLevels = r || 4, this.level = o || 0, this.bounds = {
                            x: Math.round(t),
                            y: Math.round(e),
                            width: i,
                            height: s,
                            subWidth: Math.floor(i / 2),
                            subHeight: Math.floor(s / 2),
                            right: Math.round(t) + Math.floor(i / 2),
                            bottom: Math.round(e) + Math.floor(s / 2)
                        }, this.objects.length = 0, this.nodes.length = 0
                    },
                    populate: function(t) {
                        t.forEach(this.populateHandler, this, !0)
                    },
                    populateHandler: function(t) {
                        t.body && t.exists && this.insert(t.body)
                    },
                    split: function() {
                        this.nodes[0] = new n.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new n.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new n.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new n.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)
                    },
                    insert: function(t) {
                        var e, i = 0;
                        if (null == this.nodes[0] || -1 === (e = this.getIndex(t))) {
                            if (this.objects.push(t), this.objects.length > this.maxObjects && this.level < this.maxLevels)
                                for (null == this.nodes[0] && this.split(); i < this.objects.length;) - 1 !== (e = this.getIndex(this.objects[i])) ? this.nodes[e].insert(this.objects.splice(i, 1)[0]) : i++
                        } else this.nodes[e].insert(t)
                    },
                    getIndex: function(t) {
                        var e = -1;
                        return t.x < this.bounds.right && t.right < this.bounds.right ? t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 1 : t.y > this.bounds.bottom && (e = 2) : t.x > this.bounds.right && (t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 0 : t.y > this.bounds.bottom && (e = 3)), e
                    },
                    retrieve: function(t) {
                        if (t instanceof n.Rectangle) var e = this.objects,
                            i = this.getIndex(t);
                        else {
                            if (!t.body) return this._empty;
                            e = this.objects, i = this.getIndex(t.body)
                        }
                        return this.nodes[0] && (e = -1 !== i ? e.concat(this.nodes[i].retrieve(t)) : (e = (e = (e = e.concat(this.nodes[0].retrieve(t))).concat(this.nodes[1].retrieve(t))).concat(this.nodes[2].retrieve(t))).concat(this.nodes[3].retrieve(t))), e
                    },
                    clear: function() {
                        this.objects.length = 0;
                        for (var t = this.nodes.length; t--;) this.nodes[t].clear(), this.nodes.splice(t, 1);
                        this.nodes.length = 0
                    }
                }, n.QuadTree.prototype.constructor = n.QuadTree, n.Net = function(t) {
                    this.game = t
                }, n.Net.prototype = {
                    getHostName: function() {
                        return window.location && window.location.hostname ? window.location.hostname : null
                    },
                    checkDomainName: function(t) {
                        return -1 !== window.location.hostname.indexOf(t)
                    },
                    updateQueryString: function(t, e, i, s) {
                        void 0 === i && (i = !1), void 0 !== s && "" !== s || (s = window.location.href);
                        var n = "",
                            r = new RegExp("([?|&])" + t + "=.*?(&|#|$)(.*)", "gi");
                        if (r.test(s)) n = void 0 !== e && null !== e ? s.replace(r, "$1" + t + "=" + e + "$2$3") : s.replace(r, "$1$3").replace(/(&|\?)$/, "");
                        else if (void 0 !== e && null !== e) {
                            var o = -1 !== s.indexOf("?") ? "&" : "?",
                                a = s.split("#");
                            s = a[0] + o + t + "=" + e, a[1] && (s += "#" + a[1]), n = s
                        } else n = s;
                        if (!i) return n;
                        window.location.href = n
                    },
                    getQueryString: function(t) {
                        void 0 === t && (t = "");
                        var e = {},
                            i = location.search.substring(1).split("&");
                        for (var s in i) {
                            var n = i[s].split("=");
                            if (n.length > 1) {
                                if (t && t === this.decodeURI(n[0])) return this.decodeURI(n[1]);
                                e[this.decodeURI(n[0])] = this.decodeURI(n[1])
                            }
                        }
                        return e
                    },
                    decodeURI: function(t) {
                        return decodeURIComponent(t.replace(/\+/g, " "))
                    }
                }, n.Net.prototype.constructor = n.Net, n.TweenManager = function(t) {
                    this.game = t, this.frameBased = !1, this._tweens = [], this._add = [], this.easeMap = {
                        Power0: n.Easing.Power0,
                        Power1: n.Easing.Power1,
                        Power2: n.Easing.Power2,
                        Power3: n.Easing.Power3,
                        Power4: n.Easing.Power4,
                        Linear: n.Easing.Linear.None,
                        Quad: n.Easing.Quadratic.Out,
                        Cubic: n.Easing.Cubic.Out,
                        Quart: n.Easing.Quartic.Out,
                        Quint: n.Easing.Quintic.Out,
                        Sine: n.Easing.Sinusoidal.Out,
                        Expo: n.Easing.Exponential.Out,
                        Circ: n.Easing.Circular.Out,
                        Elastic: n.Easing.Elastic.Out,
                        Back: n.Easing.Back.Out,
                        Bounce: n.Easing.Bounce.Out,
                        "Quad.easeIn": n.Easing.Quadratic.In,
                        "Cubic.easeIn": n.Easing.Cubic.In,
                        "Quart.easeIn": n.Easing.Quartic.In,
                        "Quint.easeIn": n.Easing.Quintic.In,
                        "Sine.easeIn": n.Easing.Sinusoidal.In,
                        "Expo.easeIn": n.Easing.Exponential.In,
                        "Circ.easeIn": n.Easing.Circular.In,
                        "Elastic.easeIn": n.Easing.Elastic.In,
                        "Back.easeIn": n.Easing.Back.In,
                        "Bounce.easeIn": n.Easing.Bounce.In,
                        "Quad.easeOut": n.Easing.Quadratic.Out,
                        "Cubic.easeOut": n.Easing.Cubic.Out,
                        "Quart.easeOut": n.Easing.Quartic.Out,
                        "Quint.easeOut": n.Easing.Quintic.Out,
                        "Sine.easeOut": n.Easing.Sinusoidal.Out,
                        "Expo.easeOut": n.Easing.Exponential.Out,
                        "Circ.easeOut": n.Easing.Circular.Out,
                        "Elastic.easeOut": n.Easing.Elastic.Out,
                        "Back.easeOut": n.Easing.Back.Out,
                        "Bounce.easeOut": n.Easing.Bounce.Out,
                        "Quad.easeInOut": n.Easing.Quadratic.InOut,
                        "Cubic.easeInOut": n.Easing.Cubic.InOut,
                        "Quart.easeInOut": n.Easing.Quartic.InOut,
                        "Quint.easeInOut": n.Easing.Quintic.InOut,
                        "Sine.easeInOut": n.Easing.Sinusoidal.InOut,
                        "Expo.easeInOut": n.Easing.Exponential.InOut,
                        "Circ.easeInOut": n.Easing.Circular.InOut,
                        "Elastic.easeInOut": n.Easing.Elastic.InOut,
                        "Back.easeInOut": n.Easing.Back.InOut,
                        "Bounce.easeInOut": n.Easing.Bounce.InOut
                    }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this)
                }, n.TweenManager.prototype = {
                    getAll: function() {
                        return this._tweens
                    },
                    removeAll: function() {
                        for (var t = 0; t < this._tweens.length; t++) this._tweens[t].pendingDelete = !0;
                        this._add = []
                    },
                    removeFrom: function(t, e) {
                        if (void 0 === e && (e = !0), Array.isArray(t))
                            for (i = 0, s = t.length; i < s; i++) this.removeFrom(t[i]);
                        else if (t.type === n.GROUP && e)
                            for (var i = 0, s = t.children.length; i < s; i++) this.removeFrom(t.children[i]);
                        else {
                            for (i = 0, s = this._tweens.length; i < s; i++) t === this._tweens[i].target && this.remove(this._tweens[i]);
                            for (i = 0, s = this._add.length; i < s; i++) t === this._add[i].target && this.remove(this._add[i])
                        }
                    },
                    add: function(t) {
                        t._manager = this, this._add.push(t)
                    },
                    create: function(t) {
                        return new n.Tween(t, this.game, this)
                    },
                    remove: function(t) {
                        var e = this._tweens.indexOf(t); - 1 !== e ? this._tweens[e].pendingDelete = !0 : -1 !== (e = this._add.indexOf(t)) && (this._add[e].pendingDelete = !0)
                    },
                    update: function() {
                        var t = this._add.length,
                            e = this._tweens.length;
                        if (0 === e && 0 === t) return !1;
                        for (var i = 0; i < e;) this._tweens[i].update(this.game.time.time) ? i++ : (this._tweens.splice(i, 1), e--);
                        return t > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0
                    },
                    isTweening: function(t, e) {
                        return e || (e = !1), this._tweens.some(function(i) {
                            return i.target === t && (!e || i.isRunning && !i.pendingDelete)
                        })
                    },
                    _pauseAll: function() {
                        for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._pause()
                    },
                    _resumeAll: function() {
                        for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._resume()
                    },
                    pauseAll: function() {
                        for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].pause()
                    },
                    resumeAll: function() {
                        for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].resume(!0)
                    },
                    destroy: function() {
                        this.game.onPause.remove(this._pauseAll, this), this.game.onResume.remove(this._resumeAll, this), this.game = null, this._add = null, this._tweens = null
                    }
                }, n.TweenManager.prototype.constructor = n.TweenManager, n.Tween = function(t, e, i) {
                    this.game = e, this.target = t, this.manager = i, this.timeline = [], this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new n.Signal, this.onLoop = new n.Signal, this.onRepeat = new n.Signal, this.onChildComplete = new n.Signal, this.onComplete = new n.Signal, this.isRunning = !1, this.current = 0, this.properties = {}, this.chainedTween = null, this.isPaused = !1, this.frameBased = i.frameBased, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, this._hasStarted = !1
                }, n.Tween.updateColor = function(t) {
                    n.Color.updateColor(t.target)
                }, n.Tween.prototype = {
                    to: function(t, e, i, s, r, o, a) {
                        return (void 0 === e || e <= 0) && (e = 1e3), void 0 !== i && null !== i || (i = n.Easing.Default), void 0 === s && (s = !1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = !1), "string" == typeof i && this.manager.easeMap[i] && (i = this.manager.easeMap[i]), this.isRunning ? (console.warn("Phaser.Tween.to cannot be called after Tween.start"), this) : (this.timeline.push(new n.TweenData(this).to(t, e, i, r, o, a)), s && this.start(), this)
                    },
                    from: function(t, e, i, s, r, o, a) {
                        return void 0 === e && (e = 1e3), void 0 !== i && null !== i || (i = n.Easing.Default), void 0 === s && (s = !1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = !1), "string" == typeof i && this.manager.easeMap[i] && (i = this.manager.easeMap[i]), this.isRunning ? (console.warn("Phaser.Tween.from cannot be called after Tween.start"), this) : (this.timeline.push(new n.TweenData(this).from(t, e, i, r, o, a)), s && this.start(), this)
                    },
                    start: function(t) {
                        if (void 0 === t && (t = 0), this.pendingDelete) return console.warn("Phaser.Tween.start cannot be called after Tween.stop"), this;
                        if (null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
                        for (var e = 0; e < this.timeline.length; e++)
                            for (var i in this.timeline[e].vEnd) this.properties[i] = this.target[i] || 0, Array.isArray(this.properties[i]) || (this.properties[i] *= 1);
                        for (e = 0; e < this.timeline.length; e++) this.timeline[e].loadValues();
                        return this.manager.add(this), this.isRunning = !0, (t < 0 || t > this.timeline.length - 1) && (t = 0), this.current = t, this.timeline[this.current].start(), this
                    },
                    stop: function(t) {
                        return void 0 === t && (t = !1), this.isRunning = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, t && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this
                    },
                    updateTweenData: function(t, e, i) {
                        if (0 === this.timeline.length) return this;
                        if (void 0 === i && (i = 0), -1 === i)
                            for (var s = 0; s < this.timeline.length; s++) this.timeline[s][t] = e;
                        else this.timeline[i][t] = e;
                        return this
                    },
                    delay: function(t, e) {
                        return this.updateTweenData("delay", t, e)
                    },
                    repeat: function(t, e, i) {
                        return void 0 === e && (e = 0), this.updateTweenData("repeatCounter", t, i), this.updateTweenData("repeatTotal", t, i), this.updateTweenData("repeatDelay", e, i)
                    },
                    repeatDelay: function(t, e) {
                        return this.updateTweenData("repeatDelay", t, e)
                    },
                    yoyo: function(t, e, i) {
                        return void 0 === e && (e = 0), this.updateTweenData("yoyo", t, i), this.updateTweenData("yoyoDelay", e, i)
                    },
                    yoyoDelay: function(t, e) {
                        return this.updateTweenData("yoyoDelay", t, e)
                    },
                    easing: function(t, e) {
                        return "string" == typeof t && this.manager.easeMap[t] && (t = this.manager.easeMap[t]), this.updateTweenData("easingFunction", t, e)
                    },
                    interpolation: function(t, e, i) {
                        return void 0 === e && (e = n.Math), this.updateTweenData("interpolationFunction", t, i), this.updateTweenData("interpolationContext", e, i)
                    },
                    repeatAll: function(t) {
                        return void 0 === t && (t = 0), this.repeatCounter = t, this
                    },
                    chain: function() {
                        for (var t = arguments.length; t--;) t > 0 ? arguments[t - 1].chainedTween = arguments[t] : this.chainedTween = arguments[t];
                        return this
                    },
                    loop: function(t) {
                        return void 0 === t && (t = !0), this.repeatCounter = t ? -1 : 0, this
                    },
                    onUpdateCallback: function(t, e) {
                        return this._onUpdateCallback = t, this._onUpdateCallbackContext = e, this
                    },
                    pause: function() {
                        this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time
                    },
                    _pause: function() {
                        this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time)
                    },
                    resume: function() {
                        if (this.isPaused) {
                            this.isPaused = !1, this._codePaused = !1;
                            for (var t = 0; t < this.timeline.length; t++) this.timeline[t].isRunning || (this.timeline[t].startTime += this.game.time.time - this._pausedTime)
                        }
                    },
                    _resume: function() {
                        this._codePaused || this.resume()
                    },
                    update: function(t) {
                        if (this.pendingDelete || !this.target) return !1;
                        if (this.isPaused) return !0;
                        var e = this.timeline[this.current].update(t);
                        if (e === n.TweenData.PENDING) return !0;
                        if (e === n.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning;
                        if (e === n.TweenData.LOOPED) return -1 === this.timeline[this.current].repeatCounter ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), !0;
                        if (e === n.TweenData.COMPLETE) {
                            var i = !1;
                            return this.reverse ? (this.current--, this.current < 0 && (this.current = this.timeline.length - 1, i = !0)) : (this.current++, this.current === this.timeline.length && (this.current = 0, i = !0)), i ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : this.repeatCounter > 0 ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0)
                        }
                    },
                    generateData: function(t, e) {
                        if (null === this.game || null === this.target) return null;
                        void 0 === t && (t = 60), void 0 === e && (e = []);
                        for (var i = 0; i < this.timeline.length; i++)
                            for (var s in this.timeline[i].vEnd) this.properties[s] = this.target[s] || 0, Array.isArray(this.properties[s]) || (this.properties[s] *= 1);
                        for (i = 0; i < this.timeline.length; i++) this.timeline[i].loadValues();
                        for (i = 0; i < this.timeline.length; i++) e = e.concat(this.timeline[i].generateData(t));
                        return e
                    }
                }, Object.defineProperty(n.Tween.prototype, "totalDuration", {
                    get: function() {
                        for (var t = 0, e = 0; e < this.timeline.length; e++) t += this.timeline[e].duration;
                        return t
                    }
                }), n.Tween.prototype.constructor = n.Tween, n.TweenData = function(t) {
                    this.parent = t, this.game = t.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, this.repeatCounter = 0, this.repeatDelay = 0, this.repeatTotal = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = n.Easing.Default, this.interpolationFunction = n.Math.linearInterpolation, this.interpolationContext = n.Math, this.isRunning = !1, this.isFrom = !1
                }, n.TweenData.PENDING = 0, n.TweenData.RUNNING = 1, n.TweenData.LOOPED = 2, n.TweenData.COMPLETE = 3, n.TweenData.prototype = {
                    to: function(t, e, i, s, n, r) {
                        return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = s, this.repeatTotal = n, this.yoyo = r, this.isFrom = !1, this
                    },
                    from: function(t, e, i, s, n, r) {
                        return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = s, this.repeatTotal = n, this.yoyo = r, this.isFrom = !0, this
                    },
                    start: function() {
                        if (this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, this.delay > 0 ? this.isRunning = !1 : this.isRunning = !0, this.isFrom)
                            for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t], this.parent.target[t] = this.vStart[t];
                        return this.value = 0, this.repeatCounter = this.repeatTotal, this
                    },
                    loadValues: function() {
                        for (var t in this.parent.properties) {
                            if (this.vStart[t] = this.parent.properties[t], Array.isArray(this.vEnd[t])) {
                                if (0 === this.vEnd[t].length) continue;
                                0 === this.percent && (this.vEnd[t] = [this.vStart[t]].concat(this.vEnd[t]))
                            }
                            void 0 !== this.vEnd[t] ? ("string" == typeof this.vEnd[t] && (this.vEnd[t] = this.vStart[t] + parseFloat(this.vEnd[t])), this.parent.properties[t] = this.vEnd[t]) : this.vEnd[t] = this.vStart[t], this.vStartCache[t] = this.vStart[t], this.vEndCache[t] = this.vEnd[t]
                        }
                        return this
                    },
                    update: function(t) {
                        if (this.isRunning) {
                            if (t < this.startTime) return n.TweenData.RUNNING
                        } else {
                            if (!(t >= this.startTime)) return n.TweenData.PENDING;
                            this.isRunning = !0
                        }
                        var e = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
                        this.parent.reverse ? (this.dt -= e * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += e * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                        for (var i in this.vEnd) {
                            var s = this.vStart[i],
                                r = this.vEnd[i];
                            Array.isArray(r) ? this.parent.target[i] = this.interpolationFunction.call(this.interpolationContext, r, this.value) : this.parent.target[i] = s + (r - s) * this.value
                        }
                        return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : n.TweenData.RUNNING
                    },
                    generateData: function(t) {
                        this.parent.reverse ? this.dt = this.duration : this.dt = 0;
                        var e = [],
                            i = !1,
                            s = 1 / t * 1e3;
                        do {
                            this.parent.reverse ? (this.dt -= s, this.dt = Math.max(this.dt, 0)) : (this.dt += s, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                            var n = {};
                            for (var r in this.vEnd) {
                                var o = this.vStart[r],
                                    a = this.vEnd[r];
                                Array.isArray(a) ? n[r] = this.interpolationFunction.call(this.interpolationContext, a, this.value) : n[r] = o + (a - o) * this.value
                            }
                            e.push(n), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (i = !0)
                        } while (!i);
                        if (this.yoyo) {
                            var h = e.slice();
                            h.reverse(), e = e.concat(h)
                        }
                        return e
                    },
                    repeat: function() {
                        if (this.yoyo) {
                            if (this.inReverse && 0 === this.repeatCounter) {
                                for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                                return this.inReverse = !1, n.TweenData.COMPLETE
                            }
                            this.inReverse = !this.inReverse
                        } else if (0 === this.repeatCounter) return n.TweenData.COMPLETE;
                        if (this.inReverse)
                            for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t];
                        else {
                            for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                            this.repeatCounter > 0 && this.repeatCounter--
                        }
                        return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, n.TweenData.LOOPED
                    }
                }, n.TweenData.prototype.constructor = n.TweenData, n.Easing = {
                    Linear: {
                        None: function(t) {
                            return t
                        }
                    },
                    Quadratic: {
                        In: function(t) {
                            return t * t
                        },
                        Out: function(t) {
                            return t * (2 - t)
                        },
                        InOut: function(t) {
                            return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
                        }
                    },
                    Cubic: {
                        In: function(t) {
                            return t * t * t
                        },
                        Out: function(t) {
                            return --t * t * t + 1
                        },
                        InOut: function(t) {
                            return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
                        }
                    },
                    Quartic: {
                        In: function(t) {
                            return t * t * t * t
                        },
                        Out: function(t) {
                            return 1 - --t * t * t * t
                        },
                        InOut: function(t) {
                            return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
                        }
                    },
                    Quintic: {
                        In: function(t) {
                            return t * t * t * t * t
                        },
                        Out: function(t) {
                            return --t * t * t * t * t + 1
                        },
                        InOut: function(t) {
                            return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
                        }
                    },
                    Sinusoidal: {
                        In: function(t) {
                            return 0 === t ? 0 : 1 === t ? 1 : 1 - Math.cos(t * Math.PI / 2)
                        },
                        Out: function(t) {
                            return 0 === t ? 0 : 1 === t ? 1 : Math.sin(t * Math.PI / 2)
                        },
                        InOut: function(t) {
                            return 0 === t ? 0 : 1 === t ? 1 : .5 * (1 - Math.cos(Math.PI * t))
                        }
                    },
                    Exponential: {
                        In: function(t) {
                            return 0 === t ? 0 : Math.pow(1024, t - 1)
                        },
                        Out: function(t) {
                            return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                        },
                        InOut: function(t) {
                            return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                        }
                    },
                    Circular: {
                        In: function(t) {
                            return 1 - Math.sqrt(1 - t * t)
                        },
                        Out: function(t) {
                            return Math.sqrt(1 - --t * t)
                        },
                        InOut: function(t) {
                            return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                        }
                    },
                    Elastic: {
                        In: function(t) {
                            return 0 === t ? 0 : 1 === t ? 1 : (.1, -1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - .1) * (2 * Math.PI) / .4))
                        },
                        Out: function(t) {
                            return 0 === t ? 0 : 1 === t ? 1 : (.1, 1 * Math.pow(2, -10 * t) * Math.sin((t - .1) * (2 * Math.PI) / .4) + 1)
                        },
                        InOut: function(t) {
                            return 0 === t ? 0 : 1 === t ? 1 : (.1, (t *= 2) < 1 ? 1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - .1) * (2 * Math.PI) / .4) * -.5 : 1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - .1) * (2 * Math.PI) / .4) * .5 + 1)
                        }
                    },
                    Back: {
                        In: function(t) {
                            return t * t * (2.70158 * t - 1.70158)
                        },
                        Out: function(t) {
                            return --t * t * (2.70158 * t + 1.70158) + 1
                        },
                        InOut: function(t) {
                            var e = 2.5949095;
                            return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
                        }
                    },
                    Bounce: {
                        In: function(t) {
                            return 1 - n.Easing.Bounce.Out(1 - t)
                        },
                        Out: function(t) {
                            return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                        },
                        InOut: function(t) {
                            return t < .5 ? .5 * n.Easing.Bounce.In(2 * t) : .5 * n.Easing.Bounce.Out(2 * t - 1) + .5
                        }
                    }
                }, n.Easing.Default = n.Easing.Linear.None, n.Easing.Power0 = n.Easing.Linear.None, n.Easing.Power1 = n.Easing.Quadratic.Out, n.Easing.Power2 = n.Easing.Cubic.Out, n.Easing.Power3 = n.Easing.Quartic.Out, n.Easing.Power4 = n.Easing.Quintic.Out, n.Time = function(t) {
                    this.game = t, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, this.elapsedMS = 0, this.physicsElapsed = 1 / 60, this.physicsElapsedMS = 1 / 60 * 1e3, this.desiredFpsMult = 1 / 60, this._desiredFps = 60, this.suggestedFps = this.desiredFps, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, this.updates = 0, this.renders = 0, this.fps = 0, this.ups = 0, this.rps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new n.Timer(this.game, !1), this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._justResumed = !1, this._timers = []
                }, n.Time.prototype = {
                    boot: function() {
                        this._started = Date.now(), this.time = Date.now(), this.events.start(), this.timeExpected = this.time
                    },
                    add: function(t) {
                        return this._timers.push(t), t
                    },
                    create: function(t) {
                        void 0 === t && (t = !0);
                        var e = new n.Timer(this.game, t);
                        return this._timers.push(e), e
                    },
                    removeAll: function() {
                        for (var t = 0; t < this._timers.length; t++) this._timers[t].destroy();
                        this._timers = [], this.events.removeAll()
                    },
                    refresh: function() {
                        var t = this.time;
                        this.time = Date.now(), this.elapsedMS = this.time - t
                    },
                    update: function(t) {
                        var e = this.time;
                        this.time = Date.now(), this.elapsedMS = this.time - e, this.prevTime = this.now, this.now = t, this.elapsed = this.now - this.prevTime, this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - t))), this.timeExpected = t + this.timeToCall), this.advancedTiming && this.updateAdvancedTiming(), this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers())
                    },
                    updateTimers: function() {
                        for (var t = 0, e = this._timers.length; t < e;) this._timers[t].update(this.time) ? t++ : (this._timers.splice(t, 1), e--)
                    },
                    updateAdvancedTiming: function() {
                        if (this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3) {
                            var t = this.now - this._timeLastSecond;
                            this.fps = Math.round(1e3 * this.frames / t), this.ups = Math.round(1e3 * this.updates / t), this.rps = Math.round(1e3 * this.renders / t), this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0, this.updates = 0, this.renders = 0
                        }
                    },
                    countUpdate: function() {
                        this.advancedTiming && this.updates++
                    },
                    countRender: function() {
                        this.advancedTiming && this.renders++
                    },
                    gamePaused: function() {
                        this._pauseStarted = Date.now(), this.events.pause();
                        for (var t = this._timers.length; t--;) this._timers[t]._pause()
                    },
                    gameResumed: function() {
                        this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume();
                        for (var t = this._timers.length; t--;) this._timers[t]._resume()
                    },
                    totalElapsedSeconds: function() {
                        return .001 * (this.time - this._started)
                    },
                    elapsedSince: function(t) {
                        return this.time - t
                    },
                    elapsedSecondsSince: function(t) {
                        return .001 * (this.time - t)
                    },
                    reset: function() {
                        this._started = this.time, this.removeAll()
                    }
                }, Object.defineProperty(n.Time.prototype, "desiredFps", {
                    get: function() {
                        return this._desiredFps
                    },
                    set: function(t) {
                        this._desiredFps = t, this.physicsElapsed = 1 / t, this.physicsElapsedMS = 1e3 * this.physicsElapsed, this.desiredFpsMult = 1 / t
                    }
                }), n.Time.prototype.constructor = n.Time, n.Timer = function(t, e) {
                    void 0 === e && (e = !0), this.game = t, this.running = !1, this.autoDestroy = e, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new n.Signal, this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0
                }, n.Timer.MINUTE = 6e4, n.Timer.SECOND = 1e3, n.Timer.HALF = 500, n.Timer.QUARTER = 250, n.Timer.prototype = {
                    create: function(t, e, i, s, r, o) {
                        var a = t = Math.round(t);
                        0 === this._now ? a += this.game.time.time : a += this._now;
                        var h = new n.TimerEvent(this, t, a, i, e, s, r, o);
                        return this.events.push(h), this.order(), this.expired = !1, h
                    },
                    add: function(t, e, i) {
                        return this.create(t, !1, 0, e, i, Array.prototype.slice.call(arguments, 3))
                    },
                    repeat: function(t, e, i, s) {
                        return this.create(t, !1, e, i, s, Array.prototype.slice.call(arguments, 4))
                    },
                    loop: function(t, e, i) {
                        return this.create(t, !0, 0, e, i, Array.prototype.slice.call(arguments, 3))
                    },
                    start: function(t) {
                        if (!this.running) {
                            this._started = this.game.time.time + (t || 0), this.running = !0;
                            for (var e = 0; e < this.events.length; e++) this.events[e].tick = this.events[e].delay + this._started
                        }
                    },
                    stop: function(t) {
                        this.running = !1, void 0 === t && (t = !0), t && (this.events.length = 0)
                    },
                    remove: function(t) {
                        for (var e = 0; e < this.events.length; e++)
                            if (this.events[e] === t) return this.events[e].pendingDelete = !0, !0;
                        return !1
                    },
                    order: function() {
                        this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick)
                    },
                    sortHandler: function(t, e) {
                        return t.tick < e.tick ? -1 : t.tick > e.tick ? 1 : 0
                    },
                    clearPendingEvents: function() {
                        for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                        this._len = this.events.length, this._i = 0
                    },
                    update: function(t) {
                        if (this.paused) return !0;
                        if (this.elapsed = t - this._now, this._now = t, this.elapsed > this.timeCap && this.adjustEvents(t - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) {
                            for (; this._i < this._len && this.running;) {
                                var e = this.events[this._i];
                                if (!(this._now >= e.tick) || e.pendingDelete) break;
                                this._newTick = this._now + e.delay - (this._now - e.tick), this._newTick < 0 && (this._newTick = this._now + e.delay), !0 === e.loop ? (e.tick = this._newTick, e.callback.apply(e.callbackContext, e.args)) : e.repeatCount > 0 ? (e.repeatCount--, e.tick = this._newTick, e.callback.apply(e.callbackContext, e.args)) : (this._marked++, e.pendingDelete = !0, e.callback.apply(e.callbackContext, e.args)), this._i++
                            }
                            this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
                        }
                        return !this.expired || !this.autoDestroy
                    },
                    pause: function() {
                        this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, this.paused = !0))
                    },
                    _pause: function() {
                        !this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0)
                    },
                    adjustEvents: function(t) {
                        for (var e = 0; e < this.events.length; e++)
                            if (!this.events[e].pendingDelete) {
                                var i = this.events[e].tick - t;
                                i < 0 && (i = 0), this.events[e].tick = this._now + i
                            } var s = this.nextTick - t;
                        this.nextTick = s < 0 ? this._now : this._now + s
                    },
                    resume: function() {
                        if (this.paused) {
                            var t = this.game.time.time;
                            this._pauseTotal += t - this._now, this._now = t, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1
                        }
                    },
                    _resume: function() {
                        this._codePaused || this.resume()
                    },
                    removeAll: function() {
                        this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0
                    },
                    destroy: function() {
                        this.onComplete.removeAll(), this.running = !1, this.expired = !0, this.events = [], this._len = 0, this._i = 0
                    }
                }, Object.defineProperty(n.Timer.prototype, "next", {
                    get: function() {
                        return this.nextTick
                    }
                }), Object.defineProperty(n.Timer.prototype, "duration", {
                    get: function() {
                        return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
                    }
                }), Object.defineProperty(n.Timer.prototype, "length", {
                    get: function() {
                        return this.events.length
                    }
                }), Object.defineProperty(n.Timer.prototype, "ms", {
                    get: function() {
                        return this.running ? this._now - this._started - this._pauseTotal : 0
                    }
                }), Object.defineProperty(n.Timer.prototype, "seconds", {
                    get: function() {
                        return this.running ? .001 * this.ms : 0
                    }
                }), n.Timer.prototype.constructor = n.Timer, n.TimerEvent = function(t, e, i, s, n, r, o, a) {
                    this.timer = t, this.delay = e, this.tick = i, this.repeatCount = s - 1, this.loop = n, this.callback = r, this.callbackContext = o, this.args = a, this.pendingDelete = !1
                }, n.TimerEvent.prototype.constructor = n.TimerEvent, n.AnimationManager = function(t) {
                    this.sprite = t, this.game = t.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = []
                }, n.AnimationManager.prototype = {
                    loadFrameData: function(t, e) {
                        if (void 0 === t) return !1;
                        if (this.isLoaded)
                            for (var i in this._anims) this._anims[i].updateFrameData(t);
                        return this._frameData = t, void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
                    },
                    copyFrameData: function(t, e) {
                        if (this._frameData = t.clone(), this.isLoaded)
                            for (var i in this._anims) this._anims[i].updateFrameData(this._frameData);
                        return void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
                    },
                    add: function(t, e, i, s, r) {
                        return e = e || [], i = i || 60, void 0 === s && (s = !1), void 0 === r && (r = !(!e || "number" != typeof e[0])), this._outputFrames = [], this._frameData.getFrameIndexes(e, r, this._outputFrames), this._anims[t] = new n.Animation(this.game, this.sprite, t, this._frameData, this._outputFrames, i, s), this.currentAnim = this._anims[t], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), this._anims[t]
                    },
                    validateFrames: function(t, e) {
                        void 0 === e && (e = !0);
                        for (var i = 0; i < t.length; i++)
                            if (!0 === e) {
                                if (t[i] > this._frameData.total) return !1
                            } else if (!1 === this._frameData.checkFrameName(t[i])) return !1;
                        return !0
                    },
                    play: function(t, e, i, s) {
                        if (this._anims[t]) return this.currentAnim === this._anims[t] ? !1 === this.currentAnim.isPlaying ? (this.currentAnim.paused = !1, this.currentAnim.play(e, i, s)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[t], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(e, i, s))
                    },
                    stop: function(t, e) {
                        void 0 === e && (e = !1), !this.currentAnim || "string" == typeof t && t !== this.currentAnim.name || this.currentAnim.stop(e)
                    },
                    update: function() {
                        return !(this.updateIfVisible && !this.sprite.visible) && (!(!this.currentAnim || !this.currentAnim.update()) && (this.currentFrame = this.currentAnim.currentFrame, !0))
                    },
                    next: function(t) {
                        this.currentAnim && (this.currentAnim.next(t), this.currentFrame = this.currentAnim.currentFrame)
                    },
                    previous: function(t) {
                        this.currentAnim && (this.currentAnim.previous(t), this.currentFrame = this.currentAnim.currentFrame)
                    },
                    getAnimation: function(t) {
                        return "string" == typeof t && this._anims[t] ? this._anims[t] : null
                    },
                    refreshFrame: function() {},
                    destroy: function() {
                        var t = null;
                        for (var t in this._anims) this._anims.hasOwnProperty(t) && this._anims[t].destroy();
                        this._anims = {}, this._outputFrames = [], this._frameData = null, this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null
                    }
                }, n.AnimationManager.prototype.constructor = n.AnimationManager, Object.defineProperty(n.AnimationManager.prototype, "frameData", {
                    get: function() {
                        return this._frameData
                    }
                }), Object.defineProperty(n.AnimationManager.prototype, "frameTotal", {
                    get: function() {
                        return this._frameData.total
                    }
                }), Object.defineProperty(n.AnimationManager.prototype, "paused", {
                    get: function() {
                        return this.currentAnim.isPaused
                    },
                    set: function(t) {
                        this.currentAnim.paused = t
                    }
                }), Object.defineProperty(n.AnimationManager.prototype, "name", {
                    get: function() {
                        return this.currentAnim ? this.currentAnim.name : void 0
                    }
                }), Object.defineProperty(n.AnimationManager.prototype, "frame", {
                    get: function() {
                        return this.currentFrame ? this.currentFrame.index : void 0
                    },
                    set: function(t) {
                        var e;
                        "number" == typeof t && this._frameData && (e = this._frameData.getFrame(t)) && (this.currentFrame = e, this.sprite.setFrame(this.currentFrame))
                    }
                }), Object.defineProperty(n.AnimationManager.prototype, "frameName", {
                    get: function() {
                        return this.currentFrame ? this.currentFrame.name : void 0
                    },
                    set: function(t) {
                        var e;
                        "string" == typeof t && this._frameData && (e = this._frameData.getFrameByName(t)) ? (this.currentFrame = e, this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame)) : console.warn("Cannot set frameName: " + t)
                    }
                }), n.Animation = function(t, e, i, s, r, o, a) {
                    void 0 === a && (a = !1), this.game = t, this._parent = e, this._frameData = s, this.name = i, this._frames = [], this._frames = this._frames.concat(r), this.delay = 1e3 / o, this.loop = a, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new n.Signal, this.onUpdate = null, this.onComplete = new n.Signal, this.onLoop = new n.Signal, this.isReversed = !1, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this)
                }, n.Animation.prototype = {
                    play: function(t, e, i) {
                        return "number" == typeof t && (this.delay = 1e3 / t), "boolean" == typeof e && (this.loop = e), void 0 !== i && (this.killOnComplete = i), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(!1, !0), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this
                    },
                    restart: function() {
                        this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this)
                    },
                    reverse: function() {
                        return this.reversed = !this.reversed, this
                    },
                    reverseOnce: function() {
                        return this.onComplete.addOnce(this.reverse, this), this.reverse()
                    },
                    setFrame: function(t, e) {
                        var i;
                        if (void 0 === e && (e = !1), "string" == typeof t)
                            for (var s = 0; s < this._frames.length; s++) this._frameData.getFrame(this._frames[s]).name === t && (i = s);
                        else if ("number" == typeof t)
                            if (e) i = t;
                            else
                                for (s = 0; s < this._frames.length; s++) this._frames[s] === t && (i = s);
                        if (i) {
                            var n = this.isReversed ? -1 : 1;
                            this._frameIndex = i - n, this._timeNextFrame = this.game.time.time, this.update()
                        }
                    },
                    stop: function(t, e) {
                        void 0 === t && (t = !1), void 0 === e && (e = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, t && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), e && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this))
                    },
                    onPause: function() {
                        this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time)
                    },
                    onResume: function() {
                        this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff)
                    },
                    update: function() {
                        if (this.isPaused) return !1;
                        var t = this.game.time.time,
                            e = t - this._timeNextFrame;
                        return !!(this.isPlaying && e >= 0) && (this._frameSkip = 1, this._frameDiff = e, this._timeLastFrame = t, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = t + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0))
                    },
                    updateCurrentFrame: function(t, e) {
                        if (void 0 === e && (e = !1), !this._frameData) return !1;
                        var i = this.currentFrame.index;
                        return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (e || i !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), !this.onUpdate || !t || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)
                    },
                    next: function(t) {
                        void 0 === t && (t = 1);
                        var e = this._frameIndex + t;
                        e >= this._frames.length && (this.loop ? e %= this._frames.length : e = this._frames.length - 1), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
                    },
                    previous: function(t) {
                        void 0 === t && (t = 1);
                        var e = this._frameIndex - t;
                        e < 0 && (this.loop ? e = this._frames.length + e : e++), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
                    },
                    updateFrameData: function(t) {
                        this._frameData = t, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
                    },
                    destroy: function() {
                        this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose())
                    },
                    complete: function() {
                        this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.updateCurrentFrame(!1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill()
                    }
                }, n.Animation.prototype.constructor = n.Animation, Object.defineProperty(n.Animation.prototype, "paused", {
                    get: function() {
                        return this.isPaused
                    },
                    set: function(t) {
                        this.isPaused = t, t ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay)
                    }
                }), Object.defineProperty(n.Animation.prototype, "reversed", {
                    get: function() {
                        return this.isReversed
                    },
                    set: function(t) {
                        this.isReversed = t
                    }
                }), Object.defineProperty(n.Animation.prototype, "frameTotal", {
                    get: function() {
                        return this._frames.length
                    }
                }), Object.defineProperty(n.Animation.prototype, "frame", {
                    get: function() {
                        return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
                    },
                    set: function(t) {
                        this.currentFrame = this._frameData.getFrame(this._frames[t]), null !== this.currentFrame && (this._frameIndex = t, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame))
                    }
                }), Object.defineProperty(n.Animation.prototype, "speed", {
                    get: function() {
                        return 1e3 / this.delay
                    },
                    set: function(t) {
                        t > 0 && (this.delay = 1e3 / t)
                    }
                }), Object.defineProperty(n.Animation.prototype, "enableUpdate", {
                    get: function() {
                        return null !== this.onUpdate
                    },
                    set: function(t) {
                        t && null === this.onUpdate ? this.onUpdate = new n.Signal : t || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null)
                    }
                }), n.Animation.generateFrameNames = function(t, e, i, s, r) {
                    void 0 === s && (s = "");
                    var o = [],
                        a = "";
                    if (e < i)
                        for (var h = e; h <= i; h++) a = t + (a = "number" == typeof r ? n.Utils.pad(h.toString(), r, "0", 1) : h.toString()) + s, o.push(a);
                    else
                        for (h = e; h >= i; h--) a = t + (a = "number" == typeof r ? n.Utils.pad(h.toString(), r, "0", 1) : h.toString()) + s, o.push(a);
                    return o
                }, n.Frame = function(t, e, i, s, r, o) {
                    this.index = t, this.x = e, this.y = i, this.width = s, this.height = r, 0 !== this.width && 0 !== this.height || console.warn('Phaser.Frame: Frame "' + this.name + '" has a width or height of zero'), this.name = o, this.centerX = Math.floor(s / 2), this.centerY = Math.floor(r / 2), this.distance = n.Math.distance(0, 0, s, r), this.rotated = !1, this.trimmed = !1, this.sourceSizeW = s, this.sourceSizeH = r, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height
                }, n.Frame.prototype = {
                    resize: function(t, e) {
                        this.width = t, this.height = e, this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2), this.distance = n.Math.distance(0, 0, t, e), this.sourceSizeW = t, this.sourceSizeH = e, this.right = this.x + t, this.bottom = this.y + e
                    },
                    setTrim: function(t, e, i, s, n, r, o) {
                        this.trimmed = t, t && (this.sourceSizeW = e, this.sourceSizeH = i, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(i / 2), this.spriteSourceSizeX = s, this.spriteSourceSizeY = n, this.spriteSourceSizeW = r, this.spriteSourceSizeH = o)
                    },
                    clone: function() {
                        var t = new n.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
                        for (var e in this) this.hasOwnProperty(e) && (t[e] = this[e]);
                        return t
                    },
                    getRect: function(t) {
                        return void 0 === t ? t = new n.Rectangle(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
                    }
                }, n.Frame.prototype.constructor = n.Frame, n.FrameData = function() {
                    this._frames = [], this._frameNames = []
                }, n.FrameData.prototype = {
                    addFrame: function(t) {
                        return t.index = this._frames.length, this._frames.push(t), "" !== t.name && (this._frameNames[t.name] = t.index), t
                    },
                    getFrame: function(t) {
                        return t >= this._frames.length && (t = 0), this._frames[t]
                    },
                    getFrameByName: function(t) {
                        return "number" == typeof this._frameNames[t] ? this._frames[this._frameNames[t]] : null
                    },
                    checkFrameName: function(t) {
                        return null != this._frameNames[t]
                    },
                    clone: function() {
                        for (var t = new n.FrameData, e = 0; e < this._frames.length; e++) t._frames.push(this._frames[e].clone());
                        for (var i in this._frameNames) this._frameNames.hasOwnProperty(i) && (t._frameNames[i] = this._frameNames[i]);
                        return t
                    },
                    getFrameRange: function(t, e, i) {
                        void 0 === i && (i = []);
                        for (var s = t; s <= e; s++) i.push(this._frames[s]);
                        return i
                    },
                    getFrames: function(t, e, i) {
                        if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                            for (var s = 0; s < this._frames.length; s++) i.push(this._frames[s]);
                        else
                            for (s = 0; s < t.length; s++) e ? i.push(this.getFrame(t[s])) : i.push(this.getFrameByName(t[s]));
                        return i
                    },
                    getFrameIndexes: function(t, e, i) {
                        if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                            for (var s = 0; s < this._frames.length; s++) i.push(this._frames[s].index);
                        else
                            for (s = 0; s < t.length; s++) e && this._frames[t[s]] ? i.push(this._frames[t[s]].index) : this.getFrameByName(t[s]) && i.push(this.getFrameByName(t[s]).index);
                        return i
                    },
                    destroy: function() {
                        this._frames = null, this._frameNames = null
                    }
                }, n.FrameData.prototype.constructor = n.FrameData, Object.defineProperty(n.FrameData.prototype, "total", {
                    get: function() {
                        return this._frames.length
                    }
                }), n.AnimationParser = {
                    spriteSheet: function(t, e, i, s, r, o, a, h) {
                        void 0 === r && (r = -1), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === h && (h = 0);
                        var l = e;
                        if ("string" == typeof e ? l = t.cache.getImage(e) : e = l.name, null === l) return null;
                        if (i <= 0 || s <= 0) return console.warn("Phaser.AnimationParser.spriteSheet: '%s' frameWidth (%s) or frameHeight (%s) must be positive", e, i, s), null;
                        var c = l.width,
                            u = l.height;
                        if (0 === c || 0 === u) return console.warn("Phaser.AnimationParser.spriteSheet: '%s' width (%s) or height (%s) is zero", e, c, u), null;
                        if (c < i || u < s) return console.warn("Phaser.AnimationParser.spriteSheet: '%s' width (%s) or height (%s) is less than the given frameWidth (%s) or frameHeight (%s)", e, c, u, i, s), null;
                        var d = Math.floor((c - o) / (i + a)),
                            p = Math.floor((u - o) / (s + a)),
                            f = d * p,
                            g = f,
                            m = f - 1,
                            y = 0,
                            v = m;
                        if (h > f || h < -f) return console.warn("Phaser.AnimationParser.spriteSheet: '%s' skipFrames = %s is larger than the frame total %s", e, h, f), null;
                        if (r > -1 && (v = (f = r) - 1), d < 1 && console.warn("Phaser.AnimationParser.spriteSheet: image '%s' has width %d, but it should be at least %d (frameWidth=%s, margin=%s, spacing=%s)", e, c, i + o + a, i, o, a), p < 1 && console.warn("Phaser.AnimationParser.spriteSheet: image '%s' has height %d, but it should be at least %d (frameHeight=%s, margin=%s, spacing=%s)", e, u, s + o + a, s, o, a), 0 === g) return console.warn("Phaser.AnimationParser.spriteSheet: '%s' zero frames were produced", e), null;
                        if (h > 0 ? v = (y = h) + (f = Math.min(f, g - h)) - 1 : h < 0 && (y = (v = m + h) - (f = Math.min(f, g + h)) + 1), y < 0) return console.warn("First frame index %s is outside of range [0, %d]", y, m), null;
                        if (v > m) return console.warn("Last frame index %s is outside of range [0, %d]", v, m), null;
                        for (var x = new n.FrameData, b = o, _ = o, T = 0, w = 0; w < g && !(w > v); w++) w >= y && x.addFrame(new n.Frame(T++, b, _, i, s, "")), (b += i + a) + i > c && (b = o, _ += s + a);
                        return x
                    },
                    JSONData: function(t, e) {
                        if (!e.frames) return console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"), void console.log(e);
                        for (var i, s = new n.FrameData, r = e.frames, o = 0; o < r.length; o++) i = s.addFrame(new n.Frame(o, r[o].frame.x, r[o].frame.y, r[o].frame.w, r[o].frame.h, r[o].filename)), r[o].trimmed && i.setTrim(r[o].trimmed, r[o].sourceSize.w, r[o].sourceSize.h, r[o].spriteSourceSize.x, r[o].spriteSourceSize.y, r[o].spriteSourceSize.w, r[o].spriteSourceSize.h), r[o].rotated && (i.rotated = !0);
                        return s
                    },
                    JSONDataPyxel: function(t, e) {
                        if (["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"].forEach(function(t) {
                                if (!e[t]) return console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + t + '" key.'), void console.log(e)
                            }), 1 !== e.layers.length) return console.warn("Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps."), void console.log(e);
                        for (var i = new n.FrameData, s = e.tileheight, r = e.tilewidth, o = e.layers[0].tiles, a = 0; a < o.length; a++) i.addFrame(new n.Frame(a, o[a].x, o[a].y, r, s, "frame_" + a)).setTrim(!1);
                        return i
                    },
                    JSONDataHash: function(t, e) {
                        if (!e.frames) return console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"), void console.log(e);
                        var i, s = new n.FrameData,
                            r = e.frames,
                            o = 0;
                        for (var a in r) i = s.addFrame(new n.Frame(o, r[a].frame.x, r[a].frame.y, r[a].frame.w, r[a].frame.h, a)), r[a].trimmed && i.setTrim(r[a].trimmed, r[a].sourceSize.w, r[a].sourceSize.h, r[a].spriteSourceSize.x, r[a].spriteSourceSize.y, r[a].spriteSourceSize.w, r[a].spriteSourceSize.h), r[a].rotated && (i.rotated = !0), o++;
                        return s
                    },
                    XMLData: function(t, e) {
                        if (e.getElementsByTagName("TextureAtlas")) {
                            for (var i, s, r, o, a, h, l, c, u, d, p, f = new n.FrameData, g = e.getElementsByTagName("SubTexture"), m = 0; m < g.length; m++) s = (r = g[m].attributes).name.value, o = parseInt(r.x.value, 10), a = parseInt(r.y.value, 10), h = parseInt(r.width.value, 10), l = parseInt(r.height.value, 10), c = null, u = null, r.frameX && (c = Math.abs(parseInt(r.frameX.value, 10)), u = Math.abs(parseInt(r.frameY.value, 10)), d = parseInt(r.frameWidth.value, 10), p = parseInt(r.frameHeight.value, 10)), i = f.addFrame(new n.Frame(m, o, a, h, l, s)), null === c && null === u || i.setTrim(!0, h, l, c, u, d, p);
                            return f
                        }
                        console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag")
                    }
                }, n.Cache = function(t) {
                    this.game = t, this.autoResolveURL = !1, this._cache = {
                        canvas: {},
                        image: {},
                        texture: {},
                        sound: {},
                        video: {},
                        text: {},
                        json: {},
                        xml: {},
                        physics: {},
                        tilemap: {},
                        binary: {},
                        bitmapData: {},
                        bitmapFont: {},
                        shader: {},
                        renderTexture: {},
                        compressedTexture: {}
                    }, this._urlMap = {}, this._urlResolver = new Image, this._urlTemp = null, this.onSoundUnlock = new n.Signal, this._cacheMap = [], this._cacheMap[n.Cache.CANVAS] = this._cache.canvas, this._cacheMap[n.Cache.IMAGE] = this._cache.image, this._cacheMap[n.Cache.TEXTURE] = this._cache.texture, this._cacheMap[n.Cache.SOUND] = this._cache.sound, this._cacheMap[n.Cache.TEXT] = this._cache.text, this._cacheMap[n.Cache.PHYSICS] = this._cache.physics, this._cacheMap[n.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[n.Cache.BINARY] = this._cache.binary, this._cacheMap[n.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[n.Cache.BITMAPFONT] = this._cache.bitmapFont, this._cacheMap[n.Cache.JSON] = this._cache.json, this._cacheMap[n.Cache.XML] = this._cache.xml, this._cacheMap[n.Cache.VIDEO] = this._cache.video, this._cacheMap[n.Cache.SHADER] = this._cache.shader, this._cacheMap[n.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this._pendingCount = 0, this.onReady = new n.Signal, this._addImages()
                }, n.Cache.CANVAS = 1, n.Cache.IMAGE = 2, n.Cache.TEXTURE = 3, n.Cache.SOUND = 4, n.Cache.TEXT = 5, n.Cache.PHYSICS = 6, n.Cache.TILEMAP = 7, n.Cache.BINARY = 8, n.Cache.BITMAPDATA = 9, n.Cache.BITMAPFONT = 10, n.Cache.JSON = 11, n.Cache.XML = 12, n.Cache.VIDEO = 13, n.Cache.SHADER = 14, n.Cache.RENDER_TEXTURE = 15, n.Cache.DEFAULT = null, n.Cache.DEFAULT_KEY = "__default", n.Cache.DEFAULT_SRC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==", n.Cache.MISSING = null, n.Cache.MISSING_KEY = "__missing", n.Cache.MISSING_SRC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==", n.Cache.READY_TIMEOUT = 1e3, n.Cache.prototype = {
                    addCompressedTextureMetaData: function(t, e, i, s) {
                        this.checkImageKey(t) && this.removeImage(t);
                        var r = i in n.LoaderParser ? n.LoaderParser[i](s) : s,
                            o = {
                                key: t,
                                url: e,
                                data: r,
                                base: new PIXI.BaseTexture(r, null, this.game.resolution),
                                frame: new n.Frame(0, 0, 0, r.width, r.height, t),
                                frameData: new n.FrameData,
                                fileFormat: i
                            };
                        return o.frameData.addFrame(new n.Frame(0, 0, 0, r.width, r.height, e)), this._cache.image[t] = o, this._resolveURL(e, o), o
                    },
                    addCanvas: function(t, e, i) {
                        void 0 === i && (i = e.getContext("2d")), this._cache.canvas[t] = {
                            canvas: e,
                            context: i
                        }
                    },
                    addImage: function(t, e, i) {
                        this.checkImageKey(t) && this.removeImage(t), !1 === i.complete && console.warn('Phaser.Cache.addImage: Image "%s" is not complete', t);
                        var s = {
                            key: t,
                            url: e,
                            data: i,
                            base: new PIXI.BaseTexture(i, null, this.game.resolution),
                            frame: new n.Frame(0, 0, 0, i.width, i.height, t),
                            frameData: new n.FrameData
                        };
                        return s.frameData.addFrame(new n.Frame(0, 0, 0, i.width, i.height, e)), this._cache.image[t] = s, this._resolveURL(e, s), "__default" === t ? n.Cache.DEFAULT = new PIXI.Texture(s.base) : "__missing" === t && (n.Cache.MISSING = new PIXI.Texture(s.base)), s
                    },
                    addImageAsync: function(t, e, i) {
                        var s = this,
                            n = new Image;
                        n.onload = function() {
                            i.call(this, s.addImage(t, null, n)), s._removePending(), n.onload = null
                        }, this._addPending(), n.src = e
                    },
                    addDefaultImage: function() {
                        this.addImageAsync(n.Cache.DEFAULT_KEY, n.Cache.DEFAULT_SRC, function(t) {
                            t.base.skipRender = !0, n.Cache.DEFAULT = new PIXI.Texture(t.base)
                        })
                    },
                    addMissingImage: function() {
                        this.addImageAsync(n.Cache.MISSING_KEY, n.Cache.MISSING_SRC, function(t) {
                            n.Cache.MISSING = new PIXI.Texture(t.base)
                        })
                    },
                    addSound: function(t, e, i, s, n) {
                        void 0 === s && (s = !0, n = !1), void 0 === n && (s = !1, n = !0);
                        var r = !1;
                        n && (r = !0), this._cache.sound[t] = {
                            url: e,
                            data: i,
                            isDecoding: !1,
                            decoded: r,
                            webAudio: s,
                            audioTag: n,
                            locked: this.game.sound.touchLocked
                        }, this._resolveURL(e, this._cache.sound[t])
                    },
                    addText: function(t, e, i) {
                        this._cache.text[t] = {
                            url: e,
                            data: i
                        }, this._resolveURL(e, this._cache.text[t])
                    },
                    addPhysicsData: function(t, e, i, s) {
                        this._cache.physics[t] = {
                            url: e,
                            data: i,
                            format: s
                        }, this._resolveURL(e, this._cache.physics[t])
                    },
                    addTilemap: function(t, e, i, s) {
                        this._cache.tilemap[t] = {
                            url: e,
                            data: i,
                            format: s
                        }, this._resolveURL(e, this._cache.tilemap[t])
                    },
                    addBinary: function(t, e) {
                        this._cache.binary[t] = e
                    },
                    addBitmapData: function(t, e, i) {
                        return e.key = t, void 0 === i && (i = new n.FrameData).addFrame(e.textureFrame), this._cache.bitmapData[t] = {
                            data: e,
                            frameData: i
                        }, e
                    },
                    addBitmapFont: function(t, e, i, s, r, o, a) {
                        var h = {
                            url: e,
                            data: i,
                            font: null,
                            base: new PIXI.BaseTexture(i, null, this.game.resolution)
                        };
                        void 0 === o && (o = 0), void 0 === a && (a = 0), h.font = "json" === r ? n.LoaderParser.jsonBitmapFont(s, h.base, o, a, !1, this.game.resolution) : n.LoaderParser.xmlBitmapFont(s, h.base, o, a, !1, this.game.resolution), this._cache.bitmapFont[t] = h, this._resolveURL(e, h)
                    },
                    addBitmapFontFromAtlas: function(t, e, i, s, r, o, a) {
                        var h = this.getFrameByName(e, i);
                        if (h) {
                            var l, c = {
                                font: null,
                                base: this.getBaseTexture(e),
                                frame: h
                            };
                            void 0 === o && (o = 0), void 0 === a && (a = 0), "json" === r ? (l = this.getJSON(s), c.font = n.LoaderParser.jsonBitmapFont(l, c.base, o, a, h, this.game.resolution)) : (l = this.getXML(s), c.font = n.LoaderParser.xmlBitmapFont(l, c.base, o, a, h, this.game.resolution)), this._cache.bitmapFont[t] = c
                        }
                    },
                    addJSON: function(t, e, i) {
                        this._cache.json[t] = {
                            url: e,
                            data: i
                        }, this._resolveURL(e, this._cache.json[t])
                    },
                    addXML: function(t, e, i) {
                        this._cache.xml[t] = {
                            url: e,
                            data: i
                        }, this._resolveURL(e, this._cache.xml[t])
                    },
                    addVideo: function(t, e, i, s) {
                        this._cache.video[t] = {
                            url: e,
                            data: i,
                            isBlob: s,
                            locked: !0
                        }, this._resolveURL(e, this._cache.video[t])
                    },
                    addShader: function(t, e, i) {
                        this._cache.shader[t] = {
                            url: e,
                            data: i
                        }, this._resolveURL(e, this._cache.shader[t])
                    },
                    addRenderTexture: function(t, e) {
                        this._cache.renderTexture[t] = {
                            texture: e,
                            frame: new n.Frame(0, 0, 0, e.width, e.height, "", "")
                        }
                    },
                    addSpriteSheet: function(t, e, i, s, r, o, a, h, l) {
                        void 0 === o && (o = -1), void 0 === a && (a = 0), void 0 === h && (h = 0);
                        var c = {
                            key: t,
                            url: e,
                            data: i,
                            frameWidth: s,
                            frameHeight: r,
                            margin: a,
                            spacing: h,
                            base: new PIXI.BaseTexture(i, null, this.game.resolution),
                            frameData: n.AnimationParser.spriteSheet(this.game, i, s, r, o, a, h, l)
                        };
                        this._cache.image[t] = c, this._resolveURL(e, c)
                    },
                    addTextureAtlas: function(t, e, i, s, r) {
                        var o = {
                            key: t,
                            url: e,
                            data: i,
                            base: new PIXI.BaseTexture(i, null, this.game.resolution)
                        };
                        r === n.Loader.TEXTURE_ATLAS_XML_STARLING ? o.frameData = n.AnimationParser.XMLData(this.game, s, t) : r === n.Loader.TEXTURE_ATLAS_JSON_PYXEL ? o.frameData = n.AnimationParser.JSONDataPyxel(this.game, s, t) : Array.isArray(s.frames) ? o.frameData = n.AnimationParser.JSONData(this.game, s, t) : o.frameData = n.AnimationParser.JSONDataHash(this.game, s, t), this._cache.image[t] = o, this._resolveURL(e, o)
                    },
                    reloadSound: function(t) {
                        var e = this,
                            i = this.getSound(t);
                        i && (i.data.src = i.url, i.data.addEventListener("canplaythrough", function() {
                            return e.reloadSoundComplete(t)
                        }, !1), i.data.load())
                    },
                    reloadSoundComplete: function(t) {
                        var e = this.getSound(t);
                        e && (e.locked = !1, this.onSoundUnlock.dispatch(t))
                    },
                    updateSound: function(t, e, i) {
                        var s = this.getSound(t);
                        s && (s[e] = i)
                    },
                    decodedSound: function(t, e) {
                        var i = this.getSound(t);
                        i.data = e, i.decoded = !0, i.isDecoding = !1
                    },
                    isSoundDecoded: function(t) {
                        var e = this.getItem(t, n.Cache.SOUND, "isSoundDecoded");
                        if (e) return e.decoded
                    },
                    isSoundReady: function(t) {
                        var e = this.getItem(t, n.Cache.SOUND, "isSoundDecoded");
                        if (e) return e.decoded && !this.game.sound.touchLocked
                    },
                    checkKey: function(t, e) {
                        return !!this._cacheMap[t][e]
                    },
                    checkURL: function(t) {
                        return !!this._urlMap[this._resolveURL(t)]
                    },
                    checkCanvasKey: function(t) {
                        return this.checkKey(n.Cache.CANVAS, t)
                    },
                    checkImageKey: function(t) {
                        return this.checkKey(n.Cache.IMAGE, t)
                    },
                    checkTextureKey: function(t) {
                        return this.checkKey(n.Cache.TEXTURE, t)
                    },
                    checkSoundKey: function(t) {
                        return this.checkKey(n.Cache.SOUND, t)
                    },
                    checkTextKey: function(t) {
                        return this.checkKey(n.Cache.TEXT, t)
                    },
                    checkPhysicsKey: function(t) {
                        return this.checkKey(n.Cache.PHYSICS, t)
                    },
                    checkTilemapKey: function(t) {
                        return this.checkKey(n.Cache.TILEMAP, t)
                    },
                    checkBinaryKey: function(t) {
                        return this.checkKey(n.Cache.BINARY, t)
                    },
                    checkBitmapDataKey: function(t) {
                        return this.checkKey(n.Cache.BITMAPDATA, t)
                    },
                    checkBitmapFontKey: function(t) {
                        return this.checkKey(n.Cache.BITMAPFONT, t)
                    },
                    checkJSONKey: function(t) {
                        return this.checkKey(n.Cache.JSON, t)
                    },
                    checkXMLKey: function(t) {
                        return this.checkKey(n.Cache.XML, t)
                    },
                    checkVideoKey: function(t) {
                        return this.checkKey(n.Cache.VIDEO, t)
                    },
                    checkShaderKey: function(t) {
                        return this.checkKey(n.Cache.SHADER, t)
                    },
                    checkRenderTextureKey: function(t) {
                        return this.checkKey(n.Cache.RENDER_TEXTURE, t)
                    },
                    getItem: function(t, e, i, s) {
                        return this.checkKey(e, t) ? void 0 === s ? this._cacheMap[e][t] : this._cacheMap[e][t][s] : (i && console.warn("Phaser.Cache." + i + ': Key "' + t + '" not found in Cache.'), null)
                    },
                    getCanvas: function(t) {
                        return this.getItem(t, n.Cache.CANVAS, "getCanvas", "canvas")
                    },
                    getImage: function(t, e) {
                        void 0 !== t && null !== t || (t = "__default"), void 0 === e && (e = !1);
                        var i = this.getItem(t, n.Cache.IMAGE, "getImage");
                        return null === i && (i = this.getItem("__missing", n.Cache.IMAGE, "getImage")), e ? i : i.data
                    },
                    getTextureFrame: function(t) {
                        return this.getItem(t, n.Cache.TEXTURE, "getTextureFrame", "frame")
                    },
                    getSound: function(t) {
                        return this.getItem(t, n.Cache.SOUND, "getSound")
                    },
                    getSoundData: function(t) {
                        return this.getItem(t, n.Cache.SOUND, "getSoundData", "data")
                    },
                    getText: function(t) {
                        return this.getItem(t, n.Cache.TEXT, "getText", "data")
                    },
                    getPhysicsData: function(t, e, i) {
                        var s = this.getItem(t, n.Cache.PHYSICS, "getPhysicsData", "data");
                        if (null === s || void 0 === e || null === e) return s;
                        if (s[e]) {
                            var r = s[e];
                            if (!r || !i) return r;
                            for (var o in r)
                                if ((o = r[o]).fixtureKey === i) return o;
                            console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + i + " in " + t + '"')
                        } else console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + t + " / " + e + '"');
                        return null
                    },
                    getTilemapData: function(t) {
                        return this.getItem(t, n.Cache.TILEMAP, "getTilemapData")
                    },
                    getBinary: function(t) {
                        return this.getItem(t, n.Cache.BINARY, "getBinary")
                    },
                    getBitmapData: function(t) {
                        return this.getItem(t, n.Cache.BITMAPDATA, "getBitmapData", "data")
                    },
                    getBitmapFont: function(t) {
                        return this.getItem(t, n.Cache.BITMAPFONT, "getBitmapFont")
                    },
                    getJSON: function(t, e) {
                        var i = this.getItem(t, n.Cache.JSON, "getJSON", "data");
                        return i ? e ? n.Utils.extend(!0, Array.isArray(i) ? [] : {}, i) : i : null
                    },
                    getXML: function(t) {
                        return this.getItem(t, n.Cache.XML, "getXML", "data")
                    },
                    getVideo: function(t) {
                        return this.getItem(t, n.Cache.VIDEO, "getVideo")
                    },
                    getShader: function(t) {
                        return this.getItem(t, n.Cache.SHADER, "getShader", "data")
                    },
                    getRenderTexture: function(t) {
                        return this.getItem(t, n.Cache.RENDER_TEXTURE, "getRenderTexture")
                    },
                    getBaseTexture: function(t, e) {
                        return void 0 === e && (e = n.Cache.IMAGE), this.getItem(t, e, "getBaseTexture", "base")
                    },
                    getFrame: function(t, e) {
                        return void 0 === e && (e = n.Cache.IMAGE), this.getItem(t, e, "getFrame", "frame")
                    },
                    getFrameCount: function(t, e) {
                        var i = this.getFrameData(t, e);
                        return i ? i.total : 0
                    },
                    getFrameData: function(t, e) {
                        return void 0 === e && (e = n.Cache.IMAGE), this.getItem(t, e, "getFrameData", "frameData")
                    },
                    hasFrameData: function(t, e) {
                        return void 0 === e && (e = n.Cache.IMAGE), null !== this.getItem(t, e, "", "frameData")
                    },
                    updateFrameData: function(t, e, i) {
                        void 0 === i && (i = n.Cache.IMAGE), this._cacheMap[i][t] && (this._cacheMap[i][t].frameData = e)
                    },
                    getFrameByIndex: function(t, e, i) {
                        var s = this.getFrameData(t, i);
                        return s ? s.getFrame(e) : null
                    },
                    getFrameByName: function(t, e, i) {
                        var s = this.getFrameData(t, i);
                        return s ? s.getFrameByName(e) : null
                    },
                    getURL: function(t) {
                        return (t = this._resolveURL(t)) ? this._urlMap[t] : (console.warn('Phaser.Cache.getUrl: Invalid url: "' + t + '" or Cache.autoResolveURL was false'), null)
                    },
                    getKeys: function(t) {
                        void 0 === t && (t = n.Cache.IMAGE);
                        var e = [];
                        if (this._cacheMap[t])
                            for (var i in this._cacheMap[t]) "__default" !== i && "__missing" !== i && e.push(i);
                        return e
                    },
                    removeCanvas: function(t) {
                        delete this._cache.canvas[t]
                    },
                    removeImage: function(t, e) {
                        void 0 === e && (e = !0);
                        var i = this.getImage(t, !0);
                        e && i.base && i.base.destroy(), delete this._cache.image[t]
                    },
                    removeSound: function(t) {
                        delete this._cache.sound[t]
                    },
                    removeText: function(t) {
                        delete this._cache.text[t]
                    },
                    removePhysics: function(t) {
                        delete this._cache.physics[t]
                    },
                    removeTilemap: function(t) {
                        delete this._cache.tilemap[t]
                    },
                    removeBinary: function(t) {
                        delete this._cache.binary[t]
                    },
                    removeBitmapData: function(t) {
                        delete this._cache.bitmapData[t]
                    },
                    removeBitmapFont: function(t) {
                        delete this._cache.bitmapFont[t]
                    },
                    removeJSON: function(t) {
                        delete this._cache.json[t]
                    },
                    removeXML: function(t) {
                        delete this._cache.xml[t]
                    },
                    removeVideo: function(t) {
                        delete this._cache.video[t]
                    },
                    removeShader: function(t) {
                        delete this._cache.shader[t]
                    },
                    removeRenderTexture: function(t) {
                        delete this._cache.renderTexture[t]
                    },
                    removeSpriteSheet: function(t) {
                        delete this._cache.spriteSheet[t]
                    },
                    removeTextureAtlas: function(t) {
                        delete this._cache.image[t]
                    },
                    clearGLTextures: function() {
                        for (var t in this._cache.image) this._cache.image[t].base._glTextures = []
                    },
                    _resolveURL: function(t, e) {
                        return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + t, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", e && (this._urlMap[this._urlTemp] = e), this._urlTemp) : null
                    },
                    destroy: function() {
                        for (var t = 0; t < this._cacheMap.length; t++) {
                            var e = this._cacheMap[t];
                            for (var i in e) "__default" !== i && "__missing" !== i && (this.destroyItem(e[i]), delete e[i])
                        }
                        this._urlMap = null, this._urlResolver = null, this._urlTemp = null
                    },
                    destroyItem: function(t) {
                        t.destroy ? t.destroy() : (t.base && t.base.destroy && t.base.destroy(), t.data && t.data.destroy && t.data.destroy(), t.frameData && t.frameData.destroy && t.frameData.destroy(), t.texture && t.texture.destroy && t.texture.destroy(!0))
                    },
                    _addImages: function() {
                        this._pendingCount = 0, this.addDefaultImage(), this.addMissingImage();
                        var t = this,
                            e = n.Cache.READY_TIMEOUT;
                        n.Cache.READY_TIMEOUT > 0 ? setTimeout(function() {
                            t.isReady || (console.warn("Phaser.Cache: Still waiting for images after %s ms.", e), t._ready())
                        }, n.Cache.READY_TIMEOUT) : this._ready()
                    },
                    _addPending: function() {
                        this._pendingCount += 1
                    },
                    _removePending: function() {
                        this._pendingCount -= 1, this._checkReady()
                    },
                    _checkReady: function() {
                        this.isReady && this._ready()
                    },
                    _ready: function() {
                        this._pendingCount = 0, this.onReady.dispatch(this)
                    }
                }, n.Cache.prototype.constructor = n.Cache, Object.defineProperty(n.Cache.prototype, "isReady", {
                    get: function() {
                        return this._pendingCount <= 0
                    }
                }), n.Loader = function(t) {
                    this.game = t, this.cache = t.cache, this.resetLocked = !1, this.isLoading = !1, this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.path = "", this.headers = {
                        requestedWith: !1,
                        json: "application/json",
                        xml: "application/xml"
                    }, this.onLoadStart = new n.Signal, this.onBeforeLoadComplete = new n.Signal, this.onLoadComplete = new n.Signal, this.onPackComplete = new n.Signal, this.onFileStart = new n.Signal, this.onFileComplete = new n.Signal, this.onFileError = new n.Signal, this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0
                }, n.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, n.Loader.TEXTURE_ATLAS_JSON_HASH = 1, n.Loader.TEXTURE_ATLAS_XML_STARLING = 2, n.Loader.PHYSICS_LIME_CORONA_JSON = 3, n.Loader.PHYSICS_PHASER_JSON = 4, n.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5, n.Loader.prototype = {
                    setPreloadSprite: function(t, e) {
                        e = e || 0, this.preloadSprite = {
                            sprite: t,
                            direction: e,
                            width: t.width,
                            height: t.height,
                            rect: null
                        }, this.preloadSprite.rect = 0 === e ? new n.Rectangle(0, 0, 1, t.height) : new n.Rectangle(0, 0, t.width, 1), t.crop(this.preloadSprite.rect), t.visible = !0
                    },
                    resize: function() {
                        this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height)
                    },
                    checkKeyExists: function(t, e) {
                        return this.getAssetIndex(t, e) > -1
                    },
                    getAssetIndex: function(t, e) {
                        for (var i = -1, s = 0; s < this._fileList.length; s++) {
                            var n = this._fileList[s];
                            if (n.type === t && n.key === e && (i = s, !n.loaded && !n.loading)) break
                        }
                        return i
                    },
                    getAsset: function(t, e) {
                        var i = this.getAssetIndex(t, e);
                        return i > -1 && {
                            index: i,
                            file: this._fileList[i]
                        }
                    },
                    reset: function(t, e) {
                        void 0 === e && (e = !1), this.resetLocked || (t && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, e && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll()))
                    },
                    addToFileList: function(t, e, i, s, n, r) {
                        if (void 0 === n && (n = !1), void 0 === e || "" === e) return console.warn("Phaser.Loader: Invalid or no key given of type " + t), this;
                        if (void 0 === i || null === i) {
                            if (!r) return console.warn("Phaser.Loader: No URL given for file type: " + t + " key: " + e), this;
                            i = e + r
                        }
                        var o = {
                            type: t,
                            key: e,
                            path: this.path,
                            url: i,
                            syncPoint: this._withSyncPointDepth > 0,
                            data: null,
                            loading: !1,
                            loaded: !1,
                            error: !1
                        };
                        if (s)
                            for (var a in s) o[a] = s[a];
                        var h = this.getAssetIndex(t, e);
                        if (n && h > -1) {
                            var l = this._fileList[h];
                            l.loading || l.loaded ? (this._fileList.push(o), this._totalFileCount++) : this._fileList[h] = o
                        } else -1 === h && (this._fileList.push(o), this._totalFileCount++);
                        return this
                    },
                    replaceInFileList: function(t, e, i, s) {
                        return this.addToFileList(t, e, i, s, !0)
                    },
                    pack: function(t, e, i, s) {
                        if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = null), !e && !i) return console.warn("Phaser.Loader.pack - Both url and data are null. One must be set."), this;
                        var n = {
                            type: "packfile",
                            key: t,
                            url: e,
                            path: this.path,
                            syncPoint: !0,
                            data: null,
                            loading: !1,
                            loaded: !1,
                            error: !1,
                            callbackContext: s
                        };
                        i && ("string" == typeof i && (i = JSON.parse(i)), n.data = i || {}, n.loaded = !0);
                        for (var r = 0; r < this._fileList.length + 1; r++) {
                            var o = this._fileList[r];
                            if (!o || !o.loaded && !o.loading && "packfile" !== o.type) {
                                this._fileList.splice(r, 0, n), this._totalPackCount++;
                                break
                            }
                        }
                        return this
                    },
                    image: function(t, e, i) {
                        return "object" == typeof e ? this.texture(t, e, i) : this.addToFileList("image", t, e, void 0, i, ".png")
                    },
                    imageFromBitmapData: function(t, e, i) {
                        return this.image(t, e.canvas.toDataURL("image/png"), i)
                    },
                    imageFromGrid: function(t, e, i, s, n, r) {
                        return this.imageFromBitmapData(t, this.game.create.grid(t, e, i, s, n, r, !1))
                    },
                    imageFromTexture: function(t, e, i, s, n) {
                        return this.imageFromBitmapData(t, this.game.create.texture(t, e, i, s, n, !1))
                    },
                    texture: function(t, e, i) {
                        if (this.game.renderType === n.WEBGL) {
                            var s, r = this.game.renderer.extensions.compression;
                            for (s in e)
                                if (s.toUpperCase() in r) return this.addToFileList("texture", t, e[s], void 0, i, ".pvr")
                        }
                        return e.truecolor && this.addToFileList("image", t, e.truecolor, void 0, i, ".png"), this
                    },
                    images: function(t, e) {
                        if (Array.isArray(e))
                            for (var i = 0; i < t.length; i++) this.image(t[i], e[i]);
                        else
                            for (i = 0; i < t.length; i++) this.image(t[i]);
                        return this
                    },
                    text: function(t, e, i) {
                        return this.addToFileList("text", t, e, void 0, i, ".txt")
                    },
                    json: function(t, e, i) {
                        return this.addToFileList("json", t, e, void 0, i, ".json")
                    },
                    shader: function(t, e, i) {
                        return this.addToFileList("shader", t, e, void 0, i, ".frag")
                    },
                    xml: function(t, e, i) {
                        return this.addToFileList("xml", t, e, void 0, i, ".xml")
                    },
                    script: function(t, e, i, s) {
                        return void 0 === i && (i = !1), !1 !== i && void 0 === s && (s = this), this.addToFileList("script", t, e, {
                            syncPoint: !0,
                            callback: i,
                            callbackContext: s
                        }, !1, ".js")
                    },
                    binary: function(t, e, i, s) {
                        return void 0 === i && (i = !1), !1 !== i && void 0 === s && (s = i), this.addToFileList("binary", t, e, {
                            callback: i,
                            callbackContext: s
                        }, !1, ".bin")
                    },
                    spritesheet: function(t, e, i, s, n, r, o, a) {
                        return void 0 === n && (n = -1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), this.addToFileList("spritesheet", t, e, {
                            frameWidth: i,
                            frameHeight: s,
                            frameMax: n,
                            margin: r,
                            spacing: o,
                            skipFrames: a
                        }, !1, ".png")
                    },
                    audio: function(t, e, i) {
                        return this.game.sound.noAudio ? this : (void 0 === i && (i = !0), "string" == typeof e && (e = [e]), this.addToFileList("audio", t, e, {
                            buffer: null,
                            autoDecode: i
                        }))
                    },
                    audioSprite: function(t, e, i, s, n) {
                        return this.game.sound.noAudio ? this : (void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = !0), this.audio(t, e, n), i ? this.json(t + "-audioatlas", i) : s ? ("string" == typeof s && (s = JSON.parse(s)), this.cache.addJSON(t + "-audioatlas", "", s)) : console.warn("Phaser.Loader.audiosprite - You must specify either a jsonURL or provide a jsonData object"), this)
                    },
                    audiosprite: function(t, e, i, s, n) {
                        return this.audioSprite(t, e, i, s, n)
                    },
                    video: function(t, e, i, s) {
                        return void 0 === i && (i = this.game.device.firefox ? "loadeddata" : "canplaythrough"), void 0 === s && (s = !1), "string" == typeof e && (e = [e]), this.addToFileList("video", t, e, {
                            buffer: null,
                            asBlob: s,
                            loadEvent: i
                        })
                    },
                    tilemap: function(t, e, i, s) {
                        if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = n.Tilemap.CSV), e || i || (e = s === n.Tilemap.CSV ? t + ".csv" : t + ".json"), i) {
                            switch (s) {
                                case n.Tilemap.CSV:
                                    break;
                                case n.Tilemap.TILED_JSON:
                                    "string" == typeof i && (i = JSON.parse(i))
                            }
                            this.cache.addTilemap(t, null, i, s)
                        } else this.addToFileList("tilemap", t, e, {
                            format: s
                        });
                        return this
                    },
                    tilemapCSV: function(t, e, i) {
                        return this.tilemap(t, e, i, n.Tilemap.CSV)
                    },
                    tilemapTiledJSON: function(t, e, i) {
                        return this.tilemap(t, e, i, n.Tilemap.TILED_JSON)
                    },
                    physics: function(t, e, i, s) {
                        return void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = n.Physics.LIME_CORONA_JSON), e || i || (e = t + ".json"), i ? ("string" == typeof i && (i = JSON.parse(i)), this.cache.addPhysicsData(t, null, i, s)) : this.addToFileList("physics", t, e, {
                            format: s
                        }), this
                    },
                    bitmapFont: function(t, e, i, s, n, r) {
                        if (void 0 !== e && null !== e || (e = t + ".png"), void 0 === i && (i = null), void 0 === s && (s = null), null === i && null === s && (i = t + ".xml"), void 0 === n && (n = 0), void 0 === r && (r = 0), i) this.addToFileList("bitmapfont", t, e, {
                            atlasURL: i,
                            xSpacing: n,
                            ySpacing: r
                        });
                        else if ("string" == typeof s) {
                            var o, a;
                            try {
                                o = JSON.parse(s)
                            } catch (t) {
                                a = this.parseXml(s)
                            }
                            if (!a && !o) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                            this.addToFileList("bitmapfont", t, e, {
                                atlasURL: null,
                                atlasData: o || a,
                                atlasType: o ? "json" : "xml",
                                xSpacing: n,
                                ySpacing: r
                            })
                        }
                        return this
                    },
                    atlasJSONArray: function(t, e, i, s) {
                        return this.atlas(t, e, i, s, n.Loader.TEXTURE_ATLAS_JSON_ARRAY)
                    },
                    atlasJSONHash: function(t, e, i, s) {
                        return this.atlas(t, e, i, s, n.Loader.TEXTURE_ATLAS_JSON_HASH)
                    },
                    atlasXML: function(t, e, i, s) {
                        return void 0 === i && (i = null), void 0 === s && (s = null), i || s || (i = t + ".xml"), this.atlas(t, e, i, s, n.Loader.TEXTURE_ATLAS_XML_STARLING)
                    },
                    atlas: function(t, e, i, s, r) {
                        if (void 0 !== e && null !== e || (e = t + ".png"), void 0 === i && (i = null), void 0 === s && (s = null), void 0 === r && (r = n.Loader.TEXTURE_ATLAS_JSON_ARRAY), i || s || (i = r === n.Loader.TEXTURE_ATLAS_XML_STARLING ? t + ".xml" : t + ".json"), i) this.addToFileList("textureatlas", t, e, {
                            atlasURL: i,
                            format: r
                        });
                        else {
                            switch (r) {
                                case n.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                                    "string" == typeof s && (s = JSON.parse(s));
                                    break;
                                case n.Loader.TEXTURE_ATLAS_XML_STARLING:
                                    if ("string" == typeof s) {
                                        var o = this.parseXml(s);
                                        if (!o) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                                        s = o
                                    }
                            }
                            this.addToFileList("textureatlas", t, e, {
                                atlasURL: null,
                                atlasData: s,
                                format: r
                            })
                        }
                        return this
                    },
                    withSyncPoint: function(t, e) {
                        this._withSyncPointDepth++;
                        try {
                            t.call(e || this, this)
                        } finally {
                            this._withSyncPointDepth--
                        }
                        return this
                    },
                    addSyncPoint: function(t, e) {
                        var i = this.getAsset(t, e);
                        return i && (i.file.syncPoint = !0), this
                    },
                    removeFile: function(t, e) {
                        var i = this.getAsset(t, e);
                        i && (i.loaded || i.loading || this._fileList.splice(i.index, 1))
                    },
                    removeAll: function() {
                        this._fileList.length = 0, this._flightQueue.length = 0
                    },
                    start: function() {
                        this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue())
                    },
                    processLoadQueue: function() {
                        if (!this.isLoading) return console.warn("Phaser.Loader - active loading canceled / reset"), void this.finishedLoading(!0);
                        for (var t = 0; t < this._flightQueue.length; t++) {
                            ((s = this._flightQueue[t]).loaded || s.error) && (this._flightQueue.splice(t, 1), t--, s.loading = !1, s.requestUrl = null, s.requestObject = null, s.error && this.onFileError.dispatch(s.key, s), "packfile" !== s.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, s.key, !s.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === s.type && s.error && (this._loadedPackCount++, this.onPackComplete.dispatch(s.key, !s.error, this._loadedPackCount, this._totalPackCount)))
                        }
                        var e = !1,
                            i = this.enableParallel ? Math.max(1, this.maxParallelDownloads) : 1;
                        for (t = this._processingHead; t < this._fileList.length; t++) {
                            var s;
                            if ("packfile" === (s = this._fileList[t]).type && !s.error && s.loaded && t === this._processingHead && (this.processPack(s), this._loadedPackCount++, this.onPackComplete.dispatch(s.key, !s.error, this._loadedPackCount, this._totalPackCount)), s.loaded || s.error ? t === this._processingHead && (this._processingHead = t + 1) : !s.loading && this._flightQueue.length < i && ("packfile" !== s.type || s.data ? e || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(s), s.loading = !0, this.onFileStart.dispatch(this.progress, s.key, s.url), this.loadFile(s)) : (this._flightQueue.push(s), s.loading = !0, this.loadFile(s))), !s.loaded && s.syncPoint && (e = !0), this._flightQueue.length >= i || e && this._loadedPackCount === this._totalPackCount) break
                        }
                        if (this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading();
                        else if (!this._flightQueue.length) {
                            console.warn("Phaser.Loader - aborting: processing queue empty, loading may have stalled");
                            var n = this;
                            setTimeout(function() {
                                n.finishedLoading(!0)
                            }, 2e3)
                        }
                    },
                    finishedLoading: function(t) {
                        this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, t || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.game.state.loadUpdate(), this.onBeforeLoadComplete.dispatch(), this.reset(), this.onLoadComplete.dispatch(), this.game.state && this.game.state.loadComplete())
                    },
                    asyncComplete: function(t, e) {
                        void 0 === e && (e = ""), t.loaded = !0, t.error = !!e, e && (t.errorMessage = e, console.warn("Phaser.Loader - " + t.type + "[" + t.key + "]: " + e)), this.processLoadQueue()
                    },
                    processPack: function(t) {
                        var e = t.data[t.key];
                        if (e)
                            for (var i = 0; i < e.length; i++) {
                                var s = e[i];
                                switch (s.type) {
                                    case "image":
                                        this.image(s.key, s.url, s.overwrite);
                                        break;
                                    case "text":
                                        this.text(s.key, s.url, s.overwrite);
                                        break;
                                    case "json":
                                        this.json(s.key, s.url, s.overwrite);
                                        break;
                                    case "xml":
                                        this.xml(s.key, s.url, s.overwrite);
                                        break;
                                    case "script":
                                        this.script(s.key, s.url, s.callback, t.callbackContext || this);
                                        break;
                                    case "binary":
                                        this.binary(s.key, s.url, s.callback, t.callbackContext || this);
                                        break;
                                    case "spritesheet":
                                        this.spritesheet(s.key, s.url, s.frameWidth, s.frameHeight, s.frameMax, s.margin, s.spacing, s.skipFrames);
                                        break;
                                    case "video":
                                        this.video(s.key, s.urls);
                                        break;
                                    case "audio":
                                        this.audio(s.key, s.urls, s.autoDecode);
                                        break;
                                    case "audiosprite":
                                        this.audiosprite(s.key, s.urls, s.jsonURL, s.jsonData, s.autoDecode);
                                        break;
                                    case "tilemap":
                                        this.tilemap(s.key, s.url, s.data, n.Tilemap[s.format]);
                                        break;
                                    case "physics":
                                        this.physics(s.key, s.url, s.data, n.Loader[s.format]);
                                        break;
                                    case "bitmapFont":
                                        this.bitmapFont(s.key, s.textureURL, s.atlasURL, s.atlasData, s.xSpacing, s.ySpacing);
                                        break;
                                    case "atlasJSONArray":
                                        this.atlasJSONArray(s.key, s.textureURL, s.atlasURL, s.atlasData);
                                        break;
                                    case "atlasJSONHash":
                                        this.atlasJSONHash(s.key, s.textureURL, s.atlasURL, s.atlasData);
                                        break;
                                    case "atlasXML":
                                        this.atlasXML(s.key, s.textureURL, s.atlasURL, s.atlasData);
                                        break;
                                    case "atlas":
                                        this.atlas(s.key, s.textureURL, s.atlasURL, s.atlasData, n.Loader[s.format]);
                                        break;
                                    case "shader":
                                        this.shader(s.key, s.url, s.overwrite)
                                }
                            } else console.warn("Phaser.Loader - " + t.key + ": pack has data, but not for pack key")
                    },
                    transformUrl: function(t, e) {
                        return !!t && (t.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t : this.baseURL + e.path + t)
                    },
                    loadFile: function(t) {
                        switch (t.type) {
                            case "packfile":
                                this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                                break;
                            case "image":
                            case "spritesheet":
                            case "textureatlas":
                            case "bitmapfont":
                                this.loadImageTag(t);
                                break;
                            case "audio":
                                t.url = this.getAudioURL(t.url), t.url ? this.game.sound.usingWebAudio ? this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(t) : this.fileError(t, null, "No supported audio URL specified or device does not have audio playback support");
                                break;
                            case "video":
                                t.url = this.getVideoURL(t.url), t.url ? t.asBlob ? this.xhrLoad(t, this.transformUrl(t.url, t), "blob", this.fileComplete) : this.loadVideoTag(t) : this.fileError(t, null, "No supported video URL specified or device does not have video playback support");
                                break;
                            case "json":
                                this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete);
                                break;
                            case "xml":
                                this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.xmlLoadComplete);
                                break;
                            case "tilemap":
                                t.format === n.Tilemap.TILED_JSON ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete) : t.format === n.Tilemap.CSV ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.csvLoadComplete) : this.asyncComplete(t, "invalid Tilemap format: " + t.format);
                                break;
                            case "text":
                            case "script":
                            case "shader":
                            case "physics":
                                this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                                break;
                            case "texture":
                                "truecolor" === t.key.split("_").pop() ? this.loadImageTag(t) : this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete);
                                break;
                            case "binary":
                                this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete)
                        }
                    },
                    loadImageTag: function(t) {
                        var e = this;
                        t.data = new Image, t.data.name = t.key, this.crossOrigin && (t.data.crossOrigin = this.crossOrigin), t.data.onload = function() {
                            t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileComplete(t))
                        }, t.data.onerror = function() {
                            t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileError(t))
                        }, t.data.src = this.transformUrl(t.url, t), !this.game.device.firefox && t.data.complete && t.data.width && t.data.height && (t.data.onload = null, t.data.onerror = null, this.fileComplete(t))
                    },
                    loadVideoTag: function(t) {
                        var e = this;
                        t.data = document.createElement("video"), t.data.name = t.key, t.data.controls = !1, t.data.autoplay = !1, t.data.playsInline = !0;
                        var i = function() {
                            t.data.removeEventListener(t.loadEvent, i, !1), t.data.onerror = null, t.data.canplay = !0, n.GAMES[e.game.id].load.fileComplete(t)
                        };
                        t.data.onerror = function() {
                            t.data.removeEventListener(t.loadEvent, i, !1), t.data.onerror = null, t.data.canplay = !1, e.fileError(t)
                        }, t.data.addEventListener(t.loadEvent, i, !1), t.data.src = this.transformUrl(t.url, t), t.data.load()
                    },
                    loadAudioTag: function(t) {
                        var e = this;
                        if (this.game.sound.touchLocked) t.data = new Audio, t.data.name = t.key, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), this.fileComplete(t);
                        else {
                            t.data = new Audio, t.data.name = t.key;
                            var i = function() {
                                t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileComplete(t)
                            };
                            t.data.onerror = function() {
                                t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileError(t)
                            }, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), t.data.addEventListener("canplaythrough", i, !1), t.data.load()
                        }
                    },
                    xhrLoad: function(t, e, i, s, n) {
                        var r = new XMLHttpRequest;
                        r.open("GET", e, !0), r.responseType = i, !1 !== this.headers.requestedWith && r.setRequestHeader("X-Requested-With", this.headers.requestedWith), this.headers[t.type] && r.setRequestHeader("Accept", this.headers[t.type]), n = n || this.fileError;
                        var o = this;
                        r.onload = function() {
                            try {
                                return 4 === r.readyState && r.status >= 400 && r.status <= 599 ? n.call(o, t, r) : s.call(o, t, r)
                            } catch (e) {
                                o.hasLoaded ? window.console && console.error(e) : o.asyncComplete(t, e.message || "Exception")
                            }
                        }, r.onerror = function() {
                            try {
                                return n.call(o, t, r)
                            } catch (e) {
                                o.hasLoaded ? window.console && console.error(e) : o.asyncComplete(t, e.message || "Exception")
                            }
                        }, t.requestObject = r, t.requestUrl = e, r.send()
                    },
                    getVideoURL: function(t) {
                        for (var e = 0; e < t.length; e++) {
                            var i, s = t[e];
                            if (s.uri) {
                                if (i = s.type, s = s.uri, this.game.device.canPlayVideo(i)) return s
                            } else {
                                if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:")) return s;
                                if (s.indexOf("?") >= 0 && (s = s.substr(0, s.indexOf("?"))), i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayVideo(i)) return t[e]
                            }
                        }
                        return null
                    },
                    getAudioURL: function(t) {
                        if (this.game.sound.noAudio) return null;
                        for (var e = 0; e < t.length; e++) {
                            var i, s = t[e];
                            if (s.uri) {
                                if (i = s.type, s = s.uri, this.game.device.canPlayAudio(i)) return s
                            } else {
                                if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:")) return s;
                                if (s.indexOf("?") >= 0 && (s = s.substr(0, s.indexOf("?"))), i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayAudio(i)) return t[e]
                            }
                        }
                        return null
                    },
                    fileError: function(t, e, i) {
                        var s = "error loading asset from URL " + (t.requestUrl || this.transformUrl(t.url, t));
                        !i && e && (i = e.status), i && (s = s + " (" + i + ")"), this.asyncComplete(t, s)
                    },
                    fileComplete: function(t, e) {
                        var i = !0;
                        switch (t.type) {
                            case "packfile":
                                var s = JSON.parse(e.responseText);
                                t.data = s || {};
                                break;
                            case "texture":
                                var r = /\.([^.]+)$/.exec(t.url.split("?", 1)[0])[1].toLowerCase();
                                null !== t.data ? this.cache.addCompressedTextureMetaData(t.key, t.url, r, t.data) : this.cache.addCompressedTextureMetaData(t.key, t.url, r, e.response);
                                break;
                            case "image":
                                this.cache.addImage(t.key, t.url, t.data);
                                break;
                            case "spritesheet":
                                this.cache.addSpriteSheet(t.key, t.url, t.data, t.frameWidth, t.frameHeight, t.frameMax, t.margin, t.spacing, t.skipFrames);
                                break;
                            case "textureatlas":
                                if (null == t.atlasURL) this.cache.addTextureAtlas(t.key, t.url, t.data, t.atlasData, t.format);
                                else if (i = !1, t.format === n.Loader.TEXTURE_ATLAS_JSON_ARRAY || t.format === n.Loader.TEXTURE_ATLAS_JSON_HASH || t.format === n.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.jsonLoadComplete);
                                else {
                                    if (t.format !== n.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + t.format);
                                    this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.xmlLoadComplete)
                                }
                                break;
                            case "bitmapfont":
                                t.atlasURL ? (i = !1, this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", function(t, e) {
                                    var i;
                                    try {
                                        i = JSON.parse(e.responseText)
                                    } catch (t) {}
                                    i ? (t.atlasType = "json", this.jsonLoadComplete(t, e)) : (t.atlasType = "xml", this.xmlLoadComplete(t, e))
                                })) : this.cache.addBitmapFont(t.key, t.url, t.data, t.atlasData, t.atlasType, t.xSpacing, t.ySpacing);
                                break;
                            case "video":
                                if (t.asBlob) try {
                                    t.data = e.response
                                } catch (e) {
                                    throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + t.key)
                                }
                                this.cache.addVideo(t.key, t.url, t.data, t.asBlob);
                                break;
                            case "audio":
                                this.game.sound.usingWebAudio ? (t.data = e.response, this.cache.addSound(t.key, t.url, t.data, !0, !1), t.autoDecode && this.game.sound.decode(t.key)) : this.cache.addSound(t.key, t.url, t.data, !1, !0);
                                break;
                            case "text":
                                t.data = e.responseText, this.cache.addText(t.key, t.url, t.data);
                                break;
                            case "shader":
                                t.data = e.responseText, this.cache.addShader(t.key, t.url, t.data);
                                break;
                            case "physics":
                                s = JSON.parse(e.responseText);
                                this.cache.addPhysicsData(t.key, t.url, s, t.format);
                                break;
                            case "script":
                                t.data = document.createElement("script"), t.data.language = "javascript", t.data.type = "text/javascript", t.data.defer = !1, t.data.text = e.responseText, document.head.appendChild(t.data), t.callback && (t.data = t.callback.call(t.callbackContext, t.key, e.responseText));
                                break;
                            case "binary":
                                t.callback ? t.data = t.callback.call(t.callbackContext, t.key, e.response) : t.data = e.response, this.cache.addBinary(t.key, t.data)
                        }
                        i && this.asyncComplete(t)
                    },
                    jsonLoadComplete: function(t, e) {
                        var i = JSON.parse(e.responseText);
                        "tilemap" === t.type ? this.cache.addTilemap(t.key, t.url, i, t.format) : "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, i, t.atlasType, t.xSpacing, t.ySpacing) : "json" === t.type ? this.cache.addJSON(t.key, t.url, i) : this.cache.addTextureAtlas(t.key, t.url, t.data, i, t.format), this.asyncComplete(t)
                    },
                    csvLoadComplete: function(t, e) {
                        var i = e.responseText;
                        this.cache.addTilemap(t.key, t.url, i, t.format), this.asyncComplete(t)
                    },
                    xmlLoadComplete: function(t, e) {
                        var i = e.responseText,
                            s = this.parseXml(i);
                        if (!s) {
                            var n = e.responseType || e.contentType;
                            return console.warn("Phaser.Loader - " + t.key + ": invalid XML (" + n + ")"), void this.asyncComplete(t, "invalid XML")
                        }
                        "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, s, t.atlasType, t.xSpacing, t.ySpacing) : "textureatlas" === t.type ? this.cache.addTextureAtlas(t.key, t.url, t.data, s, t.format) : "xml" === t.type && this.cache.addXML(t.key, t.url, s), this.asyncComplete(t)
                    },
                    parseXml: function(t) {
                        var e;
                        try {
                            if (window.DOMParser) e = (new DOMParser).parseFromString(t, "text/xml");
                            else(e = new ActiveXObject("Microsoft.XMLDOM")).async = "false", e.loadXML(t)
                        } catch (t) {
                            e = null
                        }
                        return e && e.documentElement && !e.getElementsByTagName("parsererror").length ? e : null
                    },
                    updateProgress: function() {
                        this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null)
                    },
                    totalLoadedFiles: function() {
                        return this._loadedFileCount
                    },
                    totalQueuedFiles: function() {
                        return this._totalFileCount - this._loadedFileCount
                    },
                    totalLoadedPacks: function() {
                        return this._totalPackCount
                    },
                    totalQueuedPacks: function() {
                        return this._totalPackCount - this._loadedPackCount
                    }
                }, Object.defineProperty(n.Loader.prototype, "progressFloat", {
                    get: function() {
                        var t = this._loadedFileCount / this._totalFileCount * 100;
                        return n.Math.clamp(t || 0, 0, 100)
                    }
                }), Object.defineProperty(n.Loader.prototype, "progress", {
                    get: function() {
                        return Math.round(this.progressFloat)
                    }
                }), n.Loader.prototype.constructor = n.Loader, n.LoaderParser = {
                    bitmapFont: function(t, e, i, s, n, r) {
                        return this.xmlBitmapFont(t, e, i, s, n, r)
                    },
                    xmlBitmapFont: function(t, e, i, s, n, r) {
                        null == r && (r = 1);
                        var o = {},
                            a = t.getElementsByTagName("info")[0],
                            h = t.getElementsByTagName("common")[0];
                        o.font = a.getAttribute("face"), o.size = parseInt(a.getAttribute("size"), 10), o.lineHeight = parseInt(h.getAttribute("lineHeight"), 10) + s, o.chars = {};
                        for (var l = t.getElementsByTagName("char"), c = n ? n.x : 0, u = n ? n.y : 0, d = 0; d < l.length; d++) {
                            var p = parseInt(l[d].getAttribute("id"), 10),
                                f = o.chars[p] = {
                                    x: parseInt(l[d].getAttribute("x"), 10),
                                    y: parseInt(l[d].getAttribute("y"), 10),
                                    width: parseInt(l[d].getAttribute("width"), 10),
                                    height: parseInt(l[d].getAttribute("height"), 10),
                                    xOffset: parseInt(l[d].getAttribute("xoffset"), 10) / r,
                                    yOffset: parseInt(l[d].getAttribute("yoffset"), 10) / r,
                                    xAdvance: (parseInt(l[d].getAttribute("xadvance"), 10) + i) / r,
                                    kerning: {}
                                };
                            if (n && n.trimmed) {
                                if (f.x + f.width > n.spriteSourceSizeX + n.spriteSourceSizeW && (f.width -= f.x + f.width - n.spriteSourceSizeX - n.spriteSourceSizeW), f.y + f.height > n.spriteSourceSizeY + n.spriteSourceSizeH && (f.height -= f.y + f.height - n.spriteSourceSizeY - n.spriteSourceSizeH), f.x < n.spriteSourceSizeX) {
                                    var g = n.spriteSourceSizeX - f.x;
                                    f.x = 0, f.width -= g, f.xOffset += g
                                }
                                if (f.y < n.spriteSourceSizeY) {
                                    g = n.spriteSourceSizeY - f.y;
                                    f.y = 0, f.height -= g, f.yOffset += g
                                }
                            }
                            f.x += c, f.y += u
                        }
                        var m = t.getElementsByTagName("kerning");
                        for (d = 0; d < m.length; d++) {
                            var y = parseInt(m[d].getAttribute("first"), 10),
                                v = parseInt(m[d].getAttribute("second"), 10),
                                x = parseInt(m[d].getAttribute("amount"), 10) / r;
                            o.chars[v] && (o.chars[v].kerning[y] = x)
                        }
                        return this.finalizeBitmapFont(e, o)
                    },
                    jsonBitmapFont: function(t, e, i, s, n, r) {
                        null == r && (r = 1);
                        var o = {
                                font: t.font.info._face,
                                size: parseInt(t.font.info._size, 10),
                                lineHeight: parseInt(t.font.common._lineHeight, 10) + s,
                                chars: {}
                            },
                            a = n ? n.x : 0,
                            h = n ? n.y : 0;
                        return t.font.chars.char.forEach(function(t) {
                            var e = parseInt(t._id, 10),
                                s = o.chars[e] = {
                                    x: parseInt(t._x, 10),
                                    y: parseInt(t._y, 10),
                                    width: parseInt(t._width, 10),
                                    height: parseInt(t._height, 10),
                                    xOffset: parseInt(t._xoffset, 10) / r,
                                    yOffset: parseInt(t._yoffset, 10) / r,
                                    xAdvance: (parseInt(t._xadvance, 10) + i) / r,
                                    kerning: {}
                                };
                            if (n && n.trimmed) {
                                if (s.x + s.width > n.spriteSourceSizeX + n.spriteSourceSizeW && (s.width -= s.x + s.width - n.spriteSourceSizeX - n.spriteSourceSizeW), s.y + s.height > n.spriteSourceSizeY + n.spriteSourceSizeH && (s.height -= s.y + s.height - n.spriteSourceSizeY - n.spriteSourceSizeH), s.x < n.spriteSourceSizeX) {
                                    var l = n.spriteSourceSizeX - s.x;
                                    s.x = 0, s.width -= l, s.xOffset += l
                                }
                                if (s.y < n.spriteSourceSizeY) {
                                    l = n.spriteSourceSizeY - s.y;
                                    s.y = 0, s.height -= l, s.yOffset += l
                                }
                            }
                            s.x += a, s.y += h
                        }), t.font.kernings && t.font.kernings.kerning && t.font.kernings.kerning.forEach(function(t) {
                            o.chars[t._second] && (o.chars[t._second].kerning[t._first] = parseInt(t._amount, 10) / r)
                        }), this.finalizeBitmapFont(e, o)
                    },
                    finalizeBitmapFont: function(t, e) {
                        return Object.keys(e.chars).forEach(function(i) {
                            var s = e.chars[i];
                            s.texture = new PIXI.Texture(t, new n.Rectangle(s.x, s.y, s.width, s.height))
                        }), e
                    },
                    pvr: function(t) {
                        var e, i = new Uint32Array(t.slice(0, 52)),
                            s = new Uint8Array(t),
                            n = null,
                            r = i[3] << 32 | i[2],
                            o = 0;
                        if (55727696 === i[0] && [0, 1, 2, 3, 6, 7, 9, 11].indexOf(r) >= 0) {
                            switch (r >= 0 && r <= 3 ? e = "PVRTC" : r >= 7 && r <= 11 ? e = "S3TC" : 6 === r && (e = "ETC1"), r) {
                                case 0:
                                    o = 35841;
                                    break;
                                case 1:
                                    o = 35843;
                                    break;
                                case 2:
                                    o = 35840;
                                    break;
                                case 3:
                                    o = 35842;
                                    break;
                                case 6:
                                    o = 36196;
                                    break;
                                case 7:
                                    o = 33777;
                                    break;
                                case 9:
                                    o = 33778;
                                    break;
                                case 11:
                                    o = 33779;
                                    break;
                                default:
                                    o = -1
                            }
                            n = {
                                complete: !0,
                                fileFormat: "PVR",
                                compressionAlgorithm: e,
                                flags: i[1],
                                pixelFormat: r,
                                colorSpace: i[4],
                                channelType: i[5],
                                height: i[6],
                                width: i[7],
                                depth: i[8],
                                numberOfSurfaces: i[9],
                                numberOfFaces: i[10],
                                numberOfMipmaps: i[11],
                                metaDataSize: i[12],
                                textureData: s.subarray(52 + i[12], s.byteLength),
                                glExtensionFormat: o
                            }
                        }
                        return n
                    },
                    dds: function(t) {
                        var e = new Uint8Array(t),
                            i = new Uint32Array(t),
                            s = null;
                        return 68 === e[0] && 68 === e[1] && 83 === e[2] && 32 === e[3] && ("DX10" === (s = {
                            complete: !0,
                            fileFormat: "DDS",
                            compressionAlgorithm: "S3TC",
                            size: i[1],
                            flags: i[2],
                            height: i[3],
                            width: i[4],
                            pitch: i[5],
                            depth: i[6],
                            mipmapCount: i[7],
                            formatSize: i[19],
                            formatFlag: i[19],
                            formatFourCC: [String.fromCharCode(e[84]), String.fromCharCode(e[85]), String.fromCharCode(e[86]), String.fromCharCode(e[87])].join(""),
                            formatBitCount: i[21],
                            formatRBitMask: i[22],
                            formatGBitMask: i[23],
                            formatBBitMask: i[24],
                            formatABitMask: i[25],
                            caps1: i[26],
                            caps2: i[27],
                            caps3: i[28],
                            caps4: i[29],
                            reserved2: i[30],
                            DXGIFormat: null,
                            resourceDimension: null,
                            miscFlag: null,
                            arraySize: null,
                            textureData: e.subarray(i[1] + 4, e.byteLength)
                        }).formatFourCC ? (s.DXGIFormat = i[31], s.resourceDimension = i[32], s.miscFlag = i[33], s.arraySize = i[34], s.miscFlag = i[35]) : "DXT5" === s.formatFourCC ? s.glExtensionFormat = 33779 : "DXT3" === s.formatFourCC && (s.glExtensionFormat = 33778)), s
                    },
                    ktx: function(t) {
                        var e = new Uint8Array(t),
                            i = new Uint32Array(t),
                            s = null,
                            n = 16 + i[15] / 4 | 0,
                            r = i[n],
                            o = i[7],
                            a = 0;
                        if (171 === e[0] && 75 === e[1] && 84 === e[2] && 88 === e[3] && 32 === e[4] && 49 === e[5] && 49 === e[6] && 187 === e[7] && 13 === e[8] && 10 === e[9] && 26 === e[10] && 10 === e[11] && [36196, 35840, 35841, 35842, 35843, 33776, 33777, 33778, 33779].indexOf(o) >= 0) {
                            switch (o) {
                                case 36196:
                                    a = "ETC1";
                                    break;
                                case 35840:
                                case 35841:
                                case 35842:
                                case 35843:
                                    a = "PVRTC";
                                    break;
                                case 33776:
                                case 33777:
                                case 33778:
                                case 33779:
                                    a = "S3TC"
                            }
                            s = {
                                complete: !0,
                                fileFormat: "KTX",
                                compressionAlgorithm: a,
                                endianness: i[3],
                                glType: i[4],
                                glTypeSize: i[5],
                                glFormat: i[6],
                                glInternalFormat: i[7],
                                glBaseInternalFormat: i[8],
                                width: i[9],
                                height: i[10],
                                pixelDepth: i[11],
                                numberOfArrayElements: i[12],
                                numberOfFaces: i[13],
                                numberOfMipmapLevels: i[14],
                                bytesOfKeyValueData: i[15],
                                keyAndValueByteSize: i[16],
                                imageSize: r,
                                textureData: e.subarray(4 * (n + 1), r + 100)
                            }
                        }
                        return s
                    },
                    pkm: function(t) {
                        var e = new Uint8Array(t),
                            i = null;
                        return 80 === e[0] && 75 === e[1] && 77 === e[2] && 32 === e[3] && (i = {
                            complete: !0,
                            fileFormat: "PKM",
                            compressionAlgorithm: "ETC1",
                            format: 65535 & (e[6] << 8 | e[7]),
                            width: 65535 & (e[8] << 8 | e[9]),
                            height: 65535 & (e[10] << 8 | e[11]),
                            originalWidth: 65535 & (e[12] << 8 | e[13]),
                            originalHeight: 65535 & (e[14] << 8 | e[15]),
                            textureData: e.subarray(16, e.length)
                        }), i
                    }
                }, n.AudioSprite = function(t, e) {
                    this.game = t, this.key = e, this.config = this.game.cache.getJSON(e + "-audioatlas"), this.autoplayKey = null, this.autoplay = !1, this.sounds = {};
                    for (var i in this.config.spritemap) {
                        var s = this.config.spritemap[i],
                            n = this.game.add.sound(this.key);
                        n.addMarker(i, s.start, s.end - s.start, null, s.loop), this.sounds[i] = n
                    }
                    this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), this.autoplay = this.sounds[this.autoplayKey])
                }, n.AudioSprite.prototype = {
                    play: function(t, e) {
                        return void 0 === e && (e = 1), this.sounds[t].play(t, null, e)
                    },
                    stop: function(t) {
                        if (t) this.sounds[t].stop();
                        else
                            for (var e in this.sounds) this.sounds[e].stop()
                    },
                    get: function(t) {
                        return this.sounds[t]
                    }
                }, n.AudioSprite.prototype.constructor = n.AudioSprite, n.Sound = function(t, e, i, s, r) {
                    void 0 === i && (i = 1), void 0 === s && (s = !1), void 0 === r && (r = t.sound.connectToMaster), this.game = t, this.name = e, this.key = e, this.loop = s, this.markers = {}, this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, this.isPlaying = !1, this.currentMarker = "", this.fadeTween = null, this.pendingPlayback = !1, this.override = !1, this.allowMultiple = !1, this.playOnce = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this._sound = null, this._globalVolume = 1, this._markedToDelete = !1, this._pendingStart = !1, this._removeFromSoundManager = !1, this._sourceId = 0, this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(), this.gainNode.gain.value = i, r && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(e) && this.game.cache.isSoundReady(e) ? (this._sound = this.game.cache.getSoundData(e), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)), this.onDecoded = new n.Signal, this.onPlay = new n.Signal, this.onPause = new n.Signal, this.onResume = new n.Signal, this.onLoop = new n.Signal, this.onStop = new n.Signal, this.onMute = new n.Signal, this.onMarkerComplete = new n.Signal, this.onFadeComplete = new n.Signal, this._volume = i, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, this._tempPause = 0, this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1
                }, n.Sound.prototype = {
                    soundHasUnlocked: function(t) {
                        t === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration)
                    },
                    addMarker: function(t, e, i, s, n) {
                        void 0 !== i && null !== i || (i = 1), void 0 !== s && null !== s || (s = 1), void 0 === n && (n = !1), this.markers[t] = {
                            name: t,
                            start: e,
                            stop: e + i,
                            volume: s,
                            duration: i,
                            durationMS: 1e3 * i,
                            loop: n
                        }
                    },
                    removeMarker: function(t) {
                        delete this.markers[t]
                    },
                    onEndedHandler: function() {
                        this._removeOnEndedHandler(), this.isPlaying = !1, this.currentTime = this.durationMS, this.stop(), this.playOnce && (this._markedToDelete = !0, this._removeFromSoundManager = !0), this._markedToDelete && (this._disconnectSource(), this._removeFromSoundManager ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose()))
                    },
                    update: function() {
                        if (this.game.cache.checkSoundKey(this.key)) {
                            this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop));
                            var t = this.game.time.time;
                            if (this.isPlaying) {
                                if (this._pendingStart) {
                                    var e = this._sound.currentTime;
                                    if (!(e > ((this.paused ? this._tempPause : 0) || this.position || 0))) return;
                                    this._pendingStart = !1, this.startTime = t - 1e3 * e, this.stopTime = this.startTime + this.durationMS
                                }
                                this.currentTime = t - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), this.isPlaying = !1, "" === this.currentMarker ? (this.currentTime = 0, this.startTime = t, this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0, !1))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker && (this.currentTime = 0, this.startTime = t), this.isPlaying = !1, this.play(this.currentMarker, 0, this.volume, !0, !0, !1)) : this.stop())
                            }
                        } else this.destroy()
                    },
                    loopFull: function(t) {
                        return this.play(null, 0, t, !0)
                    },
                    play: function(t, e, i, s, n, r) {
                        if (void 0 !== t && !1 !== t && null !== t || (t = ""), void 0 === n && (n = !0), void 0 === r && (r = !0), this.isPlaying && !this.allowMultiple && !n && !this.override) return this;
                        if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || n) && (this.usingWebAudio ? this._stopSourceAndDisconnect() : this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0), this.isPlaying = !1), "" === t && Object.keys(this.markers).length > 0) return this;
                        if ("" !== t) {
                            if (!this.markers[t]) return console.warn("Phaser.Sound.play: audio marker " + t + " doesn't exist"), this;
                            this.currentMarker = t, this.position = this.markers[t].start, this.volume = this.markers[t].volume, this.loop = this.markers[t].loop, this.duration = this.markers[t].duration, this.durationMS = this.markers[t].durationMS, void 0 !== i && (this.volume = i), void 0 !== s && (this.loop = s), this._tempMarker = t, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop
                        } else e = e || 0, void 0 === i && (i = this._volume), void 0 === s && (s = this.loop), this.position = Math.max(0, e), this.volume = i, this.loop = s, this.duration = 0, this.durationMS = 0, this._tempMarker = t, this._tempPosition = e, this._tempVolume = i, this._tempLoop = s;
                        return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._createSourceAndConnect(), this.loop && "" === t && (this._sound.loop = !0), this.loop || "" !== t || this._addOnEndedHandler(), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1e3 * this.totalDuration)), this.loop && "" === t ? this._startSource(0, 0) : this._startSource(0, this.position, this.duration), this.isPlaying = !0, this.paused = !1, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, r && this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this._sound.loop = this.loop, this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this._globalVolume = this.game.sound.volume, this._sound.currentTime = this.position, this._sound.muted = this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume * this._globalVolume, this._pendingStart = !this.currentMarker, this.isPlaying = !0, this.paused = !1, this._tempPause = 0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, r && this.onPlay.dispatch(this)) : this.pendingPlayback = !0, this.playOnce && (this.loop && console.warn("Phaser.Sound.play: audio clip " + this.name + " cannot be deleted while looping."), this._markedToDelete = !0, this._removeFromSoundManager = !0), this
                    },
                    restart: function(t, e, i, s) {
                        t = t || "", e = e || 0, i = i || 1, void 0 === s && (s = !1), this.play(t, e, i, s, !0)
                    },
                    pause: function() {
                        this.isPlaying && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.time, this._tempPause = this._sound.currentTime, this.onPause.dispatch(this), this.stop())
                    },
                    resume: function() {
                        if (this.paused) {
                            if (this.usingWebAudio) {
                                var t = Math.max(0, this.position + this.pausedPosition / 1e3);
                                this._createSourceAndConnect(), "" === this.currentMarker && (this.loop ? this._sound.loop = !0 : this._addOnEndedHandler());
                                var e = this.duration - this.pausedPosition / 1e3;
                                this.loop && "" === this.currentMarker ? this._startSource(0, t) : this._startSource(0, t, e)
                            } else this._pendingStart = !this.currentMarker, this._sound.currentTime = this._tempPause, this._tempPause = 0, this._sound.play();
                            this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, this.onResume.dispatch(this)
                        }
                    },
                    stop: function() {
                        if (this.isPlaying && this._sound && (this.usingWebAudio ? this._stopSourceAndDisconnect() : this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0)), this.pendingPlayback = !1, this.isPlaying = !1, !this.paused) {
                            var t = this.currentMarker;
                            "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), this.currentMarker = "", null !== this.fadeTween && this.fadeTween.stop(), this.onStop.dispatch(this, t)
                        }
                    },
                    fadeIn: function(t, e, i) {
                        void 0 === e && (e = !1), void 0 === i && (i = this.currentMarker), this.paused || (this.play(i, 0, 0, e), this.fadeTo(t, 1))
                    },
                    fadeOut: function(t) {
                        this.fadeTo(t, 0)
                    },
                    fadeTo: function(t, e) {
                        this.isPlaying && !this.paused && e !== this.volume && (void 0 === t && (t = 1e3), void 0 !== e ? (this.fadeTween = this.game.add.tween(this).to({
                            volume: e
                        }, t, n.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this)) : console.warn("Phaser.Sound.fadeTo: No Volume Specified."))
                    },
                    fadeComplete: function() {
                        this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop()
                    },
                    updateGlobalVolume: function(t) {
                        this.usingAudioTag && this._sound && (this._globalVolume = t, this._sound.volume = this._globalVolume * this._volume)
                    },
                    destroy: function(t) {
                        void 0 === t && (t = !0), this._markedToDelete = !0, this._removeFromSoundManager = t, this.stop(), t ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose())
                    },
                    _createSourceAndConnect: function() {
                        this._sound = this.context.createBufferSource(), this._sound.connect(this.externalNode || this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), this._sound.buffer = this._buffer, this._sourceId++
                    },
                    _disconnectSource: function() {
                        this._sound.disconnect(this.externalNode || this.gainNode)
                    },
                    _startSource: function(t, e, i) {
                        void 0 === i ? this._sound.start(t || 0, e || 0) : this._sound.start(t || 0, e || 0, i)
                    },
                    _stopSourceAndDisconnect: function() {
                        this._removeOnEndedHandler();
                        try {
                            this._sound.stop(0)
                        } catch (t) {}
                        this._disconnectSource(), this._sound = null
                    },
                    _addOnEndedHandler: function() {
                        this._sound.onended = this.onEndedHandler.bind(this)
                    },
                    _removeOnEndedHandler: function() {
                        this._sound.onended = null
                    }
                }, n.Sound.prototype.constructor = n.Sound, Object.defineProperty(n.Sound.prototype, "isDecoding", {
                    get: function() {
                        return this.game.cache.getSound(this.key).isDecoding
                    }
                }), Object.defineProperty(n.Sound.prototype, "isDecoded", {
                    get: function() {
                        return this.game.cache.isSoundDecoded(this.key)
                    }
                }), Object.defineProperty(n.Sound.prototype, "mute", {
                    get: function() {
                        return this._muted || this.game.sound.mute
                    },
                    set: function(t) {
                        (t = t || !1) !== this._muted && (t ? (this._muted = !0, this._muteVolume = this._tempVolume, this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this))
                    }
                }), Object.defineProperty(n.Sound.prototype, "volume", {
                    get: function() {
                        return this._volume
                    },
                    set: function(t) {
                        this.usingAudioTag && (t = this.game.math.clamp(t, 0, 1)), this._muted ? this._muteVolume = t : (this._tempVolume = t, this._volume = t, this.usingWebAudio ? this.gainNode.gain.value = t : this.usingAudioTag && this._sound && (this._sound.volume = this._globalVolume * t))
                    }
                }), Object.defineProperty(n.Sound.prototype, "sourceId", {
                    get: function() {
                        return this._sound ? this._sourceId : null
                    }
                }), n.SoundManager = function(t) {
                    this.game = t, this.onSoundDecode = new n.Signal, this.onVolumeChange = new n.Signal, this.onMute = new n.Signal, this.onUnMute = new n.Signal, this.onTouchUnlock = new n.Signal, this.context = null, this.baseLatency = null, this.usingWebAudio = !1, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32, this.muteOnPause = !0, this._codeMuted = !1, this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], this._watchList = new n.ArraySet, this._watching = !1, this._watchCallback = null, this._watchContext = null, this._resumeWebAudioOnClick = this._resumeWebAudioOnClick.bind(this)
                }, n.SoundManager.prototype = {
                    boot: function() {
                        var t = this.game.device,
                            e = window.PhaserGlobal;
                        if (t.iOS && !1 === t.webAudio && (this.channels = 1), e) {
                            if (!0 === e.disableAudio) return this.noAudio = !0, void(this.touchLocked = !1);
                            if (!0 === e.disableWebAudio) return this.usingAudioTag = !0, void(this.touchLocked = !1)
                        }
                        if (e && e.audioContext) this.context = e.audioContext;
                        else {
                            var i = window.AudioContext || window.webkitAudioContext;
                            if (i) try {
                                this.context = new i
                            } catch (t) {
                                this.context = null, this.usingWebAudio = !1, this.touchLocked = !1, console.warn(t)
                            }
                        }
                        if (null === this.context) {
                            if (void 0 === window.Audio) return void(this.noAudio = !0);
                            this.usingAudioTag = !0
                        } else this.usingWebAudio = !0, this.baseLatency = this.context.baseLatency || 256 / (this.context.sampleRate || 44100), void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination), "suspended" === this.context.state && this.game.canvas.addEventListener("click", this._resumeWebAudioOnClick);
                        this.noAudio || t.needsTouchUnlock() && this.setTouchLock(), this.usingWebAudio && t.chrome && t.chromeVersion <= 65 && console.log('A "GainNode.gain.value setter smoothing is deprecated" notice in Chrome is normal. <https://github.com/photonstorm/phaser-ce/issues/385>')
                    },
                    setTouchLock: function() {
                        this.noAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableAudio || (this.game.input.addTouchLockCallback(this.unlock, this, !0), this.touchLocked = !0)
                    },
                    setTouchUnlock: function() {
                        this.touchLocked = !1, this._unlockSource = null, this.onTouchUnlock.dispatch()
                    },
                    resumeWebAudio: function() {
                        if (this.usingWebAudio && "suspended" === this.context.state) return this.context.resume()
                    },
                    unlock: function() {
                        if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return !0;
                        if (this.usingAudioTag) this.setTouchUnlock();
                        else if (this.usingWebAudio) {
                            var t = this.context.createBuffer(1, 1, 22050);
                            this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = t, this._unlockSource.connect(this.context.destination);
                            var e = this;
                            this._unlockSource.onended = function() {
                                e.setTouchUnlock(), e.resumeWebAudio()
                            }, void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0), this.resumeWebAudio()
                        }
                        return !0
                    },
                    stopAll: function() {
                        if (!this.noAudio)
                            for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].stop()
                    },
                    pauseAll: function() {
                        if (!this.noAudio)
                            for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].pause()
                    },
                    resumeAll: function() {
                        if (!this.noAudio)
                            for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].resume()
                    },
                    decode: function(t, e) {
                        e = e || null;
                        var i = this.game.cache.getSoundData(t);
                        if (i && !1 === this.game.cache.isSoundDecoded(t)) {
                            this.game.cache.updateSound(t, "isDecoding", !0);
                            var s = this;
                            try {
                                this.context.decodeAudioData(i, function(i) {
                                    i && (s.game.cache.decodedSound(t, i), s.onSoundDecode.dispatch(t, e))
                                })
                            } catch (t) {}
                        }
                    },
                    setDecodedCallback: function(t, e, i) {
                        "string" == typeof t && (t = [t]), this._watchList.reset();
                        for (var s = 0; s < t.length; s++) t[s] instanceof n.Sound ? this.game.cache.isSoundDecoded(t[s].key) || this._watchList.add(t[s].key) : this.game.cache.isSoundDecoded(t[s]) || this._watchList.add(t[s]);
                        0 === this._watchList.total ? (this._watching = !1, e.call(i)) : (this._watching = !0, this._watchCallback = e, this._watchContext = i)
                    },
                    update: function() {
                        if (!this.noAudio) {
                            for (var t = 0; t < this._sounds.length; t++) this._sounds[t].update();
                            if (this._watching) {
                                for (var e = this._watchList.first; e;) this.game.cache.isSoundDecoded(e) && this._watchList.remove(e), e = this._watchList.next;
                                0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext))
                            }
                        }
                    },
                    add: function(t, e, i, s) {
                        void 0 === e && (e = 1), void 0 === i && (i = !1), void 0 === s && (s = this.connectToMaster);
                        var r = new n.Sound(this.game, t, e, i, s);
                        return this._sounds.push(r), r
                    },
                    addSprite: function(t) {
                        return new n.AudioSprite(this.game, t)
                    },
                    remove: function(t) {
                        for (var e = this._sounds.length; e--;)
                            if (this._sounds[e] === t) return this._sounds[e].destroy(!1), this._sounds.splice(e, 1), !0;
                        return !1
                    },
                    removeAll: function() {
                        this.stopAll();
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].destroy();
                        this._sounds.length = 0
                    },
                    removeByKey: function(t) {
                        for (var e = this._sounds.length, i = 0; e--;) this._sounds[e].key === t && (this._sounds[e].destroy(!1), this._sounds.splice(e, 1), i++);
                        return i
                    },
                    play: function(t, e, i) {
                        if (!this.noAudio) {
                            var s = this.add(t, e, i);
                            return s.play(), s
                        }
                    },
                    setMute: function() {
                        if (!this._muted) {
                            this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                            for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !0);
                            this.onMute.dispatch()
                        }
                    },
                    unsetMute: function() {
                        if (this._muted && !this._codeMuted) {
                            this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                            for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !1);
                            this.onUnMute.dispatch()
                        }
                    },
                    destroy: function() {
                        this.removeAll(), this.onSoundDecode.dispose(), this.game.canvas.removeEventListener("click", this._resumeWebAudioOnClick), this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close())
                    },
                    _resumeWebAudioOnClick: function() {
                        this.resumeWebAudio(), this.game.canvas.removeEventListener("click", this._resumeWebAudioOnClick)
                    }
                }, n.SoundManager.prototype.constructor = n.SoundManager, Object.defineProperty(n.SoundManager.prototype, "mute", {
                    get: function() {
                        return this._muted
                    },
                    set: function(t) {
                        if (t = t || !1) {
                            if (this._muted) return;
                            this._codeMuted = !0, this.setMute()
                        } else {
                            if (!this._muted) return;
                            this._codeMuted = !1, this.unsetMute()
                        }
                    }
                }), Object.defineProperty(n.SoundManager.prototype, "volume", {
                    get: function() {
                        return this._volume
                    },
                    set: function(t) {
                        if (t < 0 ? t = 0 : t > 1 && (t = 1), this._volume !== t) {
                            if (this._volume = t, this.usingWebAudio) this.masterGain.gain.value = t;
                            else
                                for (var e = 0; e < this._sounds.length; e++) this._sounds[e].usingAudioTag && this._sounds[e].updateGlobalVolume(t);
                            this.onVolumeChange.dispatch(t)
                        }
                    }
                }), n.ScaleManager = function(t, e, i) {
                    this.game = t, this.dom = n.DOM, this.grid = null, this.width = 0, this.height = 0, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.offset = new n.Point, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, this.onOrientationChange = new n.Signal, this.enterIncorrectOrientation = new n.Signal, this.leaveIncorrectOrientation = new n.Signal, this.hasPhaserSetFullScreen = !1, this.fullScreenTarget = null, this._createdFullScreenTarget = null, this.onFullScreenInit = new n.Signal, this.onFullScreenChange = new n.Signal, this.onFullScreenError = new n.Signal, this.screenOrientation = this.dom.getScreenOrientation(), this.scaleFactor = new n.Point(1, 1), this.scaleFactorInversed = new n.Point(1, 1), this.margin = {
                        left: 0,
                        top: 0,
                        right: 0,
                        bottom: 0,
                        x: 0,
                        y: 0
                    }, this.bounds = new n.Rectangle, this.aspectRatio = 0, this.sourceAspectRatio = 0, this.event = null, this.windowConstraints = {
                        right: "layout",
                        bottom: ""
                    }, this.compatibility = {
                        supportsFullScreen: !1,
                        orientationFallback: null,
                        noMargins: !1,
                        scrollTo: null,
                        forceMinimumDocumentHeight: !1,
                        canExpandParent: !0,
                        clickTrampoline: ""
                    }, this._scaleMode = n.ScaleManager.NO_SCALE, this._fullScreenScaleMode = n.ScaleManager.NO_SCALE, this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new n.Point(1, 1), this.trackParentInterval = 2e3, this.onSizeChange = new n.Signal, this.onResize = null, this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, this._gameSize = new n.Rectangle, this._userScaleFactor = new n.Point(1, 1), this._userScaleTrim = new n.Point(0, 0), this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, this._parentBounds = new n.Rectangle, this._tempBounds = new n.Rectangle, this._lastReportedCanvasSize = new n.Rectangle, this._lastReportedGameSize = new n.Rectangle, this._booted = !1, t.config && this.parseConfig(t.config), this.setupScale(e, i)
                }, n.ScaleManager.EXACT_FIT = 0, n.ScaleManager.NO_SCALE = 1, n.ScaleManager.SHOW_ALL = 2, n.ScaleManager.RESIZE = 3, n.ScaleManager.USER_SCALE = 4, n.ScaleManager.MODES = ["EXACT_FIT", "NO_SCALE", "SHOW_ALL", "RESIZE", "USER_SCALE"], n.ScaleManager.prototype = {
                    boot: function() {
                        var t = this.compatibility;
                        t.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? t.scrollTo = new n.Point(0, 1) : t.scrollTo = new n.Point(0, 0)), this.game.device.desktop ? (t.orientationFallback = "screen", t.clickTrampoline = "when-not-mouse") : (t.orientationFallback = "", t.clickTrampoline = "");
                        var e = this;
                        this._orientationChange = function(t) {
                            return e.orientationChange(t)
                        }, this._windowResize = function(t) {
                            return e.windowResize(t)
                        }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (this._fullScreenChange = function(t) {
                            return e.fullScreenChange(t)
                        }, this._fullScreenError = function(t) {
                            return e.fullScreenError(t)
                        }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), n.FlexGrid && (this.grid = new n.FlexGrid(this, this.width, this.height)), this._booted = !0, null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null)
                    },
                    parseConfig: function(t) {
                        void 0 !== t.scaleMode && (this._booted ? this.scaleMode = t.scaleMode : this._pendingScaleMode = t.scaleMode), void 0 !== t.fullScreenScaleMode && (this.fullScreenScaleMode = t.fullScreenScaleMode), t.fullScreenTarget && (this.fullScreenTarget = t.fullScreenTarget), this.pageAlignHorizontally = t.alignH || !1, this.pageAlignVertically = t.alignV || !1, t.scaleH && t.scaleV && this.setUserScale(t.scaleH, t.scaleV, t.trimH, t.trimV)
                    },
                    setupScale: function(t, e) {
                        var i, s = new n.Rectangle;
                        "" !== this.game.parent && ("string" == typeof this.game.parent ? i = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (i = this.game.parent)), i ? (this.parentNode = i, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds, this.parentNode), s.width = this._parentBounds.width, s.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, s.width = this.dom.visualBounds.width, s.height = this.dom.visualBounds.height, this.offset.set(0, 0));
                        var r = 0,
                            o = 0;
                        "number" == typeof t ? r = t : (this.parentScaleFactor.x = parseInt(t, 10) / 100, r = s.width * this.parentScaleFactor.x), "number" == typeof e ? o = e : (this.parentScaleFactor.y = parseInt(e, 10) / 100, o = s.height * this.parentScaleFactor.y), r = Math.floor(r), o = Math.floor(o), this._gameSize.setTo(0, 0, r, o), this.updateDimensions(r, o, !1)
                    },
                    _gameResumed: function() {
                        this.queueUpdate(!0)
                    },
                    setGameSize: function(t, e) {
                        this._gameSize.setTo(0, 0, t, e), this.currentScaleMode !== n.ScaleManager.RESIZE && this.updateDimensions(t, e, !0), this.queueUpdate(!0)
                    },
                    setUserScale: function(t, e, i, s, n, r) {
                        this._userScaleFactor.setTo(t, e), this._userScaleTrim.setTo(0 | i, 0 | s), void 0 === n && (n = !0), void 0 === r && (r = !0), n && this.queueUpdate(r)
                    },
                    setResizeCallback: function(t, e) {
                        this.onResize = t, this.onResizeContext = e
                    },
                    signalSizeChange: function() {
                        if (!n.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !n.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                            var t = this.width,
                                e = this.height;
                            this._lastReportedCanvasSize.setTo(0, 0, t, e), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), this.grid && this.grid.onResize(t, e), this.onSizeChange.dispatch(this, t, e), this.currentScaleMode === n.ScaleManager.RESIZE && (this.game.state.resize(t, e), this.game.load.resize(t, e))
                        }
                    },
                    setMinMax: function(t, e, i, s) {
                        this.minWidth = t, this.minHeight = e, void 0 !== i && (this.maxWidth = i), void 0 !== s && (this.maxHeight = s)
                    },
                    preUpdate: function() {
                        if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                            var t = this._updateThrottle;
                            this._updateThrottleReset = t >= 400 ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset);
                            var e = this._parentBounds.width,
                                i = this._parentBounds.height,
                                s = this.getParentBounds(this._parentBounds),
                                r = s.width !== e || s.height !== i,
                                o = this.updateOrientationState();
                            (r || o) && (this.onResize && this.onResize.call(this.onResizeContext, this, s), this.updateLayout(), this.signalSizeChange());
                            var a = 2 * this._updateThrottle;
                            this._updateThrottle < t && (a = Math.min(t, this._updateThrottleReset)), this._updateThrottle = n.Math.clamp(a, 25, this.trackParentInterval), this._lastUpdate = this.game.time.time
                        }
                    },
                    pauseUpdate: function() {
                        this.preUpdate(), this._updateThrottle = this.trackParentInterval
                    },
                    updateDimensions: function(t, e, i) {
                        this.width = t * this.parentScaleFactor.x, this.height = e * this.parentScaleFactor.y, this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, this.updateScalingAndBounds(), i && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height))
                    },
                    updateScalingAndBounds: function() {
                        this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y)
                    },
                    forceOrientation: function(t, e) {
                        void 0 === e && (e = !1), !0 !== t || !0 !== e ? (this.forceLandscape = t, this.forcePortrait = e, this.queueUpdate(!0)) : console.warn("Phaser.ScaleManager: forceLandscape and forcePortrait cannot both be true.")
                    },
                    classifyOrientation: function(t) {
                        return "portrait-primary" === t || "portrait-secondary" === t ? "portrait" : "landscape-primary" === t || "landscape-secondary" === t ? "landscape" : null
                    },
                    updateOrientationState: function() {
                        var t = this.screenOrientation,
                            e = this.incorrectOrientation;
                        this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
                        var i = t !== this.screenOrientation,
                            s = e !== this.incorrectOrientation;
                        return s && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (i || s) && this.onOrientationChange.dispatch(this, t, e), i || s
                    },
                    orientationChange: function(t) {
                        this.event = t, this.queueUpdate(!0)
                    },
                    windowResize: function(t) {
                        this.event = t, this.queueUpdate(!0)
                    },
                    scrollTop: function() {
                        var t = this.compatibility.scrollTo;
                        t && window.scrollTo(t.x, t.y)
                    },
                    refresh: function() {
                        this.scrollTop(), this.queueUpdate(!0)
                    },
                    updateLayout: function() {
                        var t = this.currentScaleMode;
                        if (t !== n.ScaleManager.RESIZE) {
                            if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : t === n.ScaleManager.EXACT_FIT ? this.setExactFit() : t === n.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0), this.resetCanvas(), this.setShowAll()) : this.setShowAll() : t === n.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : t === n.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), !this.compatibility.canExpandParent && (t === n.ScaleManager.SHOW_ALL || t === n.ScaleManager.USER_SCALE)) {
                                var e = this.getParentBounds(this._tempBounds);
                                this.width = Math.min(this.width, e.width), this.height = Math.min(this.height, e.height)
                            }
                            this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas()
                        } else this.reflowGame()
                    },
                    getParentBounds: function(t, e) {
                        var i = t || new n.Rectangle,
                            s = e || this.boundingParent,
                            r = this.dom.visualBounds,
                            o = this.dom.layoutBounds;
                        if (s) {
                            var a = s.getBoundingClientRect(),
                                h = s.offsetParent ? s.offsetParent.getBoundingClientRect() : s.getBoundingClientRect();
                            i.setTo(a.left - h.left, a.top - h.top, a.width, a.height);
                            var l = this.windowConstraints;
                            if (l.right) {
                                var c = "layout" === l.right ? o : r;
                                i.right = Math.min(i.right, c.width)
                            }
                            if (l.bottom) {
                                c = "layout" === l.bottom ? o : r;
                                i.bottom = Math.min(i.bottom, c.height)
                            }
                        } else i.setTo(0, 0, r.width, r.height);
                        return i.setTo(Math.round(i.x), Math.round(i.y), Math.round(i.width), Math.round(i.height)), i
                    },
                    align: function(t, e) {
                        null != t && (this.pageAlignHorizontally = t), null != e && (this.pageAlignVertically = e)
                    },
                    alignCanvas: function(t, e) {
                        var i = this.getParentBounds(this._tempBounds),
                            s = this.game.canvas,
                            n = this.margin;
                        if (t) {
                            n.left = n.right = 0;
                            var r = s.getBoundingClientRect();
                            if (this.width < i.width && !this.incorrectOrientation) {
                                var o = r.left - i.x,
                                    a = i.width / 2 - this.width / 2,
                                    h = (a = Math.max(a, 0)) - o;
                                n.left = Math.round(h)
                            }
                            s.style.marginLeft = n.left + "px", 0 !== n.left && (n.right = -(i.width - r.width - n.left), s.style.marginRight = n.right + "px")
                        }
                        if (e) {
                            n.top = n.bottom = 0;
                            r = s.getBoundingClientRect();
                            if (this.height < i.height && !this.incorrectOrientation) {
                                o = r.top - i.y, a = i.height / 2 - this.height / 2, h = (a = Math.max(a, 0)) - o;
                                n.top = Math.round(h)
                            }
                            s.style.marginTop = n.top + "px", 0 !== n.top && (n.bottom = -(i.height - r.height - n.top), s.style.marginBottom = n.bottom + "px")
                        }
                        n.x = n.left, n.y = n.top
                    },
                    reflowGame: function() {
                        this.resetCanvas("", "");
                        var t = this.getParentBounds(this._tempBounds);
                        this.updateDimensions(t.width, t.height, !0)
                    },
                    reflowCanvas: function() {
                        this.incorrectOrientation || (this.width = n.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = n.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), this.updateScalingAndBounds()
                    },
                    resetCanvas: function(t, e) {
                        void 0 === t && (t = this.width + "px"), void 0 === e && (e = this.height + "px");
                        var i = this.game.canvas;
                        this.compatibility.noMargins || (i.style.marginLeft = "", i.style.marginTop = "", i.style.marginRight = "", i.style.marginBottom = ""), i.style.width = t, i.style.height = e
                    },
                    queueUpdate: function(t) {
                        t && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset
                    },
                    reset: function(t) {
                        t && this.grid && this.grid.reset()
                    },
                    setMaximum: function() {
                        this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height
                    },
                    setShowAll: function(t) {
                        var e, i = this.getParentBounds(this._tempBounds),
                            s = i.width,
                            n = i.height;
                        e = t ? Math.max(n / this.game.height, s / this.game.width) : Math.min(n / this.game.height, s / this.game.width), this.width = Math.round(this.game.width * e), this.height = Math.round(this.game.height * e)
                    },
                    setExactFit: function() {
                        var t = this.getParentBounds(this._tempBounds);
                        this.width = t.width, this.height = t.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
                    },
                    createFullScreenTarget: function() {
                        var t = document.createElement("div");
                        return t.style.margin = "0", t.style.padding = "0", t.style.background = "#000", t
                    },
                    startFullScreen: function(t, e, i) {
                        if (this.isFullScreen) return !1;
                        if (this.compatibility.supportsFullScreen) {
                            if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                                var s = this.game.input;
                                if (s.activePointer && s.activePointer !== s.mousePointer && (e || !1 !== e)) return void s.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [t, !1])
                            }
                            void 0 !== t && this.game.renderType === n.CANVAS && (this.game.stage.smoothed = t);
                            var r = this.fullScreenTarget;
                            r || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), r = this._createdFullScreenTarget);
                            var o = {
                                targetElement: r
                            };
                            if (this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, o), this._createdFullScreenTarget) {
                                var a = this.game.canvas;
                                a.parentNode.insertBefore(r, a), r.appendChild(a)
                            }
                            return void 0 === i && (i = {
                                navigationUI: "hide"
                            }), this.game.device.fullscreenKeyboard ? r[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : r[this.game.device.requestFullscreen](i), !0
                        }
                        var h = this;
                        setTimeout(function() {
                            h.fullScreenError()
                        }, 10)
                    },
                    stopFullScreen: function() {
                        return !(!this.isFullScreen || !this.compatibility.supportsFullScreen) && (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), !0)
                    },
                    cleanupCreatedTarget: function() {
                        var t = this._createdFullScreenTarget;
                        if (t && t.parentNode) {
                            var e = t.parentNode;
                            e.insertBefore(this.game.canvas, t), e.removeChild(t)
                        }
                        this._createdFullScreenTarget = null
                    },
                    prepScreenMode: function(t) {
                        var e = !!this._createdFullScreenTarget,
                            i = this._createdFullScreenTarget || this.fullScreenTarget;
                        t ? (e || this.fullScreenScaleMode === n.ScaleManager.EXACT_FIT) && i !== this.game.canvas && (this._fullScreenRestore = {
                            targetWidth: i.style.width,
                            targetHeight: i.style.height
                        }, i.style.width = "100%", i.style.height = "100%") : (this._fullScreenRestore && (i.style.width = this._fullScreenRestore.targetWidth, i.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas())
                    },
                    fullScreenChange: function(t) {
                        this.event = t, this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), this.queueUpdate(!0)) : (this.prepScreenMode(!1), this.cleanupCreatedTarget(), this.updateLayout(), this.queueUpdate(!0)), this.onFullScreenChange.dispatch(this, this.width, this.height)
                    },
                    fullScreenError: function(t) {
                        this.event = t, this.cleanupCreatedTarget(), console.warn("Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API"), this.onFullScreenError.dispatch(this)
                    },
                    scaleSprite: function(t, e, i, s) {
                        if (void 0 === e && (e = this.width), void 0 === i && (i = this.height), void 0 === s && (s = !1), !t || !t.scale) return t;
                        if (t.scale.x = 1, t.scale.y = 1, t.width <= 0 || t.height <= 0 || e <= 0 || i <= 0) return t;
                        var n = e,
                            r = t.height * e / t.width,
                            o = t.width * i / t.height,
                            a = i,
                            h = o > e;
                        return (h = h ? s : !s) ? (t.width = Math.floor(n), t.height = Math.floor(r)) : (t.width = Math.floor(o), t.height = Math.floor(a)), t
                    },
                    destroy: function() {
                        this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1))
                    }
                }, n.ScaleManager.prototype.constructor = n.ScaleManager, Object.defineProperty(n.ScaleManager.prototype, "boundingParent", {
                    get: function() {
                        return this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget ? null : this.game.canvas && this.game.canvas.parentNode || null
                    }
                }), Object.defineProperty(n.ScaleManager.prototype, "scaleMode", {
                    get: function() {
                        return this._scaleMode
                    },
                    set: function(t) {
                        return t !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = t), this._scaleMode
                    }
                }), Object.defineProperty(n.ScaleManager.prototype, "fullScreenScaleMode", {
                    get: function() {
                        return this._fullScreenScaleMode
                    },
                    set: function(t) {
                        return t !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = t, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = t), this._fullScreenScaleMode
                    }
                }), Object.defineProperty(n.ScaleManager.prototype, "currentScaleMode", {
                    get: function() {
                        return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode
                    }
                }), Object.defineProperty(n.ScaleManager.prototype, "pageAlignHorizontally", {
                    get: function() {
                        return this._pageAlignHorizontally
                    },
                    set: function(t) {
                        t !== this._pageAlignHorizontally && (this._pageAlignHorizontally = t, this.queueUpdate(!0))
                    }
                }), Object.defineProperty(n.ScaleManager.prototype, "pageAlignVertically", {
                    get: function() {
                        return this._pageAlignVertically
                    },
                    set: function(t) {
                        t !== this._pageAlignVertically && (this._pageAlignVertically = t, this.queueUpdate(!0))
                    }
                }), Object.defineProperty(n.ScaleManager.prototype, "isFullScreen", {
                    get: function() {
                        return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
                    }
                }), Object.defineProperty(n.ScaleManager.prototype, "isPortrait", {
                    get: function() {
                        return "portrait" === this.classifyOrientation(this.screenOrientation)
                    }
                }), Object.defineProperty(n.ScaleManager.prototype, "isLandscape", {
                    get: function() {
                        return "landscape" === this.classifyOrientation(this.screenOrientation)
                    }
                }), Object.defineProperty(n.ScaleManager.prototype, "isGamePortrait", {
                    get: function() {
                        return this.height > this.width
                    }
                }), Object.defineProperty(n.ScaleManager.prototype, "isGameLandscape", {
                    get: function() {
                        return this.width > this.height
                    }
                }), n.Utils.Debug = function(t) {
                    this.game = t, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, this.font = "14px monospace", this.columnWidth = 100, this.lineHeight = 16, this.lineWidth = 1, this.renderShadow = !0, this.currentColor = null, this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1, this.isDisabled = !1, this._line = null, this._rect = null
                }, n.Utils.Debug.GEOM_AUTO = 0, n.Utils.Debug.GEOM_RECTANGLE = 1, n.Utils.Debug.GEOM_CIRCLE = 2, n.Utils.Debug.GEOM_POINT = 3, n.Utils.Debug.GEOM_LINE = 4, n.Utils.Debug.GEOM_ELLIPSE = 5, n.Utils.Debug.prototype = {
                    boot: function() {
                        this.game.renderType === n.CANVAS ? this.context = this.game.context : (this.bmd = new n.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, !0), this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), this.game.scale.onSizeChange.add(this.resize, this), this.canvas = n.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d")), this._line = new n.Line, this._rect = new n.Rectangle
                    },
                    resize: function() {
                        this.bmd.resize(this.game.width, this.game.height), this.canvas.width = this.game.width, this.canvas.height = this.game.height
                    },
                    preUpdate: function() {
                        this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1)
                    },
                    reset: function() {
                        this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), this.sprite && this.bmd.clear()
                    },
                    start: function(t, e, i, s) {
                        "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), i = i || "rgb(255,255,255)", void 0 === s && (s = 0), this.currentX = t, this.currentY = e, this.currentColor = i, this.columnWidth = s, this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.strokeStyle = i, this.context.fillStyle = i, this.context.font = this.font, this.context.globalAlpha = this.currentAlpha
                    },
                    stop: function() {
                        this.context.restore()
                    },
                    line: function() {
                        for (var t = this.currentX, e = 0; e < arguments.length; e++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[e], t + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[e], t, this.currentY), t += this.columnWidth;
                        this.currentY += this.lineHeight
                    },
                    sound: function(t, e, i) {
                        var s = this.game.sound;
                        this.start(t, e, i), s.noAudio ? this.line("Audio is disabled") : (this.line("Volume: " + s.volume.toFixed(2) + (s.mute ? " (Mute)" : "")), this.line("Mute on pause: " + s.muteOnPause), this.line("Using: " + (s.usingWebAudio ? "Web Audio - " + s.context.state : "Audio Tag")), this.line("Touch locked: " + s.touchLocked), this.line("Sounds: " + s._sounds.length)), this.stop()
                    },
                    soundInfo: function(t, e, i, s) {
                        if (this.start(e, i, s), this.line("Sound: " + t.key + "  Touch locked: " + t.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(t.key) + "  Pending Playback: " + t.pendingPlayback), this.line("Decoded: " + t.isDecoded + "  Decoding: " + t.isDecoding), this.line("Playing: " + t.isPlaying + "  Loop: " + t.loop), this.line("Time: " + (t.currentTime / 1e3).toFixed(3) + "s  Total: " + t.totalDuration.toFixed(3) + "s"), this.line("Volume: " + t.volume.toFixed(2) + (t.mute ? " (Mute)" : "")), this.line("Using: " + (t.usingWebAudio ? "Web Audio" : "Audio Tag")), t.usingWebAudio && this.line("  Source: " + (t.sourceId || "none")), t.usingAudioTag && t._sound) {
                            var n = t._sound;
                            this.line("  currentSrc: " + n.currentSrc), this.line("  currentTime: " + n.currentTime), this.line("  duration: " + n.duration), this.line("  ended: " + n.ended), this.line("  loop: " + n.loop), this.line("  muted: " + n.muted), this.line("  paused: " + n.paused)
                        }
                        "" !== t.currentMarker && (this.line("Marker: " + t.currentMarker + "  Duration: " + t.duration.toFixed(3) + "s (" + t.durationMS + "ms)"), this.line("Start: " + t.markers[t.currentMarker].start.toFixed(3) + "  Stop: " + t.markers[t.currentMarker].stop.toFixed(3)), this.line("Position: " + t.position.toFixed(3))), this.stop()
                    },
                    camera: function(t, e, i) {
                        var s = t.deadzone,
                            n = t.target,
                            r = t.view;
                        s && (this._rect.setTo(r.x + s.x, r.y + s.y, s.width, s.height), this.rectangle(this._rect, e, i)), n && (this._line.setTo(r.centerX, r.centerY, n.x, n.y), this.geom(this._line, e, i), this.geom(n, e, !1, 3))
                    },
                    cameraInfo: function(t, e, i, s) {
                        var n = t.bounds,
                            r = t.deadzone,
                            o = t.target,
                            a = t.view;
                        this.start(e, i, s), this.line("Camera (" + t.width + " x " + t.height + ")"), this.line("x: " + t.x + " y: " + t.y), this.line("Bounds: " + (n ? "x: " + n.x + " y: " + n.y + " w: " + n.width + " h: " + n.height : "none")), this.line("View: x: " + a.x + " y: " + a.y + " w: " + a.width + " h: " + a.height), this.line("Center: x: " + t.centerX + " y: " + t.centerY), this.line("Deadzone: " + (r ? "x: " + r.x + " y: " + r.y + " w: " + r.width + " h: " + r.height : r)), this.line("Total in view: " + t.totalInView), this.line("At limit: x: " + t.atLimit.x + " y: " + t.atLimit.y), this.line("Target: " + (o ? o.name || o : "none")), this.stop()
                    },
                    timer: function(t, e, i, s) {
                        this.start(e, i, s), this.line("Timer (running: " + t.running + " expired: " + t.expired + ")"), this.line("Next Tick: " + t.next + " Duration: " + t.duration), this.line("Paused: " + t.paused + " Length: " + t.length), this.stop()
                    },
                    pointer: function(t, e, i, s, n, r) {
                        if (null != t && (void 0 === e && (e = !1), i = i || "rgba(0,255,0,0.5)", s = s || "rgba(255,255,0,0.5)", r = r || "rgba(255,0,0,0.5)", !0 !== e || !0 !== t.isUp)) {
                            this.start(t.x, t.y - 150, n), this.context.beginPath(), this.context.arc(t.x, t.y, t.circle.radius, 0, 2 * Math.PI), t.active ? this.context.fillStyle = t.isDown ? i : s : this.context.fillStyle = r, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(t.positionDown.x, t.positionDown.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath();
                            var o = t.movementX,
                                a = t.movementY;
                            (o || a) && (this.context.beginPath(), this.context.moveTo(o + t.position.x, a + t.position.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath()), this.line("ID: " + t.id + " Active: " + t.active), this.line("World X: " + t.worldX.toFixed(1) + " World Y: " + t.worldY.toFixed(1)), this.line("Screen X: " + t.x.toFixed(1) + " Screen Y: " + t.y.toFixed(1) + " In: " + t.withinGame), this.line("Movement: X: " + o + " Y: " + a), this.line("Duration: " + t.duration + " ms"), this.line("is Down: " + t.isDown + " is Up: " + t.isUp), t.isMouse && this.line("Buttons: " + this._pointerButtonIcon(t.leftButton) + " " + this._pointerButtonIcon(t.middleButton) + " " + this._pointerButtonIcon(t.rightButton)), this.stop()
                        }
                    },
                    _pointerButtonIcon: function(t) {
                        return t.isDown ? "x" : t.isUp ? "o" : "-"
                    },
                    spriteInputInfo: function(t, e, i, s) {
                        this.start(e, i, s), this.line("Sprite Input: (" + t.width + " x " + t.height + ")"), this.line("x: " + t.input.pointerX().toFixed(1) + " y: " + t.input.pointerY().toFixed(1)), this.line("over: " + t.input.pointerOver() + " duration: " + t.input.overDuration().toFixed(0)), this.line("down: " + t.input.pointerDown() + " duration: " + t.input.downDuration().toFixed(0)), this.line("just over: " + t.input.justOver() + " just out: " + t.input.justOut()), this.stop()
                    },
                    key: function(t, e, i, s) {
                        this.start(e, i, s, 150), this.line("Key:", t.keyCode, "isDown:", t.isDown), this.line("justDown:", t.justDown, "justUp:", t.justUp), this.line("Time Down:", t.timeDown.toFixed(0), "duration:", t.duration.toFixed(0)), this.stop()
                    },
                    inputInfo: function(t, e, i, s) {
                        var r = this.game.input;
                        if (void 0 === s && (s = !0), this.start(t, e, i), this.line("Input"), this.line("X: " + r.x + " Y: " + r.y), this.line("World X: " + r.worldX + " World Y: " + r.worldY), this.line("Scale X: " + r.scale.x.toFixed(2) + " Scale Y: " + r.scale.x.toFixed(2)), this.line("Screen X: " + r.activePointer.screenX.toFixed(1) + " Screen Y: " + r.activePointer.screenY.toFixed(1)), s) {
                            this.line("Sources:"), this.line("  " + this._inputHandler(r.mouse, "mouse")), this.line("  " + this._inputHandler(r.mspointer, "mspointer")), this.line("  " + this._inputHandler(r.touch, "touch"));
                            var o = r.pointers,
                                a = r.mousePointer,
                                h = n.PointerModes;
                            this.line("Pointers: (Max: " + r.maxPointers + ")"), this.line("  " + (a.isDown ? "x" : "o") + " " + h[a.pointerMode] + " " + a.identifier);
                            for (var l = 0; l < o.length; l++) {
                                var c = o[l];
                                this.line("  " + (c.active ? "+" : "-") + " " + h[c.pointerMode] + " " + c.identifier)
                            }
                            this.stop()
                        } else this.stop()
                    },
                    _inputHandler: function(t, e) {
                        return this._inputHandlerStatusIcon(t) + " " + e + " " + this._inputHandlerCaptureIcon(t)
                    },
                    _inputHandlerStatusIcon: function(t) {
                        return t.active ? t.enabled ? "+" : "-" : " "
                    },
                    _inputHandlerCaptureIcon: function(t) {
                        return t.active && (t.capture || t.preventDefault) ? "*" : " "
                    },
                    spriteBounds: function(t, e, i) {
                        var s = t.getBounds();
                        s.x += this.game.camera.x, s.y += this.game.camera.y, this.rectangle(s, e, i)
                    },
                    ropeSegments: function(t, e, i) {
                        var s = this;
                        t.segments.forEach(function(t) {
                            s.rectangle(t, e, i)
                        }, this)
                    },
                    spriteInfo: function(t, e, i, s) {
                        this.start(e, i, s), this.line("Sprite: " + (t.name || "") + " (" + t.width + " x " + t.height + ") anchor: " + t.anchor.x + " x " + t.anchor.y), this.line("x: " + t.x.toFixed(1) + " y: " + t.y.toFixed(1)), this.line("angle: " + t.angle.toFixed(1) + " rotation: " + t.rotation.toFixed(1)), this.line("visible: " + t.visible + " in camera: " + t.inCamera), this.line("bounds x: " + t._bounds.x.toFixed(1) + " y: " + t._bounds.y.toFixed(1) + " w: " + t._bounds.width.toFixed(1) + " h: " + t._bounds.height.toFixed(1)), this.line("parent: " + (t.parent ? t.parent.name || "(DisplayObject)" : "(none)")), this.stop()
                    },
                    spriteCoords: function(t, e, i, s) {
                        this.start(e, i, s, 100), t.name && this.line(t.name), this.line("x:", t.x.toFixed(2), "y:", t.y.toFixed(2)), this.line("pos x:", t.position.x.toFixed(2), "pos y:", t.position.y.toFixed(2)), this.line("world x:", t.world.x.toFixed(2), "world y:", t.world.y.toFixed(2)), this.stop()
                    },
                    lineInfo: function(t, e, i, s) {
                        this.start(e, i, s, 80), this.line("start.x:", t.start.x.toFixed(2), "start.y:", t.start.y.toFixed(2)), this.line("end.x:", t.end.x.toFixed(2), "end.y:", t.end.y.toFixed(2)), this.line("length:", t.length.toFixed(2), "angle:", t.angle), this.stop()
                    },
                    pixel: function(t, e, i, s) {
                        s = s || 2, this.start(), this.context.fillStyle = i, this.context.fillRect(t, e, s, s), this.stop()
                    },
                    geom: function(t, e, i, s) {
                        void 0 === i && (i = !0), void 0 === s && (s = 0), e = e || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = e, this.context.strokeStyle = e, this.context.lineWidth = this.lineWidth;
                        var r = n.Utils.Debug;
                        s === r.GEOM_RECTANGLE || t instanceof n.Rectangle ? i ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : s === r.GEOM_CIRCLE || t instanceof n.Circle ? (this.context.beginPath(), this.context.arc(t.x - this.game.camera.x, t.y - this.game.camera.y, t.radius, 0, 2 * Math.PI, !1), this.context.closePath(), i ? this.context.fill() : this.context.stroke()) : s === r.GEOM_POINT || t instanceof n.Point ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, 4, 4) : s === r.GEOM_LINE || t instanceof n.Line ? (this.context.beginPath(), this.context.moveTo(t.start.x + .5 - this.game.camera.x, t.start.y + .5 - this.game.camera.y), this.context.lineTo(t.end.x + .5 - this.game.camera.x, t.end.y + .5 - this.game.camera.y), this.context.closePath(), this.context.stroke()) : (s === r.GEOM_ELLIPSE || t instanceof n.Ellipse) && (this.context.beginPath(), this.context.ellipse(t.centerX - this.game.camera.x, t.centerY - this.game.camera.y, t.width / 2, t.height / 2, 0, 2 * Math.PI, !1), this.context.closePath(), i ? this.context.fill() : this.context.stroke()), this.stop()
                    },
                    rectangle: function(t, e, i) {
                        void 0 === i && (i = !0), e = e || "rgba(0, 255, 0, 0.4)", this.start(), i ? (this.context.fillStyle = e, this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)) : (this.context.lineWidth = this.lineWidth, this.context.strokeStyle = e, this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)), this.stop()
                    },
                    text: function(t, e, i, s, n) {
                        s = s || "rgb(255,255,255)", n = n || this.font, this.start(), this.context.font = n, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(t, e + 1, i + 1)), this.context.fillStyle = s, this.context.fillText(t, e, i), this.stop()
                    },
                    quadTree: function(t, e) {
                        e = e || "rgba(255,0,0,0.3)", this.start();
                        var i = t.bounds;
                        if (0 === t.nodes.length) {
                            this.context.strokeStyle = e, this.context.strokeRect(i.x, i.y, i.width, i.height), this.text("size: " + t.objects.length, i.x + 4, i.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)";
                            for (var s = 0; s < t.objects.length; s++) this.context.strokeRect(t.objects[s].x, t.objects[s].y, t.objects[s].width, t.objects[s].height)
                        } else
                            for (s = 0; s < t.nodes.length; s++) this.quadTree(t.nodes[s]);
                        this.stop()
                    },
                    body: function(t, e, i) {
                        t.body && (this.start(), t.body.type === n.Physics.ARCADE ? n.Physics.Arcade.Body.render(this.context, t.body, e, i, this.lineWidth) : t.body.type === n.Physics.NINJA ? n.Physics.Ninja.Body.render(this.context, t.body, e, i) : t.body.type === n.Physics.BOX2D && n.Physics.Box2D.renderBody(this.context, t.body, e), this.stop())
                    },
                    bodyInfo: function(t, e, i, s) {
                        t.body && (this.start(e, i, s, 210), t.body.type === n.Physics.ARCADE ? n.Physics.Arcade.Body.renderBodyInfo(this, t.body) : t.body.type === n.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, t.body), this.stop())
                    },
                    box2dWorld: function() {
                        this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), this.game.physics.box2d.renderDebugDraw(this.context), this.stop()
                    },
                    box2dBody: function(t, e) {
                        this.start(), n.Physics.Box2D.renderBody(this.context, t, e), this.stop()
                    },
                    displayList: function(t) {
                        if (void 0 === t && (t = this.game.world), t.hasOwnProperty("renderOrderID") ? console.log("[" + t.renderOrderID + "]", t) : console.log("[]", t), t.children && t.children.length > 0)
                            for (var e = 0; e < t.children.length; e++) this.game.debug.displayList(t.children[e])
                    },
                    renderer: function(t, e, i) {
                        var s = this.game.renderer,
                            n = s.renderSession;
                        if (this.start(t, e, i), this.line((s.gl ? "WebGL" : "Canvas") + " Renderer (" + s.width + " x " + s.height + ")"), this.line("autoResize: " + s.autoResize), this.line("clearBeforeRender: " + s.clearBeforeRender), this.line("resolution: " + s.resolution), this.line("transparent: " + s.transparent), this.line("renderSession:"), s.gl) {
                            this.line("  currentBatchedTextures: (" + s.currentBatchedTextures.length + ")");
                            for (var r = 0; r < s.currentBatchedTextures.length; r++) this.line("    " + s.currentBatchedTextures[r]);
                            this.line("  drawCount: " + n.drawCount), this.line("  maxTextures: " + s.maxTextures), this.line("  maxTextureSize: " + s.maxTextureSize), this.line("  maxTextureAvailableSpace: " + n.maxTextureAvailableSpace), this.line("  roundPixels: " + n.roundPixels)
                        } else this.line("  roundPixels: " + n.roundPixels), this.line("  scaleMode: " + (0 === n.scaleMode ? "LINEAR" : 1 === n.scaleMode ? "NEAREST" : n.scaleMode));
                        this.stop()
                    },
                    canvasPool: function(t, e, i, s) {
                        var r = n.CanvasPool;
                        this.start(t, e, i, s || 100), this.line("Canvas Pool"), this.line("Used:", r.getTotal()), this.line("Free:", r.getFree()), this.line("Total:", r.length), this.stop()
                    },
                    physicsGroup: function(t, e, i, s) {
                        t.forEach(this.body, this, s, e, i)
                    },
                    phaser: function(t, e, i) {
                        this.text("Phaser v" + n.VERSION + " " + (this.game.renderType === n.WEBGL ? "WebGL" : "Canvas") + " " + (this.game.device.webAudio ? "WebAudio" : "HTML Audio"), t, e, i, this.font)
                    },
                    scale: function(t, e, i) {
                        this.start(t, e, i);
                        var s = this.game.scale,
                            r = s.scaleFactorInversed,
                            o = s._parentBounds;
                        t = " x ";
                        this.line("Game: " + this.game.width + t + this.game.height), this.line("Canvas: " + s.width + t + s.height + " (" + r.x.toFixed(2) + t + r.y.toFixed(2) + ") [" + s.aspectRatio.toFixed(2) + "]"), this.line("Mode: " + n.ScaleManager.MODES[s.currentScaleMode] + (s.currentScaleMode === n.ScaleManager.USER_SCALE ? " (" + s._userScaleFactor.x + t + s._userScaleFactor.y + ")" : "")), this.line("Parent: " + (s.parentIsWindow ? "window" : s.parentNode) + (o.empty ? "" : " (" + o.width + t + o.height + ")")), this.line("Screen: " + s.classifyOrientation(s.screenOrientation) + (s.incorrectOrientation ? " (incorrect)" : "")), this.stop()
                    },
                    loader: function(t, e, i, s) {
                        var r = n.Utils.pad;
                        this.start(e, i, s), t.hasLoaded ? this.line("Complete" + (t.resetLocked ? " [locked]" : "")) : t.isLoading ? this.line("Loading") : this.line("Not started"), t.hasLoaded && !t.resetLocked || (this.line("Progress: " + r(t.progress, 3) + "%"), this.line("Files: " + t._loadedFileCount + " of " + t._totalFileCount), this.line("Packs: " + t._loadedPackCount + " of " + t._loadedPackCount)), this.stop()
                    },
                    device: function(t, e, i) {
                        var s = this.game.device;
                        this.start(t, e, i), this.line("Device"), this.line("Pointer Events: " + s.mspointer), this.line("Touch: " + s.touch), this.line("Web Audio: " + s.webAudio), this.line("WebGL: " + s.webGL), this.stop()
                    },
                    destroy: function() {
                        n.CanvasPool.remove(this)
                    }
                }, n.Utils.Debug.prototype.constructor = n.Utils.Debug, n.DOM = {
                    getOffset: function(t, e) {
                        e = e || new n.Point;
                        var i = t.getBoundingClientRect(),
                            s = n.DOM.scrollY,
                            r = n.DOM.scrollX,
                            o = document.documentElement.clientTop,
                            a = document.documentElement.clientLeft;
                        return e.x = i.left + r - a, e.y = i.top + s - o, e
                    },
                    getBounds: function(t, e) {
                        return void 0 === e && (e = 0), !(!(t = t && !t.nodeType ? t[0] : t) || 1 !== t.nodeType) && this.calibrate(t.getBoundingClientRect(), e)
                    },
                    calibrate: function(t, e) {
                        e = +e || 0;
                        var i = {
                            width: 0,
                            height: 0,
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0
                        };
                        return i.width = (i.right = t.right + e) - (i.left = t.left - e), i.height = (i.bottom = t.bottom + e) - (i.top = t.top - e), i
                    },
                    getAspectRatio: function(t) {
                        var e = (t = null == t ? this.visualBounds : 1 === t.nodeType ? this.getBounds(t) : t).width,
                            i = t.height;
                        return "function" == typeof e && (e = e.call(t)), "function" == typeof i && (i = i.call(t)), e / i
                    },
                    inLayoutViewport: function(t, e) {
                        var i = this.getBounds(t, e);
                        return !!i && i.bottom >= 0 && i.right >= 0 && i.top <= this.layoutBounds.width && i.left <= this.layoutBounds.height
                    },
                    getScreenOrientation: function(t) {
                        var e = window.screen,
                            i = e.orientation || e.mozOrientation || e.msOrientation;
                        if (i && "string" == typeof i.type) return i.type;
                        if ("string" == typeof i) return i;
                        var s = "portrait-primary",
                            n = "landscape-primary";
                        if ("screen" === t) return e.height > e.width ? s : n;
                        if ("viewport" === t) return this.visualBounds.height > this.visualBounds.width ? s : n;
                        if ("window.orientation" === t && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? s : n;
                        if (window.matchMedia) {
                            if (window.matchMedia("(orientation: portrait)").matches) return s;
                            if (window.matchMedia("(orientation: landscape)").matches) return n
                        }
                        return this.visualBounds.height > this.visualBounds.width ? s : n
                    },
                    visualBounds: new n.Rectangle,
                    layoutBounds: new n.Rectangle,
                    documentBounds: new n.Rectangle
                }, n.Device.whenReady(function(t) {
                    var e = window && "pageXOffset" in window ? function() {
                            return window.pageXOffset
                        } : function() {
                            return document.documentElement.scrollLeft
                        },
                        i = window && "pageYOffset" in window ? function() {
                            return window.pageYOffset
                        } : function() {
                            return document.documentElement.scrollTop
                        };
                    if (Object.defineProperty(n.DOM, "scrollX", {
                            get: e
                        }), Object.defineProperty(n.DOM, "scrollY", {
                            get: i
                        }), Object.defineProperty(n.DOM.visualBounds, "x", {
                            get: e
                        }), Object.defineProperty(n.DOM.visualBounds, "y", {
                            get: i
                        }), Object.defineProperty(n.DOM.layoutBounds, "x", {
                            value: 0
                        }), Object.defineProperty(n.DOM.layoutBounds, "y", {
                            value: 0
                        }), t.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight) {
                        var s = function() {
                                return Math.max(window.innerWidth, document.documentElement.clientWidth)
                            },
                            r = function() {
                                return Math.max(window.innerHeight, document.documentElement.clientHeight)
                            };
                        Object.defineProperty(n.DOM.visualBounds, "width", {
                            get: s
                        }), Object.defineProperty(n.DOM.visualBounds, "height", {
                            get: r
                        }), Object.defineProperty(n.DOM.layoutBounds, "width", {
                            get: s
                        }), Object.defineProperty(n.DOM.layoutBounds, "height", {
                            get: r
                        })
                    } else Object.defineProperty(n.DOM.visualBounds, "width", {
                        get: function() {
                            return window.innerWidth
                        }
                    }), Object.defineProperty(n.DOM.visualBounds, "height", {
                        get: function() {
                            return window.innerHeight
                        }
                    }), Object.defineProperty(n.DOM.layoutBounds, "width", {
                        get: function() {
                            var t = document.documentElement.clientWidth,
                                e = window.innerWidth;
                            return t < e ? e : t
                        }
                    }), Object.defineProperty(n.DOM.layoutBounds, "height", {
                        get: function() {
                            var t = document.documentElement.clientHeight,
                                e = window.innerHeight;
                            return t < e ? e : t
                        }
                    });
                    Object.defineProperty(n.DOM.documentBounds, "x", {
                        value: 0
                    }), Object.defineProperty(n.DOM.documentBounds, "y", {
                        value: 0
                    }), Object.defineProperty(n.DOM.documentBounds, "width", {
                        get: function() {
                            var t = document.documentElement;
                            return Math.max(t.clientWidth, t.offsetWidth, t.scrollWidth)
                        }
                    }), Object.defineProperty(n.DOM.documentBounds, "height", {
                        get: function() {
                            var t = document.documentElement;
                            return Math.max(t.clientHeight, t.offsetHeight, t.scrollHeight)
                        }
                    })
                }, null, !0), n.ArraySet = function(t) {
                    this.position = 0, this.list = t || []
                }, n.ArraySet.prototype = {
                    add: function(t) {
                        return this.exists(t) || this.list.push(t), t
                    },
                    getIndex: function(t) {
                        return this.list.indexOf(t)
                    },
                    getByKey: function(t, e) {
                        for (var i = this.list.length; i--;)
                            if (this.list[i][t] === e) return this.list[i];
                        return null
                    },
                    exists: function(t) {
                        return this.list.indexOf(t) > -1
                    },
                    reset: function() {
                        this.list.length = 0
                    },
                    remove: function(t) {
                        var e = this.list.indexOf(t);
                        if (e > -1) return this.list.splice(e, 1), t
                    },
                    setAll: function(t, e) {
                        for (var i = this.list.length; i--;) this.list[i] && (this.list[i][t] = e)
                    },
                    callAll: function(t) {
                        for (var e = Array.prototype.slice.call(arguments, 1), i = this.list.length; i--;) this.list[i] && this.list[i][t] && this.list[i][t].apply(this.list[i], e)
                    },
                    removeAll: function(t) {
                        void 0 === t && (t = !1);
                        for (var e = this.list.length; e--;)
                            if (this.list[e]) {
                                var i = this.remove(this.list[e]);
                                t && i.destroy()
                            } this.position = 0, this.list = []
                    }
                }, Object.defineProperty(n.ArraySet.prototype, "total", {
                    get: function() {
                        return this.list.length
                    }
                }), Object.defineProperty(n.ArraySet.prototype, "first", {
                    get: function() {
                        return this.position = 0, this.list.length > 0 ? this.list[0] : null
                    }
                }), Object.defineProperty(n.ArraySet.prototype, "next", {
                    get: function() {
                        return this.position < this.list.length ? (this.position++, this.list[this.position]) : null
                    }
                }), n.ArraySet.prototype.constructor = n.ArraySet, n.ArrayUtils = {
                    getRandomItem: function(t, e, i) {
                        if (null === t) return null;
                        void 0 === e && (e = 0), void 0 === i && (i = t.length);
                        var s = e + Math.floor(Math.random() * i);
                        return void 0 === t[s] ? null : t[s]
                    },
                    removeRandomItem: function(t, e, i) {
                        if (null == t) return null;
                        void 0 === e && (e = 0), void 0 === i && (i = t.length);
                        var s = e + Math.floor(Math.random() * i);
                        if (s < t.length) {
                            var n = t.splice(s, 1);
                            return void 0 === n[0] ? null : n[0]
                        }
                        return null
                    },
                    remove: function(t, e, i) {
                        var s = t.length;
                        if (!(e >= s || 0 === i)) {
                            null == i && (i = 1);
                            for (var n = s - i, r = e; r < n; ++r) t[r] = t[r + i];
                            t.length = n
                        }
                    },
                    shuffle: function(t) {
                        for (var e = t.length - 1; e > 0; e--) {
                            var i = Math.floor(Math.random() * (e + 1)),
                                s = t[e];
                            t[e] = t[i], t[i] = s
                        }
                        return t
                    },
                    transposeMatrix: function(t) {
                        for (var e = t.length, i = t[0].length, s = new Array(i), n = 0; n < i; n++) {
                            s[n] = new Array(e);
                            for (var r = e - 1; r > -1; r--) s[n][r] = t[r][n]
                        }
                        return s
                    },
                    rotateMatrix: function(t, e) {
                        if ("string" != typeof e && (e = (e % 360 + 360) % 360), 90 === e || -270 === e || "rotateLeft" === e) t = (t = n.ArrayUtils.transposeMatrix(t)).reverse();
                        else if (-90 === e || 270 === e || "rotateRight" === e) t = t.reverse(), t = n.ArrayUtils.transposeMatrix(t);
                        else if (180 === Math.abs(e) || "rotate180" === e) {
                            for (var i = 0; i < t.length; i++) t[i].reverse();
                            t = t.reverse()
                        }
                        return t
                    },
                    findClosest: function(t, e) {
                        if (!e.length) return NaN;
                        if (1 === e.length || t < e[0]) return e[0];
                        for (var i = 1; e[i] < t;) i++;
                        var s = e[i - 1],
                            n = i < e.length ? e[i] : Number.POSITIVE_INFINITY;
                        return n - t <= t - s ? n : s
                    },
                    rotateRight: function(t) {
                        var e = t.pop();
                        return t.unshift(e), e
                    },
                    rotateLeft: function(t) {
                        var e = t.shift();
                        return t.push(e), e
                    },
                    numberArray: function(t, e) {
                        void 0 !== e && null !== e || (e = t, t = 0);
                        for (var i = [], s = t; s <= e; s++) i.push(s);
                        return i
                    },
                    numberArrayStep: function(t, e, i) {
                        void 0 !== t && null !== t || (t = 0), void 0 !== e && null !== e || (e = t, t = 0), void 0 === i && (i = 1);
                        for (var s = [], r = Math.max(n.Math.roundAwayFromZero((e - t) / (i || 1)), 0), o = 0; o < r; o++) s.push(t), t += i;
                        return s
                    }
                }, n.LinkedList = function() {
                    this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0
                }, n.LinkedList.prototype = {
                    add: function(t) {
                        return 0 === this.total && null === this.first && null === this.last ? (this.first = t, this.last = t, this.next = t, t.prev = this, this.total++, t) : (this.last.next = t, t.prev = this.last, this.last = t, this.total++, t)
                    },
                    reset: function() {
                        this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0
                    },
                    remove: function(t) {
                        if (1 === this.total) return this.reset(), void(t.next = t.prev = null);
                        t === this.first ? this.first = this.first.next : t === this.last && (this.last = this.last.prev), t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.next = t.prev = null, null === this.first && (this.last = null), this.total--
                    },
                    callAll: function(t) {
                        if (this.first && this.last) {
                            var e = this.first;
                            do {
                                e && e[t] && e[t].call(e), e = e.next
                            } while (e !== this.last.next)
                        }
                    }
                }, n.LinkedList.prototype.constructor = n.LinkedList, n.Create = function(t) {
                    this.game = t, this.bmd = null, this.canvas = null, this.ctx = null, this.palettes = [{
                        0: "#000",
                        1: "#9D9D9D",
                        2: "#FFF",
                        3: "#BE2633",
                        4: "#E06F8B",
                        5: "#493C2B",
                        6: "#A46422",
                        7: "#EB8931",
                        8: "#F7E26B",
                        9: "#2F484E",
                        A: "#44891A",
                        B: "#A3CE27",
                        C: "#1B2632",
                        D: "#005784",
                        E: "#31A2F2",
                        F: "#B2DCEF"
                    }, {
                        0: "#000",
                        1: "#191028",
                        2: "#46af45",
                        3: "#a1d685",
                        4: "#453e78",
                        5: "#7664fe",
                        6: "#833129",
                        7: "#9ec2e8",
                        8: "#dc534b",
                        9: "#e18d79",
                        A: "#d6b97b",
                        B: "#e9d8a1",
                        C: "#216c4b",
                        D: "#d365c8",
                        E: "#afaab9",
                        F: "#f5f4eb"
                    }, {
                        0: "#000",
                        1: "#2234d1",
                        2: "#0c7e45",
                        3: "#44aacc",
                        4: "#8a3622",
                        5: "#5c2e78",
                        6: "#aa5c3d",
                        7: "#b5b5b5",
                        8: "#5e606e",
                        9: "#4c81fb",
                        A: "#6cd947",
                        B: "#7be2f9",
                        C: "#eb8a60",
                        D: "#e23d69",
                        E: "#ffd93f",
                        F: "#fff"
                    }, {
                        0: "#000",
                        1: "#fff",
                        2: "#8b4131",
                        3: "#7bbdc5",
                        4: "#8b41ac",
                        5: "#6aac41",
                        6: "#3931a4",
                        7: "#d5de73",
                        8: "#945a20",
                        9: "#5a4100",
                        A: "#bd736a",
                        B: "#525252",
                        C: "#838383",
                        D: "#acee8b",
                        E: "#7b73de",
                        F: "#acacac"
                    }, {
                        0: "#000",
                        1: "#191028",
                        2: "#46af45",
                        3: "#a1d685",
                        4: "#453e78",
                        5: "#7664fe",
                        6: "#833129",
                        7: "#9ec2e8",
                        8: "#dc534b",
                        9: "#e18d79",
                        A: "#d6b97b",
                        B: "#e9d8a1",
                        C: "#216c4b",
                        D: "#d365c8",
                        E: "#afaab9",
                        F: "#fff"
                    }]
                }, n.Create.PALETTE_ARNE = 0, n.Create.PALETTE_JMP = 1, n.Create.PALETTE_CGA = 2, n.Create.PALETTE_C64 = 3, n.Create.PALETTE_JAPANESE_MACHINE = 4, n.Create.prototype = {
                    texture: function(t, e, i, s, n, r, o, a) {
                        void 0 === i && (i = 8), void 0 === s && (s = i), void 0 === n && (n = 0), void 0 === r && (r = !0);
                        var h = e[0].length * i,
                            l = e.length * s;
                        null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(h, l), this.bmd.clear();
                        for (var c = 0; c < e.length; c++)
                            for (var u = e[c], d = 0; d < u.length; d++) {
                                var p = u[d];
                                "." !== p && " " !== p && (this.ctx.fillStyle = this.palettes[n][p], this.ctx.fillRect(d * i, c * s, i, s))
                            }
                        return r ? this.bmd.generateTexture(t, o, a) : this.copy()
                    },
                    grid: function(t, e, i, s, n, r, o, a, h) {
                        void 0 === o && (o = !0), null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(e, i), this.ctx.fillStyle = r;
                        for (var l = 0; l < i; l += n) this.ctx.fillRect(0, l, e, 1);
                        for (var c = 0; c < e; c += s) this.ctx.fillRect(c, 0, 1, i);
                        return o ? this.bmd.generateTexture(t, a, h) : this.copy()
                    },
                    copy: function(t, e, i, s, n, r, o) {
                        return null == t && (t = this.game.make.bitmapData()), t.resize(this.bmd.width, this.bmd.height), t.draw(this.bmd, e, i, s, n, r, o)
                    }
                }, n.Create.prototype.constructor = n.Create, n.FlexGrid = function(t, e, i) {
                    this.game = t.game, this.manager = t, this.width = e, this.height = i, this.boundsCustom = new n.Rectangle(0, 0, e, i), this.boundsFluid = new n.Rectangle(0, 0, e, i), this.boundsFull = new n.Rectangle(0, 0, e, i), this.boundsNone = new n.Rectangle(0, 0, e, i), this.positionCustom = new n.Point(0, 0), this.positionFluid = new n.Point(0, 0), this.positionFull = new n.Point(0, 0), this.positionNone = new n.Point(0, 0), this.scaleCustom = new n.Point(1, 1), this.scaleFluid = new n.Point(1, 1), this.scaleFluidInversed = new n.Point(1, 1), this.scaleFull = new n.Point(1, 1), this.scaleNone = new n.Point(1, 1), this.customWidth = 0, this.customHeight = 0, this.customOffsetX = 0, this.customOffsetY = 0, this.ratioH = e / i, this.ratioV = i / e, this.multiplier = 0, this.layers = []
                }, n.FlexGrid.prototype = {
                    setSize: function(t, e) {
                        this.width = t, this.height = e, this.ratioH = t / e, this.ratioV = e / t, this.scaleNone = new n.Point(1, 1), this.boundsNone.width = this.width, this.boundsNone.height = this.height, this.refresh()
                    },
                    createCustomLayer: function(t, e, i, s) {
                        void 0 === s && (s = !0), this.customWidth = t, this.customHeight = e, this.boundsCustom.width = t, this.boundsCustom.height = e;
                        var r = new n.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
                        return s && this.game.world.add(r), this.layers.push(r), i && r.addMultiple(i), r
                    },
                    createFluidLayer: function(t, e) {
                        void 0 === e && (e = !0);
                        var i = new n.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
                        return e && this.game.world.add(i), this.layers.push(i), t && i.addMultiple(t), i
                    },
                    createFullLayer: function(t) {
                        var e = new n.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
                        return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e
                    },
                    createFixedLayer: function(t) {
                        var e = new n.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
                        return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e
                    },
                    reset: function() {
                        for (var t = this.layers.length; t--;) this.layers[t].persist || (this.layers[t].position = null, this.layers[t].scale = null, this.layers.slice(t, 1))
                    },
                    onResize: function(t, e) {
                        this.ratioH = t / e, this.ratioV = e / t, this.refresh(t, e)
                    },
                    refresh: function() {
                        this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width), this.boundsFluid.width = Math.round(this.width * this.multiplier), this.boundsFluid.height = Math.round(this.height * this.multiplier), this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height), this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height), this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height), this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x), this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y), this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y), this.positionNone.set(this.boundsNone.x, this.boundsNone.y)
                    },
                    fitSprite: function(t) {
                        this.manager.scaleSprite(t), t.x = this.manager.bounds.centerX, t.y = this.manager.bounds.centerY
                    },
                    debug: function() {
                        this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16), this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1)
                    }
                }, n.FlexGrid.prototype.constructor = n.FlexGrid, n.FlexLayer = function(t, e, i, s) {
                    n.Group.call(this, t.game, null, "__flexLayer" + t.game.rnd.uuid(), !1), this.manager = t.manager, this.grid = t, this.persist = !1, this.position = e, this.bounds = i, this.scale = s, this.topLeft = i.topLeft, this.topMiddle = new n.Point(i.halfWidth, 0), this.topRight = i.topRight, this.bottomLeft = i.bottomLeft, this.bottomMiddle = new n.Point(i.halfWidth, i.bottom), this.bottomRight = i.bottomRight
                }, n.FlexLayer.prototype = Object.create(n.Group.prototype), n.FlexLayer.prototype.constructor = n.FlexLayer, n.FlexLayer.prototype.resize = function() {}, n.FlexLayer.prototype.debug = function() {
                    this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16), this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1), this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9")
                }, n.Color = {
                    RED: 16711680,
                    ORANGE: 16750848,
                    YELLOW: 16776960,
                    GREEN: 65280,
                    AQUA: 65535,
                    BLUE: 255,
                    VIOLET: 16711935,
                    WHITE: 16777215,
                    BLACK: 0,
                    GRAY: 6710886,
                    packPixel: function(t, e, i, s) {
                        return n.Device.LITTLE_ENDIAN ? (s << 24 | i << 16 | e << 8 | t) >>> 0 : (t << 24 | e << 16 | i << 8 | s) >>> 0
                    },
                    unpackPixel: function(t, e, i, s) {
                        return void 0 !== e && null !== e || (e = n.Color.createColor()), void 0 !== i && null !== i || (i = !1), void 0 !== s && null !== s || (s = !1), n.Device.LITTLE_ENDIAN ? (e.a = (4278190080 & t) >>> 24, e.b = (16711680 & t) >>> 16, e.g = (65280 & t) >>> 8, e.r = 255 & t) : (e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t), e.color = t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a / 255 + ")", i && n.Color.RGBtoHSL(e.r, e.g, e.b, e), s && n.Color.RGBtoHSV(e.r, e.g, e.b, e), e
                    },
                    fromRGBA: function(t, e) {
                        return e || (e = n.Color.createColor()), e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a + ")", e
                    },
                    toRGBA: function(t, e, i, s) {
                        return t << 24 | e << 16 | i << 8 | s
                    },
                    toABGR: function(t, e, i, s) {
                        return (s << 24 | i << 16 | e << 8 | t) >>> 0
                    },
                    hexToRGBArray: function(t) {
                        return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255]
                    },
                    RGBArrayToHex: function(t) {
                        return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
                    },
                    RGBtoHSL: function(t, e, i, s) {
                        s || (s = n.Color.createColor(t, e, i, 1)), t /= 255, e /= 255, i /= 255;
                        var r = Math.min(t, e, i),
                            o = Math.max(t, e, i);
                        if (s.h = 0, s.s = 0, s.l = (o + r) / 2, o !== r) {
                            var a = o - r;
                            s.s = s.l > .5 ? a / (2 - o - r) : a / (o + r), o === t ? s.h = (e - i) / a + (e < i ? 6 : 0) : o === e ? s.h = (i - t) / a + 2 : o === i && (s.h = (t - e) / a + 4), s.h /= 6
                        }
                        return s
                    },
                    HSLtoRGB: function(t, e, i, s) {
                        if (s ? (s.r = i, s.g = i, s.b = i) : s = n.Color.createColor(i, i, i), 0 !== e) {
                            var r = i < .5 ? i * (1 + e) : i + e - i * e,
                                o = 2 * i - r;
                            s.r = n.Color.hueToColor(o, r, t + 1 / 3), s.g = n.Color.hueToColor(o, r, t), s.b = n.Color.hueToColor(o, r, t - 1 / 3)
                        }
                        return s.r = Math.floor(255 * s.r | 0), s.g = Math.floor(255 * s.g | 0), s.b = Math.floor(255 * s.b | 0), n.Color.updateColor(s), s
                    },
                    RGBtoHSV: function(t, e, i, s) {
                        s || (s = n.Color.createColor(t, e, i, 255)), t /= 255, e /= 255, i /= 255;
                        var r = Math.min(t, e, i),
                            o = Math.max(t, e, i),
                            a = o - r;
                        return s.h = 0, s.s = 0 === o ? 0 : a / o, s.v = o, o !== r && (o === t ? s.h = (e - i) / a + (e < i ? 6 : 0) : o === e ? s.h = (i - t) / a + 2 : o === i && (s.h = (t - e) / a + 4), s.h /= 6), s
                    },
                    HSVtoRGB: function(t, e, i, s) {
                        var r, o, a;
                        void 0 === s && (s = n.Color.createColor(0, 0, 0, 1, t, e, 0, i));
                        var h = Math.floor(6 * t),
                            l = 6 * t - h,
                            c = i * (1 - e),
                            u = i * (1 - l * e),
                            d = i * (1 - (1 - l) * e);
                        switch (h % 6) {
                            case 0:
                                r = i, o = d, a = c;
                                break;
                            case 1:
                                r = u, o = i, a = c;
                                break;
                            case 2:
                                r = c, o = i, a = d;
                                break;
                            case 3:
                                r = c, o = u, a = i;
                                break;
                            case 4:
                                r = d, o = c, a = i;
                                break;
                            case 5:
                                r = i, o = c, a = u
                        }
                        return s.r = Math.floor(255 * r), s.g = Math.floor(255 * o), s.b = Math.floor(255 * a), n.Color.updateColor(s), s
                    },
                    hueToColor: function(t, e, i) {
                        return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
                    },
                    createColor: function(t, e, i, s, r, o, a, h) {
                        var l = {
                            r: t || 0,
                            g: e || 0,
                            b: i || 0,
                            a: s || 1,
                            h: r || 0,
                            s: o || 0,
                            l: a || 0,
                            v: h || 0,
                            color: 0,
                            color32: 0,
                            rgba: ""
                        };
                        return n.Color.updateColor(l)
                    },
                    updateColor: function(t) {
                        return t.rgba = "rgba(" + t.r.toFixed() + "," + t.g.toFixed() + "," + t.b.toFixed() + "," + t.a.toString() + ")", t.color = n.Color.getColor(t.r, t.g, t.b), t.color32 = n.Color.getColor32(255 * t.a, t.r, t.g, t.b), t
                    },
                    getColor32: function(t, e, i, s) {
                        return t << 24 | e << 16 | i << 8 | s
                    },
                    getColor: function(t, e, i) {
                        return t << 16 | e << 8 | i
                    },
                    RGBtoString: function(t, e, i, s, r) {
                        return void 0 === s && (s = 255), void 0 === r && (r = "#"), "#" === r ? "#" + ((1 << 24) + (t << 16) + (e << 8) + i).toString(16).slice(1) : "0x" + n.Color.componentToHex(s) + n.Color.componentToHex(t) + n.Color.componentToHex(e) + n.Color.componentToHex(i)
                    },
                    hexToRGB: function(t) {
                        var e = n.Color.hexToColor(t);
                        if (e) return n.Color.getColor32(e.a, e.r, e.g, e.b)
                    },
                    hexToColor: function(t, e) {
                        t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(t, e, i, s) {
                            return e + e + i + i + s + s
                        });
                        var i = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
                        if (i) {
                            var s = parseInt(i[1], 16),
                                r = parseInt(i[2], 16),
                                o = parseInt(i[3], 16);
                            e ? (e.r = s, e.g = r, e.b = o) : e = n.Color.createColor(s, r, o)
                        }
                        return e
                    },
                    webToColor: function(t, e) {
                        e || (e = n.Color.createColor());
                        var i = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t);
                        return i && (e.r = ~~Number(i[1]), e.g = ~~Number(i[2]), e.b = ~~Number(i[3]), e.a = void 0 !== i[4] ? Number(i[4]) : 1, n.Color.updateColor(e)), e
                    },
                    valueToColor: function(t, e) {
                        if (e || (e = n.Color.createColor()), "string" == typeof t) return 0 === t.indexOf("rgb") ? n.Color.webToColor(t, e) : (e.a = 1, n.Color.hexToColor(t, e));
                        if ("number" == typeof t) {
                            var i = n.Color.getRGB(t);
                            return e.r = i.r, e.g = i.g, e.b = i.b, e.a = i.a / 255, e
                        }
                        return e
                    },
                    componentToHex: function(t) {
                        var e = t.toString(16);
                        return 1 === e.length ? "0" + e : e
                    },
                    HSVColorWheel: function(t, e) {
                        void 0 === t && (t = 1), void 0 === e && (e = 1);
                        for (var i = [], s = 0; s <= 359; s++) i.push(n.Color.HSVtoRGB(s / 359, t, e));
                        return i
                    },
                    HSLColorWheel: function(t, e) {
                        void 0 === t && (t = .5), void 0 === e && (e = .5);
                        for (var i = [], s = 0; s <= 359; s++) i.push(n.Color.HSLtoRGB(s / 359, t, e));
                        return i
                    },
                    interpolateColor: function(t, e, i, s, r, o) {
                        void 0 === r && (r = 255), void 0 === o && (o = 0);
                        var a = n.Color.getRGB(t),
                            h = n.Color.getRGB(e);
                        if (0 === o) var l = (h.red - a.red) * s / i + a.red,
                            c = (h.green - a.green) * s / i + a.green,
                            u = (h.blue - a.blue) * s / i + a.blue;
                        if (1 === o) {
                            var d, p = n.Color.RGBtoHSV(a.r, a.g, a.b),
                                f = n.Color.RGBtoHSV(h.r, h.g, h.b),
                                g = f.h - p.h;
                            if (p.h > f.h) {
                                var m = f.h;
                                f.h = p.h, p.h = m, g = -g, s = i - s
                            }
                            g > .5 && (p.h = p.h + 1, d = ((f.h - p.h) * s / i + p.h) % 1), g <= .5 && (d = (f.h - p.h) * s / i + p.h);
                            var y = (f.s - p.s) * s / i + p.s,
                                v = (f.v - p.v) * s / i + p.v,
                                x = n.Color.HSVtoRGB(d, y, v, x);
                            l = x.r, c = x.g, u = x.b
                        }
                        return n.Color.getColor32(r, l, c, u)
                    },
                    interpolateColorWithRGB: function(t, e, i, s, r, o) {
                        var a = n.Color.getRGB(t),
                            h = (e - a.red) * o / r + a.red,
                            l = (i - a.green) * o / r + a.green,
                            c = (s - a.blue) * o / r + a.blue;
                        return n.Color.getColor(h, l, c)
                    },
                    interpolateRGB: function(t, e, i, s, r, o, a, h) {
                        var l = (s - t) * h / a + t,
                            c = (r - e) * h / a + e,
                            u = (o - i) * h / a + i;
                        return n.Color.getColor(l, c, u)
                    },
                    linear: function(t, e, i) {
                        return this.interpolateColor(t, e, 1, i)
                    },
                    linearInterpolation: function(t, e) {
                        var i = n.Math.linear(0, t.length - 1, e),
                            s = t[Math.floor(i)],
                            r = t[Math.ceil(i)];
                        return this.linear(s, r, i % 1)
                    },
                    getRandomColor: function(t, e, i) {
                        if (void 0 === t && (t = 0), void 0 === e && (e = 255), void 0 === i && (i = 255), e > 255 || t > e) return n.Color.getColor(255, 255, 255);
                        var s = t + Math.round(Math.random() * (e - t)),
                            r = t + Math.round(Math.random() * (e - t)),
                            o = t + Math.round(Math.random() * (e - t));
                        return n.Color.getColor32(i, s, r, o)
                    },
                    getRGB: function(t) {
                        return t > 16777215 ? {
                            alpha: t >>> 24,
                            red: t >> 16 & 255,
                            green: t >> 8 & 255,
                            blue: 255 & t,
                            a: t >>> 24,
                            r: t >> 16 & 255,
                            g: t >> 8 & 255,
                            b: 255 & t
                        } : {
                            alpha: 255,
                            red: t >> 16 & 255,
                            green: t >> 8 & 255,
                            blue: 255 & t,
                            a: 255,
                            r: t >> 16 & 255,
                            g: t >> 8 & 255,
                            b: 255 & t
                        }
                    },
                    getWebRGB: function(t) {
                        if ("object" == typeof t) return "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + (t.a / 255).toString() + ")";
                        var e = n.Color.getRGB(t);
                        return "rgba(" + e.r.toString() + "," + e.g.toString() + "," + e.b.toString() + "," + (e.a / 255).toString() + ")"
                    },
                    getAlpha: function(t) {
                        return t >>> 24
                    },
                    getAlphaFloat: function(t) {
                        return (t >>> 24) / 255
                    },
                    getRed: function(t) {
                        return t >> 16 & 255
                    },
                    getGreen: function(t) {
                        return t >> 8 & 255
                    },
                    getBlue: function(t) {
                        return 255 & t
                    },
                    blendNormal: function(t) {
                        return t
                    },
                    blendLighten: function(t, e) {
                        return e > t ? e : t
                    },
                    blendDarken: function(t, e) {
                        return e > t ? t : e
                    },
                    blendMultiply: function(t, e) {
                        return t * e / 255
                    },
                    blendAverage: function(t, e) {
                        return (t + e) / 2
                    },
                    blendAdd: function(t, e) {
                        return Math.min(255, t + e)
                    },
                    blendSubtract: function(t, e) {
                        return Math.max(0, t + e - 255)
                    },
                    blendDifference: function(t, e) {
                        return Math.abs(t - e)
                    },
                    blendNegation: function(t, e) {
                        return 255 - Math.abs(255 - t - e)
                    },
                    blendScreen: function(t, e) {
                        return 255 - ((255 - t) * (255 - e) >> 8)
                    },
                    blendExclusion: function(t, e) {
                        return t + e - 2 * t * e / 255
                    },
                    blendOverlay: function(t, e) {
                        return e < 128 ? 2 * t * e / 255 : 255 - 2 * (255 - t) * (255 - e) / 255
                    },
                    blendSoftLight: function(t, e) {
                        return e < 128 ? 2 * (64 + (t >> 1)) * (e / 255) : 255 - 2 * (255 - (64 + (t >> 1))) * (255 - e) / 255
                    },
                    blendHardLight: function(t, e) {
                        return n.Color.blendOverlay(e, t)
                    },
                    blendColorDodge: function(t, e) {
                        return 255 === e ? e : Math.min(255, (t << 8) / (255 - e))
                    },
                    blendColorBurn: function(t, e) {
                        return 0 === e ? e : Math.max(0, 255 - (255 - t << 8) / e)
                    },
                    blendLinearDodge: function(t, e) {
                        return n.Color.blendAdd(t, e)
                    },
                    blendLinearBurn: function(t, e) {
                        return n.Color.blendSubtract(t, e)
                    },
                    blendLinearLight: function(t, e) {
                        return e < 128 ? n.Color.blendLinearBurn(t, 2 * e) : n.Color.blendLinearDodge(t, 2 * (e - 128))
                    },
                    blendVividLight: function(t, e) {
                        return e < 128 ? n.Color.blendColorBurn(t, 2 * e) : n.Color.blendColorDodge(t, 2 * (e - 128))
                    },
                    blendPinLight: function(t, e) {
                        return e < 128 ? n.Color.blendDarken(t, 2 * e) : n.Color.blendLighten(t, 2 * (e - 128))
                    },
                    blendHardMix: function(t, e) {
                        return n.Color.blendVividLight(t, e) < 128 ? 0 : 255
                    },
                    blendReflect: function(t, e) {
                        return 255 === e ? e : Math.min(255, t * t / (255 - e))
                    },
                    blendGlow: function(t, e) {
                        return n.Color.blendReflect(e, t)
                    },
                    blendPhoenix: function(t, e) {
                        return Math.min(t, e) - Math.max(t, e) + 255
                    }
                }, n.Physics = function(t, e) {
                    e = e || {}, this.game = t, this.config = e, this.arcade = null, this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.matter = null, this.parseConfig()
                }, n.Physics.ARCADE = 0, n.Physics.P2JS = 1, n.Physics.NINJA = 2, n.Physics.BOX2D = 3, n.Physics.CHIPMUNK = 4, n.Physics.MATTERJS = 5, n.Physics.prototype = {
                    parseConfig: function() {
                        this.config.hasOwnProperty("arcade") && !0 !== this.config.arcade || !n.Physics.hasOwnProperty("Arcade") || (this.arcade = new n.Physics.Arcade(this.game)), this.config.hasOwnProperty("ninja") && !0 === this.config.ninja && n.Physics.hasOwnProperty("Ninja") && (this.ninja = new n.Physics.Ninja(this.game)), this.config.hasOwnProperty("p2") && !0 === this.config.p2 && n.Physics.hasOwnProperty("P2") && (this.p2 = new n.Physics.P2(this.game, this.config)), this.config.hasOwnProperty("box2d") && !0 === this.config.box2d && n.Physics.hasOwnProperty("BOX2D") && (this.box2d = new n.Physics.Box2D(this.game, this.config)), this.config.hasOwnProperty("matter") && !0 === this.config.matter && n.Physics.hasOwnProperty("Matter") && (this.matter = new n.Physics.Matter(this.game, this.config))
                    },
                    startSystem: function(t) {
                        t === n.Physics.ARCADE ? this.arcade = new n.Physics.Arcade(this.game) : t === n.Physics.P2JS ? null === this.p2 ? this.p2 = new n.Physics.P2(this.game, this.config) : this.p2.reset() : t === n.Physics.NINJA ? this.ninja = new n.Physics.Ninja(this.game) : t === n.Physics.BOX2D ? null === this.box2d ? this.box2d = new n.Physics.Box2D(this.game, this.config) : this.box2d.reset() : t === n.Physics.MATTERJS && (null === this.matter ? this.matter = new n.Physics.Matter(this.game, this.config) : this.matter.reset())
                    },
                    enable: function(t, e, i) {
                        void 0 === e && (e = n.Physics.ARCADE), void 0 === i && (i = !1), e === n.Physics.ARCADE ? this.arcade.enable(t) : e === n.Physics.P2JS && this.p2 ? this.p2.enable(t, i) : e === n.Physics.NINJA && this.ninja ? this.ninja.enableAABB(t) : e === n.Physics.BOX2D && this.box2d ? this.box2d.enable(t) : e === n.Physics.MATTERJS && this.matter ? this.matter.enable(t) : console.warn(t.key + " is attempting to enable a physics body using an unknown physics system.")
                    },
                    preUpdate: function() {
                        this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate()
                    },
                    update: function() {
                        this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update()
                    },
                    setBoundsToWorld: function() {
                        this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld()
                    },
                    clear: function() {
                        this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear()
                    },
                    reset: function() {
                        this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset()
                    },
                    destroy: function() {
                        this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), this.arcade = null, this.ninja = null, this.p2 = null, this.box2d = null, this.matter = null
                    }
                }, n.Physics.prototype.constructor = n.Physics, n.Particles = function(t) {
                    this.game = t, this.emitters = {}, this.ID = 0
                }, n.Particles.prototype = {
                    add: function(t) {
                        return this.emitters[t.id] = t, t
                    },
                    remove: function(t) {
                        delete this.emitters[t.id]
                    }
                }, n.Particles.prototype.constructor = n.Particles, n.Video = function(t, e, i) {
                    if (void 0 === e && (e = null), void 0 === i && (i = null), this.game = t, this.key = e, this.width = 0, this.height = 0, this.type = n.VIDEO, this.disableTextureUpload = !1, this.touchLocked = !1, this.onPlay = new n.Signal, this.onChangeSource = new n.Signal, this.onComplete = new n.Signal, this.onAccess = new n.Signal, this.onError = new n.Signal, this.onTimeout = new n.Signal, this.onTouchUnlock = new n.Signal, this.playWhenUnlocked = !0, this.timeout = 15e3, this._timeOutID = null, this.video = null, this.videoStream = null, this.isStreaming = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._codeMuted = !1, this._muted = !1, this._codePaused = !1, this._paused = !1, this._pending = !1, this._pendingChangeSource = !1, this._autoplay = !1, this._endCallback = null, this._playCallback = null, e && this.game.cache.checkVideoKey(e)) {
                        var s = this.game.cache.getVideo(e);
                        s.isBlob ? this.createVideoFromBlob(s.data) : this.video = s.data, this.width = this.video.videoWidth, this.height = this.video.videoHeight
                    } else i && this.createVideoFromURL(i, !1);
                    this.video && !i ? (this.baseTexture = new PIXI.BaseTexture(this.video, null, this.game.resolution), this.baseTexture.forceLoaded(this.width, this.height)) : (this.baseTexture = new PIXI.BaseTexture(n.Cache.DEFAULT.baseTexture.source, null, this.game.resolution), this.baseTexture.forceLoaded(this.width, this.height)), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new n.Frame(0, 0, 0, this.width, this.height, "video"), this.texture.setFrame(this.textureFrame), this.texture.valid = !1, null !== e && this.video && (this.texture.valid = this.video.canplay), this.snapshot = null, n.BitmapData && (this.snapshot = new n.BitmapData(this.game, "", this.width, this.height)), this.game.device.needsTouchUnlock() ? this.setTouchLock() : s && (s.locked = !1)
                }, n.Video.prototype = {
                    connectToMediaStream: function(t, e) {
                        return t && e && (this.video = t, this.videoStream = e, this.isStreaming = !0, this.baseTexture.source = this.video, this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this)), this
                    },
                    startMediaStream: function(t, e, i) {
                        if (void 0 === t && (t = !1), void 0 === e && (e = null), void 0 === i && (i = null), !this.game.device.getUserMedia) return this.onError.dispatch(this, "No getUserMedia"), !1;
                        null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()), this.removeVideoElement(), this.video = document.createElement("video"), this.video.setAttribute("autoplay", "autoplay"), this.video.setAttribute("playsinline", "playsinline"), null !== e && (this.video.width = e), null !== i && (this.video.height = i), this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
                        try {
                            navigator.getUserMedia({
                                audio: t,
                                video: !0
                            }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this))
                        } catch (t) {
                            this.getUserMediaError(t)
                        }
                        return this
                    },
                    getUserMediaTimeout: function() {
                        clearTimeout(this._timeOutID), this.onTimeout.dispatch(this)
                    },
                    getUserMediaError: function(t) {
                        clearTimeout(this._timeOutID), this.onError.dispatch(this, t)
                    },
                    getUserMediaSuccess: function(t) {
                        clearTimeout(this._timeOutID), this.videoStream = t, void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = t : void 0 !== this.video.srcObject ? this.video.srcObject = t : this.video.src = window.URL && window.URL.createObjectURL(t) || t;
                        var e = this;
                        this.video.onloadeddata = function() {
                            var t = 10;
                            ! function i() {
                                if (t > 0)
                                    if (e.video.videoWidth > 0) {
                                        var s = e.video.videoWidth,
                                            n = e.video.videoHeight;
                                        isNaN(e.video.videoHeight) && (n = s / (4 / 3)), e.video.play(), e.isStreaming = !0, e.baseTexture.source = e.video, e.updateTexture(null, s, n), e.onAccess.dispatch(e)
                                    } else window.setTimeout(i, 500);
                                else console.warn("Unable to connect to video stream. Webcam error?");
                                t--
                            }()
                        }
                    },
                    createVideoFromBlob: function(t) {
                        var e = this;
                        return this.video = document.createElement("video"), this.video.controls = !1, this.video.setAttribute("autoplay", "autoplay"), this.video.setAttribute("playsinline", "playsinline"), this.video.addEventListener("loadeddata", function(t) {
                            e.updateTexture(t)
                        }, !0), this.video.src = window.URL.createObjectURL(t), this.video.canplay = !0, this
                    },
                    createVideoFromURL: function(t, e) {
                        return void 0 === e && (e = !1), this.texture && (this.texture.valid = !1), this.video = document.createElement("video"), this.video.controls = !1, e && this.video.setAttribute("autoplay", "autoplay"), this.video.setAttribute("playsinline", "playsinline"), this.video.src = t, this.video.canplay = !0, this.video.load(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.key = t, this
                    },
                    updateTexture: function(t, e, i) {
                        var s = !1;
                        void 0 !== e && null !== e || (e = this.video.videoWidth, s = !0), void 0 !== i && null !== i || (i = this.video.videoHeight), this.width = e, this.height = i, this.baseTexture.source !== this.video && (this.baseTexture.source = this.video), this.baseTexture.forceLoaded(e, i), this.texture.frame.resize(e, i), this.texture.width = e, this.texture.height = i, this.texture.valid = !0, this.snapshot && this.snapshot.resize(e, i), s && null !== this.key && (this.onChangeSource.dispatch(this, e, i), this._autoplay && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)))
                    },
                    complete: function() {
                        this.onComplete.dispatch(this)
                    },
                    play: function(t, e) {
                        return this._pendingChangeSource ? this : (void 0 === t && (t = !1), void 0 === e && (e = 1), this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()), this.game.onPause.add(this.setPause, this), this.game.onResume.add(this.setResume, this), this._endCallback = this.complete.bind(this), this.video.addEventListener("ended", this._endCallback, !0), this.video.addEventListener("webkitendfullscreen", this._endCallback, !0), this.video.loop = t ? "loop" : "", this.video.playbackRate = e, this.touchLocked ? this._pending = !0 : (this._pending = !1, null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this), this.video.addEventListener("playing", this._playCallback, !0))), this.video.play(), this.onPlay.dispatch(this, t, e)), this)
                    },
                    playHandler: function() {
                        this.video.removeEventListener("playing", this._playCallback, !0), this.updateTexture()
                    },
                    stop: function() {
                        return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), this.game.sound.onUnMute.remove(this.unsetMute, this)), this.game.onPause.remove(this.setPause, this), this.game.onResume.remove(this.setResume, this), this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(), this.video.src = null) : this.video.srcObject ? (this.video.srcObject.stop(), this.video.src = null) : (this.video.src = "", this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.getTracks ? this.videoStream.getTracks().forEach(function(t) {
                            t.stop()
                        }) : this.videoStream.stop()), this.videoStream = null, this.isStreaming = !1) : (this.video.removeEventListener("ended", this._endCallback, !0), this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0), this.video.removeEventListener("playing", this._playCallback, !0), this.touchLocked ? this._pending = !1 : this.video.pause()), this
                    },
                    add: function(t) {
                        if (Array.isArray(t))
                            for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                        else t.loadTexture(this);
                        return this
                    },
                    addToWorld: function(t, e, i, s, n, r) {
                        n = n || 1, r = r || 1;
                        var o = this.game.add.image(t, e, this);
                        return o.anchor.set(i, s), o.scale.set(n, r), o
                    },
                    render: function() {
                        !this.disableTextureUpload && this.playing && this.baseTexture.dirty()
                    },
                    setMute: function() {
                        this._muted || (this._muted = !0, this.video.muted = !0)
                    },
                    unsetMute: function() {
                        this._muted && !this._codeMuted && (this._muted = !1, this.video.muted = !1)
                    },
                    setPause: function() {
                        this._paused || this.touchLocked || (this._paused = !0, this.video.pause())
                    },
                    setResume: function() {
                        !this._paused || this._codePaused || this.touchLocked || (this._paused = !1, this.video.ended || this.video.play())
                    },
                    changeSource: function(t, e) {
                        return void 0 === e && (e = !0), this.texture.valid = !1, this.video.pause(), this._pendingChangeSource = !0, this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.video.src = t, this.video.load(), this._autoplay = e, e || (this.paused = !0), this
                    },
                    checkVideoProgress: function() {
                        4 === this.video.readyState ? (this._pendingChangeSource = !1, this.updateTexture()) : (this.retry--, this.retry > 0 ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : console.warn("Phaser.Video: Unable to start downloading video in time", this.isStreaming))
                    },
                    setTouchLock: function() {
                        this.game.input.addTouchLockCallback(this.unlock, this, !0), this.touchLocked = !0
                    },
                    unlock: function() {
                        if (this.touchLocked = !1, this.playWhenUnlocked && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)), this.key) {
                            var t = this.game.cache.getVideo(this.key);
                            t && !t.isBlob && (t.locked = !1)
                        }
                        return this.onTouchUnlock.dispatch(this), !0
                    },
                    grab: function(t, e, i) {
                        if (void 0 === t && (t = !1), void 0 === e && (e = 1), void 0 === i && (i = null), null !== this.snapshot) return t && this.snapshot.cls(), this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, e, i), this.snapshot;
                        console.warn("Video.grab cannot run because Phaser.BitmapData is unavailable")
                    },
                    removeVideoElement: function() {
                        if (this.video) {
                            for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes();) this.video.removeChild(this.video.firstChild);
                            this.video.removeAttribute("autoplay"), this.video.removeAttribute("src"), this.video = null
                        }
                    },
                    destroy: function() {
                        this.stop(), this.removeVideoElement(), this.touchLocked && this.game.input.removeTouchLockCallback(this.unlock, this), this._retryID && window.clearTimeout(this._retryID)
                    }
                }, Object.defineProperty(n.Video.prototype, "currentTime", {
                    get: function() {
                        return this.video ? this.video.currentTime : 0
                    },
                    set: function(t) {
                        this.video.currentTime = t
                    }
                }), Object.defineProperty(n.Video.prototype, "duration", {
                    get: function() {
                        return this.video ? this.video.duration : 0
                    }
                }), Object.defineProperty(n.Video.prototype, "progress", {
                    get: function() {
                        return this.video ? this.video.currentTime / this.video.duration : 0
                    }
                }), Object.defineProperty(n.Video.prototype, "mute", {
                    get: function() {
                        return this._muted
                    },
                    set: function(t) {
                        if (t = t || null) {
                            if (this._muted) return;
                            this._codeMuted = !0, this.setMute()
                        } else {
                            if (!this._muted) return;
                            this._codeMuted = !1, this.unsetMute()
                        }
                    }
                }), Object.defineProperty(n.Video.prototype, "paused", {
                    get: function() {
                        return this._paused
                    },
                    set: function(t) {
                        if (t = t || null, !this.touchLocked)
                            if (t) {
                                if (this._paused) return;
                                this._codePaused = !0, this.setPause()
                            } else {
                                if (!this._paused) return;
                                this._codePaused = !1, this.setResume()
                            }
                    }
                }), Object.defineProperty(n.Video.prototype, "volume", {
                    get: function() {
                        return this.video ? this.video.volume : 1
                    },
                    set: function(t) {
                        t < 0 ? t = 0 : t > 1 && (t = 1), this.video && (this.video.volume = t)
                    }
                }), Object.defineProperty(n.Video.prototype, "playbackRate", {
                    get: function() {
                        return this.video ? this.video.playbackRate : 1
                    },
                    set: function(t) {
                        this.video && (this.video.playbackRate = t)
                    }
                }), Object.defineProperty(n.Video.prototype, "loop", {
                    get: function() {
                        return !!this.video && this.video.loop
                    },
                    set: function(t) {
                        t && this.video ? this.video.loop = "loop" : this.video && (this.video.loop = "")
                    }
                }), Object.defineProperty(n.Video.prototype, "playing", {
                    get: function() {
                        return !!this.video && !(this.video.paused && this.video.ended)
                    }
                }), n.Video.prototype.constructor = n.Video, void 0 === PIXI.blendModes && (PIXI.blendModes = n.blendModes), void 0 === PIXI.scaleModes && (PIXI.scaleModes = n.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)), void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new n.Matrix), PIXI.TextureSilentFail = !0, PIXI.canUseNewCanvasBlendModes = function() {
                    return n.Device.canUseMultiply
                }, void 0 !== t && t.exports && (e = t.exports = n), e.Phaser = n, n
            }.call(this)
    }).call(e, i(27))
}, function(t, e) {
    var i, s, n = t.exports = {};

    function r() {
        throw new Error("setTimeout has not been defined")
    }

    function o() {
        throw new Error("clearTimeout has not been defined")
    }

    function a(t) {
        if (i === setTimeout) return setTimeout(t, 0);
        if ((i === r || !i) && setTimeout) return i = setTimeout, setTimeout(t, 0);
        try {
            return i(t, 0)
        } catch (e) {
            try {
                return i.call(null, t, 0)
            } catch (e) {
                return i.call(this, t, 0)
            }
        }
    }! function() {
        try {
            i = "function" == typeof setTimeout ? setTimeout : r
        } catch (t) {
            i = r
        }
        try {
            s = "function" == typeof clearTimeout ? clearTimeout : o
        } catch (t) {
            s = o
        }
    }();
    var h, l = [],
        c = !1,
        u = -1;

    function d() {
        c && h && (c = !1, h.length ? l = h.concat(l) : u = -1, l.length && p())
    }

    function p() {
        if (!c) {
            var t = a(d);
            c = !0;
            for (var e = l.length; e;) {
                for (h = l, l = []; ++u < e;) h && h[u].run();
                u = -1, e = l.length
            }
            h = null, c = !1,
                function(t) {
                    if (s === clearTimeout) return clearTimeout(t);
                    if ((s === o || !s) && clearTimeout) return s = clearTimeout, clearTimeout(t);
                    try {
                        s(t)
                    } catch (e) {
                        try {
                            return s.call(null, t)
                        } catch (e) {
                            return s.call(this, t)
                        }
                    }
                }(t)
        }
    }

    function f(t, e) {
        this.fun = t, this.array = e
    }

    function g() {}
    n.nextTick = function(t) {
        var e = new Array(arguments.length - 1);
        if (arguments.length > 1)
            for (var i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
        l.push(new f(t, e)), 1 !== l.length || c || a(p)
    }, f.prototype.run = function() {
        this.fun.apply(null, this.array)
    }, n.title = "browser", n.browser = !0, n.env = {}, n.argv = [], n.version = "", n.versions = {}, n.on = g, n.addListener = g, n.once = g, n.off = g, n.removeListener = g, n.removeAllListeners = g, n.emit = g, n.prependListener = g, n.prependOnceListener = g, n.listeners = function(t) {
        return []
    }, n.binding = function(t) {
        throw new Error("process.binding is not supported")
    }, n.cwd = function() {
        return "/"
    }, n.chdir = function(t) {
        throw new Error("process.chdir is not supported")
    }, n.umask = function() {
        return 0
    }
}, function(t, e, i) {
    var s;
    ! function() {
        function n(t, e, i) {
            return t.call.apply(t.bind, arguments)
        }

        function r(t, e, i) {
            if (!t) throw Error();
            if (2 < arguments.length) {
                var s = Array.prototype.slice.call(arguments, 2);
                return function() {
                    var i = Array.prototype.slice.call(arguments);
                    return Array.prototype.unshift.apply(i, s), t.apply(e, i)
                }
            }
            return function() {
                return t.apply(e, arguments)
            }
        }

        function o(t, e, i) {
            return (o = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? n : r).apply(null, arguments)
        }
        var a = Date.now || function() {
            return +new Date
        };
        var h = !!window.FontFace;

        function l(t, e, i, s) {
            if (e = t.c.createElement(e), i)
                for (var n in i) i.hasOwnProperty(n) && ("style" == n ? e.style.cssText = i[n] : e.setAttribute(n, i[n]));
            return s && e.appendChild(t.c.createTextNode(s)), e
        }

        function c(t, e, i) {
            (t = t.c.getElementsByTagName(e)[0]) || (t = document.documentElement), t.insertBefore(i, t.lastChild)
        }

        function u(t) {
            t.parentNode && t.parentNode.removeChild(t)
        }

        function d(t, e, i) {
            e = e || [], i = i || [];
            for (var s = t.className.split(/\s+/), n = 0; n < e.length; n += 1) {
                for (var r = !1, o = 0; o < s.length; o += 1)
                    if (e[n] === s[o]) {
                        r = !0;
                        break
                    } r || s.push(e[n])
            }
            for (e = [], n = 0; n < s.length; n += 1) {
                for (r = !1, o = 0; o < i.length; o += 1)
                    if (s[n] === i[o]) {
                        r = !0;
                        break
                    } r || e.push(s[n])
            }
            t.className = e.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "")
        }

        function p(t, e) {
            for (var i = t.className.split(/\s+/), s = 0, n = i.length; s < n; s++)
                if (i[s] == e) return !0;
            return !1
        }

        function f(t, e, i) {
            function s() {
                a && n && r && (a(o), a = null)
            }
            e = l(t, "link", {
                rel: "stylesheet",
                href: e,
                media: "all"
            });
            var n = !1,
                r = !0,
                o = null,
                a = i || null;
            h ? (e.onload = function() {
                n = !0, s()
            }, e.onerror = function() {
                n = !0, o = Error("Stylesheet failed to load"), s()
            }) : setTimeout(function() {
                n = !0, s()
            }, 0), c(t, "head", e)
        }

        function g(t, e, i, s) {
            var n = t.c.getElementsByTagName("head")[0];
            if (n) {
                var r = l(t, "script", {
                        src: e
                    }),
                    o = !1;
                return r.onload = r.onreadystatechange = function() {
                    o || this.readyState && "loaded" != this.readyState && "complete" != this.readyState || (o = !0, i && i(null), r.onload = r.onreadystatechange = null, "HEAD" == r.parentNode.tagName && n.removeChild(r))
                }, n.appendChild(r), setTimeout(function() {
                    o || (o = !0, i && i(Error("Script load timeout")))
                }, s || 5e3), r
            }
            return null
        }

        function m() {
            this.a = 0, this.c = null
        }

        function y(t) {
            return t.a++,
                function() {
                    t.a--, x(t)
                }
        }

        function v(t, e) {
            t.c = e, x(t)
        }

        function x(t) {
            0 == t.a && t.c && (t.c(), t.c = null)
        }

        function b(t) {
            this.a = t || "-"
        }

        function _(t, e) {
            this.c = t, this.f = 4, this.a = "n";
            var i = (e || "n4").match(/^([nio])([1-9])$/i);
            i && (this.a = i[1], this.f = parseInt(i[2], 10))
        }

        function T(t) {
            var e = [];
            t = t.split(/,\s*/);
            for (var i = 0; i < t.length; i++) {
                var s = t[i].replace(/['"]/g, ""); - 1 != s.indexOf(" ") || /^\d/.test(s) ? e.push("'" + s + "'") : e.push(s)
            }
            return e.join(",")
        }

        function w(t) {
            return t.a + t.f
        }

        function S(t) {
            var e = "normal";
            return "o" === t.a ? e = "oblique" : "i" === t.a && (e = "italic"), e
        }

        function C(t) {
            if (t.g) {
                var e = p(t.f, t.a.c("wf", "active")),
                    i = [],
                    s = [t.a.c("wf", "loading")];
                e || i.push(t.a.c("wf", "inactive")), d(t.f, i, s)
            }
            E(t, "inactive")
        }

        function E(t, e, i) {
            t.j && t.h[e] && (i ? t.h[e](i.c, w(i)) : t.h[e]())
        }

        function P(t, e) {
            this.c = t, this.f = e, this.a = l(this.c, "span", {
                "aria-hidden": "true"
            }, this.f)
        }

        function A(t) {
            c(t.c, "body", t.a)
        }

        function M(t) {
            return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + T(t.c) + ";font-style:" + S(t) + ";font-weight:" + t.f + "00;"
        }

        function k(t, e, i, s, n, r) {
            this.g = t, this.j = e, this.a = s, this.c = i, this.f = n || 3e3, this.h = r || void 0
        }

        function R(t, e, i, s, n, r, o) {
            this.v = t, this.B = e, this.c = i, this.a = s, this.s = o || "BESbswy", this.f = {}, this.w = n || 3e3, this.u = r || null, this.m = this.j = this.h = this.g = null, this.g = new P(this.c, this.s), this.h = new P(this.c, this.s), this.j = new P(this.c, this.s), this.m = new P(this.c, this.s), t = M(t = new _(this.a.c + ",serif", w(this.a))), this.g.a.style.cssText = t, t = M(t = new _(this.a.c + ",sans-serif", w(this.a))), this.h.a.style.cssText = t, t = M(t = new _("serif", w(this.a))), this.j.a.style.cssText = t, t = M(t = new _("sans-serif", w(this.a))), this.m.a.style.cssText = t, A(this.g), A(this.h), A(this.j), A(this.m)
        }
        b.prototype.c = function(t) {
            for (var e = [], i = 0; i < arguments.length; i++) e.push(arguments[i].replace(/[\W_]+/g, "").toLowerCase());
            return e.join(this.a)
        }, k.prototype.start = function() {
            var t = this.c.o.document,
                e = this,
                i = a(),
                s = new Promise(function(s, n) {
                    ! function r() {
                        var o;
                        a() - i >= e.f ? n() : t.fonts.load((o = e.a, S(o) + " " + o.f + "00 300px " + T(o.c)), e.h).then(function(t) {
                            1 <= t.length ? s() : setTimeout(r, 25)
                        }, function() {
                            n()
                        })
                    }()
                }),
                n = null,
                r = new Promise(function(t, i) {
                    n = setTimeout(i, e.f)
                });
            Promise.race([r, s]).then(function() {
                n && (clearTimeout(n), n = null), e.g(e.a)
            }, function() {
                e.j(e.a)
            })
        };
        var O = {
                D: "serif",
                C: "sans-serif"
            },
            I = null;

        function L() {
            if (null === I) {
                var t = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
                I = !!t && (536 > parseInt(t[1], 10) || 536 === parseInt(t[1], 10) && 11 >= parseInt(t[2], 10))
            }
            return I
        }

        function B(t, e, i) {
            for (var s in O)
                if (O.hasOwnProperty(s) && e === t.f[O[s]] && i === t.f[O[s]]) return !0;
            return !1
        }

        function D(t) {
            var e, i = t.g.a.offsetWidth,
                s = t.h.a.offsetWidth;
            (e = i === t.f.serif && s === t.f["sans-serif"]) || (e = L() && B(t, i, s)), e ? a() - t.A >= t.w ? L() && B(t, i, s) && (null === t.u || t.u.hasOwnProperty(t.a.c)) ? F(t, t.v) : F(t, t.B) : setTimeout(o(function() {
                D(this)
            }, t), 50) : F(t, t.v)
        }

        function F(t, e) {
            setTimeout(o(function() {
                u(this.g.a), u(this.h.a), u(this.j.a), u(this.m.a), e(this.a)
            }, t), 0)
        }

        function U(t, e, i) {
            this.c = t, this.a = e, this.f = 0, this.m = this.j = !1, this.s = i
        }
        R.prototype.start = function() {
            this.f.serif = this.j.a.offsetWidth, this.f["sans-serif"] = this.m.a.offsetWidth, this.A = a(), D(this)
        };
        var N = null;

        function G(t) {
            0 == --t.f && t.j && (t.m ? ((t = t.a).g && d(t.f, [t.a.c("wf", "active")], [t.a.c("wf", "loading"), t.a.c("wf", "inactive")]), E(t, "active")) : C(t.a))
        }

        function j(t) {
            this.j = t, this.a = new function() {
                this.c = {}
            }, this.h = 0, this.f = this.g = !0
        }

        function X(t, e) {
            this.c = t, this.a = e
        }

        function W(t, e) {
            this.c = t, this.a = e
        }
        U.prototype.g = function(t) {
            var e = this.a;
            e.g && d(e.f, [e.a.c("wf", t.c, w(t).toString(), "active")], [e.a.c("wf", t.c, w(t).toString(), "loading"), e.a.c("wf", t.c, w(t).toString(), "inactive")]), E(e, "fontactive", t), this.m = !0, G(this)
        }, U.prototype.h = function(t) {
            var e = this.a;
            if (e.g) {
                var i = p(e.f, e.a.c("wf", t.c, w(t).toString(), "active")),
                    s = [],
                    n = [e.a.c("wf", t.c, w(t).toString(), "loading")];
                i || s.push(e.a.c("wf", t.c, w(t).toString(), "inactive")), d(e.f, s, n)
            }
            E(e, "fontinactive", t), G(this)
        }, j.prototype.load = function(t) {
            this.c = new function(t, e) {
                    this.a = t, this.o = e || t, this.c = this.o.document
                }(this.j, t.context || this.j), this.g = !1 !== t.events, this.f = !1 !== t.classes,
                function(t, e, i) {
                    var s = [],
                        n = i.timeout;
                    r = e, r.g && d(r.f, [r.a.c("wf", "loading")]), E(r, "loading");
                    var r;
                    var s = function(t, e, i) {
                            var s, n = [];
                            for (s in e)
                                if (e.hasOwnProperty(s)) {
                                    var r = t.c[s];
                                    r && n.push(r(e[s], i))
                                } return n
                        }(t.a, i, t.c),
                        a = new U(t.c, e, n);
                    for (t.h = s.length, e = 0, i = s.length; e < i; e++) s[e].load(function(e, i, s) {
                        var n, r, h, l, c, u;
                        r = a, h = e, l = i, c = s, u = 0 == --(n = t).h, (n.f || n.g) && setTimeout(function() {
                            var t = c || null,
                                e = l || {};
                            if (0 === h.length && u) C(r.a);
                            else {
                                r.f += h.length, u && (r.j = u);
                                var i, s = [];
                                for (i = 0; i < h.length; i++) {
                                    var n = h[i],
                                        a = e[n.c],
                                        p = r.a,
                                        f = n;
                                    if (p.g && d(p.f, [p.a.c("wf", f.c, w(f).toString(), "loading")]), E(p, "fontloading", f), p = null, null === N)
                                        if (window.FontFace) {
                                            var f = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),
                                                g = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
                                            N = f ? 42 < parseInt(f[1], 10) : !g
                                        } else N = !1;
                                    p = N ? new k(o(r.g, r), o(r.h, r), r.c, n, r.s, a) : new R(o(r.g, r), o(r.h, r), r.c, n, r.s, t, a), s.push(p)
                                }
                                for (i = 0; i < s.length; i++) s[i].start()
                            }
                        }, 0)
                    })
                }(this, new function(t, e) {
                    this.c = t, this.f = t.o.document.documentElement, this.h = e, this.a = new b("-"), this.j = !1 !== e.events, this.g = !1 !== e.classes
                }(this.c, t), t)
        }, X.prototype.load = function(t) {
            var e = this,
                i = e.a.projectId,
                s = e.a.version;
            if (i) {
                var n = e.c.o;
                g(this.c, (e.a.api || "https://fast.fonts.net/jsapi") + "/" + i + ".js" + (s ? "?v=" + s : ""), function(s) {
                    s ? t([]) : (n["__MonotypeConfiguration__" + i] = function() {
                        return e.a
                    }, function e() {
                        if (n["__mti_fntLst" + i]) {
                            var s, r = n["__mti_fntLst" + i](),
                                o = [];
                            if (r)
                                for (var a = 0; a < r.length; a++) {
                                    var h = r[a].fontfamily;
                                    void 0 != r[a].fontStyle && void 0 != r[a].fontWeight ? (s = r[a].fontStyle + r[a].fontWeight, o.push(new _(h, s))) : o.push(new _(h))
                                }
                            t(o)
                        } else setTimeout(function() {
                            e()
                        }, 50)
                    }())
                }).id = "__MonotypeAPIScript__" + i
            } else t([])
        }, W.prototype.load = function(t) {
            var e, i, s = this.a.urls || [],
                n = this.a.families || [],
                r = this.a.testStrings || {},
                o = new m;
            for (e = 0, i = s.length; e < i; e++) f(this.c, s[e], y(o));
            var a = [];
            for (e = 0, i = n.length; e < i; e++)
                if (s = n[e].split(":"), s[1])
                    for (var h = s[1].split(","), l = 0; l < h.length; l += 1) a.push(new _(s[0], h[l]));
                else a.push(new _(s[0]));
            v(o, function() {
                t(a, r)
            })
        };
        var H = "https://fonts.googleapis.com/css";
        var V = {
                latin: "BESbswy",
                "latin-ext": "",
                cyrillic: "",
                greek: "",
                khmer: "",
                Hanuman: ""
            },
            z = {
                thin: "1",
                extralight: "2",
                "extra-light": "2",
                ultralight: "2",
                "ultra-light": "2",
                light: "3",
                regular: "4",
                book: "4",
                medium: "5",
                "semi-bold": "6",
                semibold: "6",
                "demi-bold": "6",
                demibold: "6",
                bold: "7",
                "extra-bold": "8",
                extrabold: "8",
                "ultra-bold": "8",
                ultrabold: "8",
                black: "9",
                heavy: "9",
                l: "3",
                r: "4",
                b: "7"
            },
            Y = {
                i: "i",
                italic: "i",
                n: "n",
                normal: "n"
            },
            K = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;

        function q(t, e) {
            this.c = t, this.a = e
        }
        var J = {
            Arimo: !0,
            Cousine: !0,
            Tinos: !0
        };

        function Q(t, e) {
            this.c = t, this.a = e
        }

        function Z(t, e) {
            this.c = t, this.f = e, this.a = []
        }
        q.prototype.load = function(t) {
            var e = new m,
                i = this.c,
                s = new function(t, e) {
                    this.c = t || H, this.a = [], this.f = [], this.g = e || ""
                }(this.a.api, this.a.text),
                n = this.a.families;
            ! function(t, e) {
                for (var i = e.length, s = 0; s < i; s++) {
                    var n = e[s].split(":");
                    3 == n.length && t.f.push(n.pop());
                    var r = "";
                    2 == n.length && "" != n[1] && (r = ":"), t.a.push(n.join(r))
                }
            }(s, n);
            var r = new function(t) {
                this.f = t, this.a = [], this.c = {}
            }(n);
            ! function(t) {
                for (var e = t.f.length, i = 0; i < e; i++) {
                    var s = t.f[i].split(":"),
                        n = s[0].replace(/\+/g, " "),
                        r = ["n4"];
                    if (2 <= s.length) {
                        var o;
                        if (o = [], a = s[1])
                            for (var a = a.split(","), h = a.length, l = 0; l < h; l++) {
                                var c;
                                if ((c = a[l]).match(/^[\w-]+$/))
                                    if (null == (d = K.exec(c.toLowerCase()))) c = "";
                                    else {
                                        if (c = null == (c = d[2]) || "" == c ? "n" : Y[c], null == (d = d[1]) || "" == d) d = "4";
                                        else var u = z[d],
                                            d = u || (isNaN(d) ? "4" : d.substr(0, 1));
                                        c = [c, d].join("")
                                    }
                                else c = "";
                                c && o.push(c)
                            }
                        0 < o.length && (r = o), 3 == s.length && (o = [], 0 < (s = (s = s[2]) ? s.split(",") : o).length && (s = V[s[0]]) && (t.c[n] = s))
                    }
                    for (t.c[n] || (s = V[n]) && (t.c[n] = s), s = 0; s < r.length; s += 1) t.a.push(new _(n, r[s]))
                }
            }(r), f(i, function(t) {
                if (0 == t.a.length) throw Error("No fonts to load!");
                if (-1 != t.c.indexOf("kit=")) return t.c;
                for (var e = t.a.length, i = [], s = 0; s < e; s++) i.push(t.a[s].replace(/ /g, "+"));
                return e = t.c + "?family=" + i.join("%7C"), 0 < t.f.length && (e += "&subset=" + t.f.join(",")), 0 < t.g.length && (e += "&text=" + encodeURIComponent(t.g)), e
            }(s), y(e)), v(e, function() {
                t(r.a, r.c, J)
            })
        }, Q.prototype.load = function(t) {
            var e = this.a.id,
                i = this.c.o;
            e ? g(this.c, (this.a.api || "https://use.typekit.net") + "/" + e + ".js", function(e) {
                if (e) t([]);
                else if (i.Typekit && i.Typekit.config && i.Typekit.config.fn) {
                    e = i.Typekit.config.fn;
                    for (var s = [], n = 0; n < e.length; n += 2)
                        for (var r = e[n], o = e[n + 1], a = 0; a < o.length; a++) s.push(new _(r, o[a]));
                    try {
                        i.Typekit.load({
                            events: !1,
                            classes: !1,
                            async: !0
                        })
                    } catch (t) {}
                    t(s)
                }
            }, 2e3) : t([])
        }, Z.prototype.load = function(t) {
            var e, i = this.f.id,
                s = this.c.o,
                n = this;
            i ? (s.__webfontfontdeckmodule__ || (s.__webfontfontdeckmodule__ = {}), s.__webfontfontdeckmodule__[i] = function(e, i) {
                for (var s = 0, r = i.fonts.length; s < r; ++s) {
                    var o = i.fonts[s];
                    n.a.push(new _(o.name, (a = "font-weight:" + o.weight + ";font-style:" + o.style, h = void 0, l = void 0, c = void 0, h = 4, l = "n", c = null, a && ((c = a.match(/(normal|oblique|italic)/i)) && c[1] && (l = c[1].substr(0, 1).toLowerCase()), (c = a.match(/([1-9]00|normal|bold)/i)) && c[1] && (/bold/i.test(c[1]) ? h = 7 : /[1-9]00/.test(c[1]) && (h = parseInt(c[1].substr(0, 1), 10)))), l + h)))
                }
                var a, h, l, c;
                t(n.a)
            }, g(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + ((e = this.c).o.location.hostname || e.a.location.hostname) + "/" + i + ".js", function(e) {
                e && t([])
            })) : t([])
        };
        var $ = new j(window);
        $.a.c.custom = function(t, e) {
            return new W(e, t)
        }, $.a.c.fontdeck = function(t, e) {
            return new Z(e, t)
        }, $.a.c.monotype = function(t, e) {
            return new X(e, t)
        }, $.a.c.typekit = function(t, e) {
            return new Q(e, t)
        }, $.a.c.google = function(t, e) {
            return new q(e, t)
        };
        var tt = {
            load: o($.load, $)
        };
        void 0 === (s = function() {
            return tt
        }.call(e, i, e, t)) || (t.exports = s)
    }()
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = i(0),
        o = function(t) {
            function e() {
                return null !== t && t.apply(this, arguments) || this
            }
            return n(e, t), e.prototype.preload = function() {
                this.game.load.image(r.Images.ImagesPreloadTitle.getName(), r.Images.ImagesPreloadTitle.getPNG()), this.game.load.image(r.Images.ImagesFrame.getName(), r.Images.ImagesFrame.getPNG()), this.game.load.image(r.Images.ImagesPreloadPlayBtn.getName(), r.Images.ImagesPreloadPlayBtn.getPNG()), this.game.load.image(r.Images.ImagesSkyGradient1.getName(), r.Images.ImagesSkyGradient1.getPNG()), this.game.load.image(r.Images.ImagesRect16.getName(), r.Images.ImagesRect16.getPNG())
            }, e.prototype.create = function() {
                this.input.maxPointers = 1, this.game.device.android ? SYSTEM_FONT = "Droid Sans" : (this.game.device.iOS || this.game.device.macOS) && (SYSTEM_FONT = "Gill Sans"), this.game.scale.pageAlignHorizontally = !0, this.game.scale.pageAlignVertically = !0, this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL, this.game.scale.pageAlignHorizontally = !0, this.game.scale.pageAlignVertically = !0, this.game.scale.refresh(), GLOBAL_GAME = this.game;
                var t = window.innerHeight / window.innerWidth;
                t > 2.16 && (t = 2.16), t < 1.3 && (t = 1.3), t > 2 && (SAFE_TOP = 15, SAFE_SIDE = 15);
                var e = 620;
                t < 1.4 && (e *= t), EDITOR_MODE ? this.game.scale.setGameSize(1400, 800) : this.game.scale.setGameSize(e, Math.max(1e3, e * t)), this.game.scale.refresh(), console.log("DEBUG....................... false\n           \nSCALE_MODE.................. USER_SCALE\n           \nDEFAULT_GAME_WIDTH.......... 800\n           \nDEFAULT_GAME_HEIGHT......... 500\n           \nMAX_GAME_WIDTH.............. 888\n           \nMAX_GAME_HEIGHT............. 600\n           \ngame.width.................. " + this.game.width + "\n           \ngame.height................. " + this.game.height + "\n           \nGOOGLE_WEB_FONTS............ " + [] + "\n           \nSOUND_EXTENSIONS_PREFERENCE. " + ["webm", "ogg", "m4a", "mp3", "aac", "ac3", "caf", "flac", "mp4", "wav"]), this.game.state.start("preloader")
            }, e
        }(Phaser.State);
    e.default = o
}, function(t, e, i) {
    t.exports = i.p + "assets/2b7a9f4e73baaa5ca0531483fe7496d6.png"
}, function(t, e, i) {
    t.exports = i.p + "assets/e48b97ec574d9e63e152c22faafd7d74.png"
}, function(t, e, i) {
    t.exports = i.p + "assets/ac7159d9fff18655731c1cb1de0cf4f8.png"
}, function(t, e, i) {
    t.exports = i.p + "assets/bedeca5845110f9d49999f4a1e7472e1.png"
}, function(t, e, i) {
    t.exports = i.p + "assets/05007bee07ad9dcf4574910cfe0e0d86.png"
}, function(t, e, i) {
    t.exports = i.p + "assets/67258da2091afd1430b5248d9c9cf3d4.png"
}, function(t, e, i) {
    t.exports = i.p + "assets/9f5169271257bdc8f884b5371b82dbfd.png"
}, function(t, e, i) {
    t.exports = i.p + "assets/aec203295d700aff3e37419f37f3a15c.json"
}, function(t, e, i) {
    t.exports = i.p + "assets/b70e9021406a7db38a44234f4b5e1790.png"
}, function(t, e, i) {
    t.exports = i.p + "assets/44bff17c3c4b8efb7fc9c1ff50b273b1.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/1db824c92d67c095e4eb75aebd252f5e.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/778639b075d5416f8884b5c2eefdf3f2.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/74e0722b75a0f3d642c01bd79e2f421f.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/a14c2fbb17fe540113b32ed79543a10e.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/897689ba085bf971f27c905d982a8292.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/05ff3812881d39c523a460bc8e8cb917.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/0fc868066017a13eaa97dbb0a36887d7.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/02b95043840eda0882d65c3d41fd05bc.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/6ce0e517dea6e63569b520a3e1db512a.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/4b23ffa2c9d7e2759dbea457bd23b7ce.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/3ad0717f8bd92a745617841051119807.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/af2020c850d3bfe95aa768a084ba11bb.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/a60a6cc0ea2b9dec475d8775bf3088f0.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/097bfefdb1249d6be91e329fba57a56a.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/8d0e4429353b46e362f053150df4cac6.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/06987bb2a4961dfd5a14a3c1557b6020.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/7dcaac998854ac5cd05624296a3c17c5.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/92f6a7eee1c7c367df1f75627031a8e1.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/c3f38be273ec0f5d2a92dcc17338b4e4.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/49a39be3d24abd8ca76e917992ee8c6f.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/0694a6cf8ed80bf2fcb242e70bd49e61.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/644c24628af310a2166328e7e8b69f72.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/0f6a2df9d754b6221754fe94b9d82b68.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/f715b0675e4306f2e408787be6bab27e.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/15637da2c1100e827d18e7d370583c2e.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/908673f2dbca2c2120cb06b6cd10b517.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/4fb196a9ef751e3f13998ad22ecae325.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/a97f7608e1d36e9d67dca2524b187443.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/e90f2445970b2e1624cc2d5611f1fdb0.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/66564b9abca5afc1c72d3943e535d767.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/7a492ac575b3a42603b98e8da2b972ba.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/4fff3f95bd5c8a083ce34582270f2cb1.mp3"
}, function(t, e, i) {
    t.exports = i.p + "assets/e1bb5dfc89db37921ae93acccec8da6f.ogg"
}, function(t, e, i) {
    t.exports = i.p + "assets/ed7e917edb6b196123396c8d3a3cecab.json"
}, function(t, e, i) {
    t.exports = i.p + "assets/cdf6681c251a0bb0e6027747ee1c6aa9.json"
}, function(t, e, i) {
    t.exports = i.p + "assets/7cb68446bd1dd6201337c51a0c3b1d13.json"
}, function(t, e, i) {
    t.exports = i.p + "assets/f43dab0e42410f1dd591e36d7e855afe.xml"
}, function(t, e, i) {
    t.exports = i.p + "assets/779f4861be29c17adc5183c3ef61659b.js"
}, function(t, e, i) {
    t.exports = i.p + "assets/7e44068dd65b1e3f82dec52f780163c8.js"
}, function(t, e, i) {
    t.exports = i.p + "assets/e5894f2f22663c24c32de30d7d97f184.js"
}, function(t, e, i) {
    t.exports = i.p + "assets/1cdb51ec2f59b803cdcda4ded3c188f8.js"
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = i(0),
        o = i(82),
        a = i(6),
        h = i(4);
    i(2);
    var l = i(14),
        c = function(t) {
            function e() {
                var e = null !== t && t.apply(this, arguments) || this;
                return e.preloadBarSprite = null, e.preloadFrameSprite = null, e
            }
            return n(e, t), e.prototype.preload = function() {
                this.game.stage.setBackgroundColor(58623);
                var t = this.game.add.sprite(0, 0, r.Images.ImagesSkyGradient1.getName());
                t.width = this.game.width, t.height = this.game.height, this.title = this.game.add.sprite(this.game.world.centerX, this.game.world.centerY - 30, r.Images.ImagesPreloadTitle.getName()), this.title.anchor.set(.5), this.frame = this.game.add.sprite(this.game.world.centerX, this.game.world.centerY + 50, r.Images.ImagesFrame.getName()), this.frame.anchor.set(.5), this.bar = this.game.add.sprite(this.game.world.centerX - this.frame.width / 2 + 6, this.game.world.centerY + 31, r.Images.ImagesRect16.getName()), this.bar.width = this.frame.width - 12, this.bar.height = this.frame.height - 11, this.bar.tint = 16402220, this.titlePlayBtn = this.game.add.sprite(this.game.world.centerX, this.game.world.centerY + 800, r.Images.ImagesPreloadPlayBtn.getName()), this.titlePlayBtn.anchor.set(.5), this.titlePlayBtn.scale.set(.9), this.titlePlayBtn.visible = !1, o.Loader.loadAllAssets(this.game, this.waitForSoundDecoding, this), this.game.load.onFileComplete.add(this.fileComplete, this)
            }, e.prototype.fileComplete = function(t, e, i, s, n) {
                this.bar.width = (this.frame.width - 12) * s / n
            }, e.prototype.waitForSoundDecoding = function() {
                o.Loader.waitForSoundDecoding(this.setUpSounds, this)
            }, e.prototype.startSoon = function() {
                var t = this;
                this.game.load.onFileComplete.remove(this.fileComplete, this), this.titlePlayBtn.visible = !0, this.titlePlayBtn.inputEnabled = !0, TweenLite.to(this.frame, .6, {
                    delay: 0,
                    alpha: 0
                }), TweenLite.to(this.bar, .6, {
                    delay: 0,
                    alpha: 0
                }), this.titlePlayBtn.events.onInputDown.addOnce(function() {
                    return t.startGame()
                }), this.game.add.tween(this.titlePlayBtn).to({
                    y: this.game.world.centerY
                }, 400, Phaser.Easing.Circular.Out, !0, 400, 0), this.game.add.tween(this.titlePlayBtn.scale).to({
                    x: .85,
                    y: .85
                }, 500, Phaser.Easing.Circular.Out, !0, 0, -1, !0), TweenLite.to(this.title, .4, {
                    delay: 0,
                    y: this.game.world.centerY - 180,
                    ease: Sine.easeInOut
                })
            }, e.prototype.startGame = function() {
                var t = this;
                if ("undefined" != typeof gdsdk && "undefined" !== gdsdk.showAd && gdsdk.showAd(), gdsdk) {
                    window.GD_OPTIONS || (window.GD_OPTIONS = {
                        gameId: "7c55e325cfa441e08416e610253e02c3",
                        onEvent: function(t) {
                            switch (t.name) {
                                case "SDK_GAME_START":
                                    GLOBAL_GAME.paused = !1;
                                    break;
                                case "SDK_GAME_PAUSE":
                                    GLOBAL_GAME.paused = !0
                            }
                        }
                    }), this.titlePlayBtn.visible = !1;
                    ISCONTEXT = !1;
                    var e = new URL(window.location.href);
                    e.searchParams.get("levelset") && (LEVEL_SET = e.searchParams.get("levelset")), "B" == LEVEL_SET ? LEVELS = this.game.cache.getJSON(r.JSON.Levels2.getName()).levels : LEVELS = this.game.cache.getJSON(r.JSON.Levels.getName()).levels, h.default.Instance.init(this.game.cache.getJSON(r.JSON.Locale.getName()), this.game);
                    var i = window.navigator.userLanguage || window.navigator.language,
                        s = i.toLowerCase(),
                        n = "EN";
                    n = "zh-tw" === s || s.indexOf("zh-hant") >= 0 || "zh-hk" === s ? "ZT" : i.substr(0, 2).toUpperCase(), h.default.Instance.language = n, e.searchParams.get("lang") && (h.default.Instance.language = e.searchParams.get("lang")), l.PhaserUtils.AddBitmapFontAddMethod(), this.game.cache.addBitmapFontFromImage("desyrel", null, r.Atlases.SpritesheetsMain.getName(), this.cache.getXML("desyrel"), "xml"), TIME_SINCE_LAST_SESSION = 0, setTimeout(function() {
                        t.loadTitle()
                    }, 500)
                } else console.error("NO GD SDK FOUND")
            }, e.prototype.setUpSounds = function() {
                a.default.Instance.init(this.game), a.default.Instance.add(FxEvent.SCORE, r.Audio.SoundsGoal.getName(), .5), a.default.Instance.add(FxEvent.GAME_OVER, r.Audio.SoundsDie.getName(), .7), a.default.Instance.add(FxEvent.SHOOT_ROPE, r.Audio.SoundsSwisch1.getName(), .5, 0, 3), a.default.Instance.add(FxEvent.PRESS_BUTTON, r.Audio.SoundsButton.getName(), .7), a.default.Instance.add(FxEvent.PRESS_BUTTON_RESTART, r.Audio.SoundsRestart.getName(), 1), a.default.Instance.add(FxEvent.HANGER_HURT, r.Audio.SoundsSplat.getName(), .6), a.default.Instance.add(FxEvent.DROP_ROPE, r.Audio.SoundsSwischBack.getName(), .5), a.default.Instance.add(FxEvent.TITLE_SCREEN_SHOW, r.Audio.SoundsHanger.getName(), .3), a.default.Instance.add(FxEvent.HIGHSCORE, r.Audio.SoundsHighscore.getName(), .5), a.default.Instance.add(FxEvent.COIN, r.Audio.SoundsCoin.getName(), .3), a.default.Instance.add(FxEvent.NOT_ENOUGH, r.Audio.SoundsError.getName(), .5), a.default.Instance.add(FxEvent.BUY_SKIN, r.Audio.SoundsBuyskin.getName(), .4), a.default.Instance.add(FxEvent.SPRING, r.Audio.SoundsSpring.getName(), .4), a.default.Instance.add(FxEvent.COINS_REWARD, r.Audio.SoundsCoinsReward.getName(), 1), a.default.Instance.add(FxEvent.CONFETTI, r.Audio.SoundsConfetti.getName(), .6), this.startSoon()
            }, e.prototype.loadTitle = function() {
                this.game.state.start("title")
            }, e
        }(Phaser.State);
    e.default = c
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s = i(0),
        n = function() {
            function t() {}
            return t.loadImages = function() {
                for (var t in s.Images)
                    if (!this.game.cache.checkImageKey(s.Images[t].getName()))
                        for (var e = 0, i = Object.getOwnPropertyNames(s.Images[t]); e < i.length; e++) {
                            var n = i[e];
                            "getName" !== n && -1 != n.indexOf("get") && this.game.load.image(s.Images[t].getName(), s.Images[t][n]())
                        }
            }, t.loadSpritesheets = function() {
                for (var t in s.Spritesheets)
                    if (!this.game.cache.checkImageKey(s.Spritesheets[t].getName())) {
                        for (var e = null, i = 0, n = Object.getOwnPropertyNames(s.Spritesheets[t]); i < n.length; i++) {
                            var r = n[i];
                            "getName" !== r && "getFrameWidth" !== r && "getFrameHeight" !== r && "getFrameMax" !== r && "getMargin" !== r && "getSpacing" !== r && -1 != r.indexOf("get") && (e = r)
                        }
                        this.game.load.spritesheet(s.Spritesheets[t].getName(), s.Spritesheets[t][e](), s.Spritesheets[t].getFrameWidth(), s.Spritesheets[t].getFrameHeight(), s.Spritesheets[t].getFrameMax(), s.Spritesheets[t].getMargin(), s.Spritesheets[t].getSpacing())
                    }
            }, t.loadAtlases = function() {
                for (var t in s.Atlases)
                    if (!this.game.cache.checkImageKey(s.Atlases[t].getName())) {
                        for (var e = null, i = null, n = 0, r = Object.getOwnPropertyNames(s.Atlases[t]); n < r.length; n++) {
                            var o = r[n];
                            "getXML" !== o && "getJSONArray" !== o && "getJSONHash" !== o || -1 == o.indexOf("get") ? "getName" !== o && "Frames" !== o && -1 != o.indexOf("get") && (e = o) : i = o
                        }
                        "getXML" === i ? this.game.load.atlasXML(s.Atlases[t].getName(), s.Atlases[t][e](), s.Atlases[t].getXML()) : "getJSONArray" === i ? this.game.load.atlasJSONArray(s.Atlases[t].getName(), s.Atlases[t][e](), s.Atlases[t].getJSONArray()) : "getJSONHash" === i && this.game.load.atlasJSONHash(s.Atlases[t].getName(), s.Atlases[t][e](), s.Atlases[t].getJSONHash())
                    }
            }, t.orderAudioSourceArrayBasedOnSoundExtensionPreference = function(t) {
                var e = this,
                    i = [];
                for (var s in this.soundExtensionsPreference) {
                    var n = t.filter(function(t) {
                        return t.substring(t.lastIndexOf(".") + 1, t.length) === e.soundExtensionsPreference[s]
                    });
                    i = i.concat(n)
                }
                return i
            }, t.loadAudio = function() {
                for (var t in s.Audio) {
                    var e = s.Audio[t].getName();
                    if (this.soundKeys.push(e), !this.game.cache.checkSoundKey(e)) {
                        for (var i = [], n = 0, r = Object.getOwnPropertyNames(s.Audio[t]); n < r.length; n++) {
                            var o = r[n];
                            "getName" !== o && -1 != o.indexOf("get") && i.push(s.Audio[t][o]())
                        }
                        i = this.orderAudioSourceArrayBasedOnSoundExtensionPreference(i), this.game.load.audio(e, i, !0)
                    }
                }
            }, t.loadAudiosprites = function() {
                for (var t in s.Audiosprites) {
                    var e = s.Audiosprites[t].getName();
                    if (this.soundKeys.push(e), !this.game.cache.checkSoundKey(e)) {
                        for (var i = [], n = 0, r = Object.getOwnPropertyNames(s.Audiosprites[t]); n < r.length; n++) {
                            var o = r[n];
                            "getName" !== o && "getJSON" !== o && "Sprites" !== o && -1 != o.indexOf("get") && i.push(s.Audiosprites[t][o]())
                        }
                        i = this.orderAudioSourceArrayBasedOnSoundExtensionPreference(i), this.game.load.audiosprite(e, i, s.Audiosprites[t].getJSON(), null, !0)
                    }
                }
            }, t.loadBitmapFonts = function() {
                for (var t in s.BitmapFonts)
                    if (!this.game.cache.checkBitmapFontKey(s.BitmapFonts[t].getName())) {
                        for (var e = null, i = null, n = 0, r = Object.getOwnPropertyNames(s.BitmapFonts[t]); n < r.length; n++) {
                            var o = r[n];
                            "getXML" !== o && "getFNT" !== o || -1 == o.indexOf("get") ? "getName" !== o && -1 != o.indexOf("get") && (e = o) : i = o
                        }
                        this.game.load.bitmapFont(s.BitmapFonts[t].getName(), s.BitmapFonts[t][e](), s.BitmapFonts[t][i]())
                    }
            }, t.loadJSON = function() {
                for (var t in s.JSON) this.game.cache.checkJSONKey(s.JSON[t].getName()) || this.game.load.json(s.JSON[t].getName(), s.JSON[t].getJSON(), !0)
            }, t.loadXML = function() {
                for (var t in s.XML) this.game.cache.checkXMLKey(s.XML[t].getName()) || this.game.load.xml(s.XML[t].getName(), s.XML[t].getXML(), !0)
            }, t.loadText = function() {
                for (var t in s.Text) this.game.cache.checkTextKey(s.Text[t].getName()) || this.game.load.text(s.Text[t].getName(), s.Text[t].getTXT(), !0)
            }, t.loadScripts = function() {
                for (var t in s.Scripts) this.game.load.script(s.Scripts[t].getName(), s.Scripts[t].getJS())
            }, t.loadShaders = function() {
                for (var t in s.Shaders) this.game.cache.checkShaderKey(s.Shaders[t].getName()) || this.game.load.shader(s.Shaders[t].getName(), s.Shaders[t].getFRAG(), !0)
            }, t.loadMisc = function() {
                for (var t in s.Misc) this.game.cache.checkBinaryKey(s.Misc[t].getName()) || this.game.load.binary(s.Misc[t].getName(), s.Misc[t].getFile())
            }, t.loadAllAssets = function(t, e, i) {
                this.game = t, e && this.game.load.onLoadComplete.addOnce(e, i), this.loadImages(), this.loadSpritesheets(), this.loadAtlases(), this.loadAudio(), this.loadAudiosprites(), this.loadBitmapFonts(), this.loadJSON(), this.loadXML(), this.loadText(), this.loadScripts(), this.loadShaders(), this.loadMisc(), 0 === this.game.load._fileList.length && this.game.load.onLoadComplete.dispatch()
            }, t.loadSoundsOnly = function(t, e, i) {
                this.game = t, console.log("LOAD AUDIO"), e && this.game.load.onLoadComplete.addOnce(e, i), this.loadAudio(), this.loadAudiosprites(), 0 === this.game.load._fileList.length && this.game.load.onLoadComplete.dispatch(), this.game.load.start()
            }, t.waitForSoundDecoding = function(t, e) {
                this.soundKeys.length > 0 ? this.game.sound.setDecodedCallback(this.soundKeys, t, e) : t.call(e)
            }, t.game = null, t.soundKeys = [], t.soundExtensionsPreference = ["webm", "ogg", "m4a", "mp3", "aac", "ac3", "caf", "flac", "mp4", "wav"], t
        }();
    e.Loader = n
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0),
        o = i(84),
        a = i(85),
        h = i(15);
    i(2);
    var l = i(6),
        c = i(14),
        u = i(3),
        d = i(10),
        p = function(t) {
            function e(e, i, s, n) {
                void 0 === i && (i = 1), void 0 === s && (s = 0), void 0 === n && (n = 0);
                var o = t.call(this, e) || this;
                o.hangTarget = null, o.hangerScale = 1, o.swingForce = .4, o.damageForce = 1.15, o.lastHitTime = 0, o.lastHitDangerousTime = 0, o.minRopeLength = 2, o.steer = 0, o.dead = !1, o.bloodDropCount = 0, o.maxBloodDrops = 12, o.bloodDropInterval = 220, o.lastBloodDropTime = 0, o.isHanging = !1, o.extraChances = 0, o.ropeSpeed = 1, o.ropeDamping = 10, o.ropeFrequency = 10, o.coinsTaken = 0, o.idleTimeCheck = 0, o.lastIdlePosition = 0, o.score = 0, o.startX = 0, o.isStartBoost = !1, o.isLocked = !1, o.stopped = !1, o.shield = 0, o.onFireTime = 0;
                var l = i;
                o.hangerScale = l, o.startX = s;
                o.idle = !1;
                return o.shirtColor = 16711680, o.pantsColor = 16711680, o.skinColor = 16711680, o.onFire = !1, o.bloodColor = 16711680, o.bloodCircles = [], o.createParts(i, s, n), o.hitEffectImage = o.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Hit), o.hitEffectImage.anchor.set(.5), o.hitEffectImage.alpha = 0, o.addChild(o.hitEffectImage), CANVAS_RENDERING || (o.ropeHitEffect = new a.default(o.game), o.addChild(o.ropeHitEffect), o.coinHitEffect = new h.default(o.game, 6, 2 * Math.PI, 0, 0, !1, 16775979), o.addChild(o.coinHitEffect)), o.adjustedHangTargetPosition = new Phaser.Point(0, 0), o.adjustedRopeTargetPosition = new Phaser.Point(0, 0), o.resetSlowMotion(), o.idleTimeCheck = o.game.time.time, o
            }
            return n(e, t), e.prototype.createParts = function(t, e, i) {
                void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === i && (i = 0);
                var s = t,
                    n = this.skinColor,
                    a = this.pantsColor,
                    h = this.shirtColor;
                this.head = this.createCircle(20 * s, n), this.head.body.x = e, this.head.body.y = i - 22, this.torsoA = this.createImageRect(30 * s, 20 * s, r.Atlases.SpritesheetsMain.Frames.Torso1, h), this.torsoA.body.x = e, this.torsoA.body.y = i + 28 * s, this.torsoB = this.createImageRect(30 * s, 20 * s, r.Atlases.SpritesheetsMain.Frames.Torso1, h), this.torsoB.body.x = e, this.torsoB.body.y = i + 43 * s, this.torsoC = this.createImageRect(30 * s, 20 * s, r.Atlases.SpritesheetsMain.Frames.Torso1, h), this.torsoC.body.x = e, this.torsoC.body.y = i + 58 * s, this.leftLegA = this.createRect(15 * s, 44 * s, a), this.leftLegA.body.x = e - 8 * s, this.leftLegA.body.y = i + 85 * s, this.leftLegB = this.createRect(12 * s, 40 * s, a), this.leftLegB.body.x = e - 8 * s, this.leftLegB.body.y = i + 120 * s, this.rightLegA = this.createRect(15 * s, 44 * s, a), this.rightLegA.body.x = e + 8 * s, this.rightLegA.body.y = i + 85 * s, this.rightLegB = this.createRect(12 * s, 40 * s, a), this.rightLegB.body.x = e + 8 * s, this.rightLegB.body.y = i + 120 * s, this.lowerArmL = this.createRect(30 * s, 12 * s, n), this.lowerArmL.body.x = e - 57 * s, this.lowerArmL.body.y = i + 20 * s, this.leftArmB = this.createImageRect(36 * s, 12 * s, r.Atlases.SpritesheetsMain.Frames.Arm, h), this.leftArmB.body.x = e - 30 * s, this.leftArmB.body.y = i + 20 * s, this.rightArmA = this.createRect(36 * s, 12 * s, n), this.rightArmA.body.x = e + 57 * s, this.rightArmA.body.y = i + 20 * s, this.rightArmB = this.createImageRect(36 * s, 12 * s, r.Atlases.SpritesheetsMain.Frames.Arm, h), this.rightArmB.body.x = e + 30 * s, this.rightArmB.body.y = i + 20 * s, this.addJoint(this.head, this.torsoA, 0, 18 * s, 0, -10 * s, -40, 40), this.addJoint(this.torsoA, this.torsoB, 0, 6 * s, 0, -6 * s, -13, 15), this.addJoint(this.torsoB, this.torsoC, 0, 6 * s, 0, -6 * s, -13, 15), this.addJoint(this.torsoC, this.leftLegA, -8 * s, 6 * s, 0, -18 * s, -25, 45), this.addJoint(this.torsoC, this.rightLegA, 8 * s, 6 * s, 0, -18 * s, -45, 25), this.addJoint(this.leftLegA, this.leftLegB, 0, 20 * s, 0, -18 * s, -25, 115), this.addJoint(this.rightLegA, this.rightLegB, 0, 20 * s, 0, -18 * s, -115, 25), this.addJoint(this.torsoA, this.rightArmB, 11 * s, 0, -18 * s, 0, 60, -60), this.addJoint(this.torsoA, this.leftArmB, -11 * s, 0, 18 * s, 6 * s, -60, 60), this.addJoint(this.lowerArmL, this.leftArmB, 15 * s, 0, -12 * s, 0, -60, 60), this.addJoint(this.rightArmA, this.rightArmB, -15 * s, 0, 12 * s, 0, -60, 60), this.animatedHangTarget = this.createCircle(6, Colors.white, !1), this.addChild(this.animatedHangTarget), this.ropeRect = this.createRopeRect(100, 8, Colors.white, !1), SHADOWS && (this.ropeRect_shadow = c.PhaserUtils.createShadowSprite(this.game, this.ropeRect, "shadow_ropeRect"), this.addChild(this.ropeRect_shadow)), this.addChild(this.ropeRect), this.bodyparts = [], this.bodyparts.push(this.lowerArmL), this.bodyparts.push(this.head), this.bodyparts.push(this.torsoA), this.bodyparts.push(this.leftArmB), this.bodyparts.push(this.torsoB), this.bodyparts.push(this.torsoC), this.bodyparts.push(this.rightArmB), this.bodyparts.push(this.rightArmA), this.bodyparts.push(this.leftLegA), this.bodyparts.push(this.rightLegA), this.bodyparts.push(this.rightLegB), this.bodyparts.push(this.leftLegB), this.addChild(this.leftLegA), this.addChild(this.leftLegB), this.addChild(this.rightLegA), this.addChild(this.rightLegB), this.addChild(this.lowerArmL), this.addChild(this.leftArmB), this.addChild(this.rightArmA), this.addChild(this.rightArmB), this.addChild(this.torsoA), this.addChild(this.torsoB), this.addChild(this.torsoC), this.addChild(this.head), this.shadowParts = [];
                for (var l = 0, u = 0, d = this.bodyparts; u < d.length; u++) {
                    var p = d[u];
                    l++, p.body.bodypart = !0, p.body.linearDamping = .14, p.body.setCategoryPostsolveCallback(HangerCollisionGroups.level, this.collisionCallBack, this), p.body.setCategoryContactCallback(HangerCollisionGroups.enemy, this.dangerousObjectCollisionCallBack, this), p.body.setCategoryContactCallback(HangerCollisionGroups.coin, this.coinCallBack, this), p.body.setCollisionCategory(HangerCollisionGroups.hanger), SHADOWS && (p.shadow = c.PhaserUtils.createShadowSprite(this.game, p, p.key.toString() + l), this.addChild(p.shadow), p.shadow.bodypart = p, this.shadowParts.push(p.shadow), p.shadow.sendToBack(), 2 == l && p.shadow.scale.set(1.2))
                }
                this.ropeTarget = this.createCircle(2, 16711935, !1), this.ropeTarget.x = -8 * s, this.ropeTarget.y = 0, this.ropeTarget.alpha = 0, this.lowerArmL.addChild(this.ropeTarget), this.headGroup = new Phaser.Group(this.game), this.leftEye = new o.default(this.game, t, 0, 0), this.headGroup.addChild(this.leftEye), this.leftEye.x = -10, this.leftEye.y = -2.5, this.leftEye.scale.set(.65, .65), this.rightEye = new o.default(this.game, t, 0, 0), this.headGroup.addChild(this.rightEye), this.rightEye.x = 10, this.rightEye.y = -2.5, this.rightEye.scale.set(.65, .65), this.addChild(this.headGroup), this.bleedBody = this.leftLegB, 0 != OVERRIDE_COLORS.back && this.updateDebugShadow(), this.onFirePath && (this.add(this.onFirePath), this.sendToBack(this.onFirePath))
            }, e.prototype.destroyParts = function() {
                this.drop();
                for (var t = this.game.world.centerY, e = 0, i = this.bodyparts; e < i.length; e++) {
                    i[e].destroy()
                }
                for (var s = 0, n = this.shadowParts; s < n.length; s++) {
                    n[s].destroy()
                }
                this.ropeRect_shadow && this.ropeRect_shadow.destroy(), this.leftEye.destroy(), this.rightEye.destroy(), this.ropeRect.destroy(), this.animatedHangTarget.destroy(), this.createParts(this.hangerScale, this.startX + 300, t)
            }, e.prototype.setOnFire = function() {
                if (!this.onFire) {
                    this.onFire = !0, this.onFireTime = this.game.time.time, this.onFireHead || (this.onFireHead = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Fire), this.onFireHead.anchor.set(.5, 1), this.onFireHead.y = 25, this.headGroup.add(this.onFireHead)), this.onFireHead.visible = !0;
                    for (var t = 0; t < this.bodyparts.length; t++);
                }
            }, e.prototype.resetOnFire = function() {
                this.onFire = !1, TweenMax.killTweensOf(this.onFireHead.scale), this.onFirePath && this.onFirePath.stop(), this.onFireHead.visible = !1;
                SKINS[ACTIVE_SKIN];
                this.shield = 0
            }, e.prototype.copyPosition = function(t, e, i, s) {
                void 0 === i && (i = 0), void 0 === s && (s = 0), e.x = t.x + i, e.y = t.y + s, t.body && (e.x = e.x + .015 * t.body.velocity.x, e.y = e.y + .015 * t.body.velocity.y), e.rotation = t.rotation
            }, e.prototype.setTint = function(t, e, i, s) {
                this.leftArmB.tint = t, this.rightArmB.tint = t, this.lowerArmL.tint = i, this.rightArmA.tint = i, this.torsoA.tint = t, this.torsoB.tint = t, this.torsoC.tint = t, this.leftLegA.tint = e, this.leftLegB.tint = e, this.rightLegA.tint = e, this.rightLegB.tint = e, this.bloodColor = t, s ? (this.ropeRect.tint = s, this.animatedHangTarget.tint = s) : (this.ropeRect.tint = Colors.white, this.animatedHangTarget.tint = Colors.white);
                for (var n = 0; n < this.maxBloodDrops; n++) this.bloodCircles[n] && (this.bloodCircles[n].tint = this.bloodColor)
            }, e.prototype.startBoost = function() {
                var t = this;
                this.isLocked = !0, this.isStartBoost = !0;
                for (var e = 0; e < this.bodyparts.length; e++) this.bodyparts[e] != this.lowerArmL && (this.bodyparts[e].body.velocity.y = -300, this.bodyparts[e].body.velocity.x = 300);
                this.lowerArmL.body.applyForce(400, -300), this.slowMoAnim = 1, TweenMax.to(this, 1, {
                    delay: .3,
                    slowMoAnim: 4,
                    onUpdate: function() {
                        t.game && (t.game.time.slowMotion = t.slowMoAnim, t.game.time.desiredFps = 60 * t.slowMoAnim, t.game.physics.box2d.frameRate = 1 / 60 / t.slowMoAnim)
                    }
                })
            }, e.prototype.endStartBoost = function() {
                var t = this;
                this.isStartBoost = !1, this.isLocked = !1, TweenMax.killTweensOf(this), TweenMax.to(this, .4, {
                    delay: 0,
                    slowMoAnim: 1,
                    onUpdate: function() {
                        t.game && (t.game.time.slowMotion = t.slowMoAnim, t.game.time.desiredFps = 60 * t.slowMoAnim, t.game.physics.box2d.frameRate = 1 / 60 / t.slowMoAnim)
                    }
                })
            }, e.prototype.setSkin = function(t, e) {
                var i = this;
                void 0 === e && (e = !1);
                var s = SKINS[t];
                if (s) {
                    s && s.scale && this.hangerScale !== s.scale && (this.hangerScale = s.scale, this.destroyParts(), setTimeout(function() {
                        i.shoot(-50, 1)
                    }, 100)), null != s.damageForce ? this.damageForce = s.damageForce : this.damageForce = 1.15, this.damageForce = s.damageForce + .25 * STRENGTH_LEVEL, this.headSkin && this.headSkin.destroy();
                    var n = !1;
                    null != s && "skin_hanger" !== t && -1 == t.indexOf("skin_hanger") || (this.setTint(s.shirtColor, s.pantsColor, s.skinColor, s.ropeColor), this.game.stage.setBackgroundColor(58623), this.ropeDamping = 10, this.ropeFrequency = 10, this.ropeSpeed = 1, 1.9, n = !0), -1 != t.search("skin_hanger") ? (this.headSkin = new Phaser.Sprite(this.game, 0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Circle), this.headSkin.anchor.set(.5), this.headSkin.tint = s.skinColor) : (this.headSkin = new Phaser.Sprite(this.game, 0, 0, r.Atlases.SpritesheetsMain.getName(), t + ".png"), this.headSkin.anchor.set(.5)), this.headSkin.width = s.width * this.hangerScale * 1.9, this.headSkin.height = s.width * this.hangerScale * 1.9, SHADOWS && this.shadowParts && (this.shadowParts[1].width = this.headSkin.width, this.shadowParts[1].height = this.headSkin.height), this.headGroup.addChild(this.headSkin), this.headGroup.addChild(this.leftEye), this.headSkin.sendToBack(), this.head.visible = !1, 1 == s.noEyes ? (this.leftEye.visible = !1, this.rightEye.visible = !1) : (this.leftEye.visible = !0, this.rightEye.visible = !0), this.game.stage.setBackgroundColor(s.backColor), n || this.setTint(s.shirtColor, s.pantsColor, s.skinColor, s.ropeColor), !1 === e && (ACTIVE_SKIN = t), this.ropeDamping = s.ropeDamping, this.ropeFrequency = s.ropeFrequency, null != s.ropeDamping ? this.ropeDamping = s.ropeDamping : this.ropeDamping = 10, null != s.ropeFrequency ? this.ropeFrequency = s.ropeFrequency : this.ropeFrequency = 10, null != s.ropeSpeed ? this.ropeSpeed = s.ropeSpeed : this.ropeSpeed = 1
                }
            }, e.prototype.coinCallBack = function(t, e, i, s, n) {
                if (!0 === n) {
                    var r = null;
                    !0 === t.isSensor && (r = t), !0 === e.isSensor && (r = e), r && !1 === this.dead && !1 === r.taken && (this.coinHitEffect && (this.coinHitEffect.x = r.x, this.coinHitEffect.y = r.y, this.coinHitEffect.play()), r.y = 2e3, r.taken = !0, KEYS += 1, setTimeout(function() {
                        return r.y = 2e3
                    }, 10), l.default.Instance.fx(FxEvent.COIN))
                }
            }, e.prototype.collisionCallBack = function(t, e, i, s, n, r) {
                var o = this;
                !0 !== t.dead && !0 !== e.dead && (t.bodypart || e.bodypart) && (!1 === t.level && !1 === e.level || (!1 === t.level && (t.dead = !0), !1 === e.level && (e.dead = !0), t.isCrate || e.isCrate || this.bodyparts.length > 1 && r.count > 0 && (r.normalImpulses[0] > this.damageForce + this.shield || r.tangentImpulses[0] > this.damageForce + this.shield) && this.game.time.now - this.lastHitTime > 1e3 && (this.lastHitTime = this.game.time.now, this.lastHitTime = this.game.time.now, this.dropPart(this.bodyparts.pop()), setTimeout(function() {
                    o.game.camera && o.game.camera.flash(16711680, 120, !1, .7)
                }, 50), this.game.camera.shake(.015, 100), this.hitEffectImage.x = this.bodyparts[this.bodyparts.length - 1].body.x + 5, this.hitEffectImage.y = this.bodyparts[this.bodyparts.length - 1].body.y, this.hitEffect(.8), Math.random() > .2 + this.damageForce / 60 && this.dropPart(this.bodyparts.pop()), Math.random() > .45 + this.damageForce / 60 && this.dropPart(this.bodyparts.pop()))))
            }, e.prototype.slowMotion = function(t, e) {
                var i = this;
                this.game && (this.game.time.slowMotion = t, this.game.time.desiredFps = 60 * t, this.game.physics.box2d.frameRate = 1 / 60 / t, this.resetSlowMotionTimeout = setTimeout(function() {
                    return i.resetSlowMotion()
                }, e))
            }, e.prototype.hitEffect = function(t) {
                l.default.Instance.fx(FxEvent.HANGER_HURT), this.hitEffectImage.scale.x = .1, this.hitEffectImage.scale.y = .1, this.hitEffectImage.alpha = 0, this.hitEffectImage.angle = 360 * Math.random(), TweenLite.to(this.hitEffectImage.scale, .15, {
                    x: t,
                    y: t,
                    ease: Expo.easeOut
                }), TweenLite.to(this.hitEffectImage, .15, {
                    alpha: 1,
                    ease: Expo.easeOut,
                    delay: .05
                }), TweenLite.to(this.hitEffectImage.scale, .2, {
                    delay: .35,
                    x: .1,
                    y: .1
                }), TweenLite.to(this.hitEffectImage, .2, {
                    delay: .35,
                    alpha: 0
                }), u.default.Instance.impact()
            }, e.prototype.resetSlowMotion = function() {
                this.game.time.slowMotion = BASE_SPEED, this.game.time.desiredFps = 60, TweenMax.to(this.game.physics.box2d, .3, {
                    frameRate: 1 / 60
                })
            }, e.prototype.boostTowardsGoal = function() {
                for (var t = 0; t < this.bodyparts.length; t++) this.bodyparts[t].body.velocity.x < 200 && (this.bodyparts[t].body.velocity.x += 20, this.bodyparts[t].body.velocity.y -= 20)
            }, e.prototype.dangerousObjectCollisionCallBack = function(t, e, i, s, n) {
                var r = this;
                if (n && !t.dead && !e.dead)
                    if (t.isBoost || e.isBoost) {
                        var o = t;
                        e.isBoost && (o = e), o.initialVelocity || (o.initialVelocity = (.12 * this.lowerArmL.body.velocity.x + .12 * this.head.body.velocity.x) / 2);
                        var a = o.initialVelocity;
                        a < 15 && (a = 15);
                        var h = a;
                        h = o.goalBoost ? a + 18 * BOOSTER_LEVEL : a + 120;
                        for (var c = 0; c < this.bodyparts.length; c++) this.isHanging && this.drop(), this.bodyparts[c].body.velocity.x < 600 + 3.8 * h && (this.bodyparts[c].body.velocity.x = this.bodyparts[c].body.velocity.x + (10 + h) + .1), this.bodyparts[c].body.velocity.y > -(350 + 3.2 * a) && (this.bodyparts[c].body.velocity.y = this.bodyparts[c].body.velocity.y - (6 + .7 * a + .2));
                        o.goalBoost && this.lowerArmL.body.applyForce(5, -2)
                    } else {
                        var d;
                        if (t.isSpring || e.isSpring) {
                            if (t.isSpring && (d = t), e.isSpring && (d = e), d && !d.isHit) {
                                for (c = 0; c < this.bodyparts.length; c++) this.bodyparts[c].body.velocity.y = -800, this.bodyparts[c].body.velocity.x = 700;
                                d.isHit = !0, TweenLite.killTweensOf(d), TweenLite.from(d, .6, {
                                    y: d.y - 45,
                                    x: d.x + 25,
                                    ease: Elastic.easeOut,
                                    onComplete: function() {
                                        d.isHit = !1
                                    }
                                }), l.default.Instance.fx(FxEvent.SPRING), u.default.Instance.impact()
                            }
                        } else if (this.game.time.now - this.lastHitDangerousTime > 1200 && this.shield < 10) {
                            if (this.game.time.slowMotion = 4, TweenLite.to(this.game.time, .85, {
                                    slowMotion: BASE_SPEED
                                }), this.game.camera.shake(.02, 200), setTimeout(function() {
                                    return r.game.camera.flash(16711680, 150, !1, 1)
                                }, 50), this.hitEffectImage.x = this.bodyparts[this.bodyparts.length - 1].body.x + 5, this.hitEffectImage.y = this.bodyparts[this.bodyparts.length - 1].body.y, this.hitEffect(1.3), this.extraChances > 0) this.extraChances--;
                            else if (this.bodyparts.length > 8 && Math.random() > .7) {
                                for (var p = 0, f = this.bodyparts.slice(this.bodyparts.indexOf(this.torsoC) + 1); p < f.length; p++) {
                                    f[p].body.dead = !0
                                }
                                this.bodyparts = this.bodyparts.slice(0, this.bodyparts.indexOf(this.torsoC)), this.dropPart(this.torsoC)
                            } else this.dropPart(this.bodyparts.pop()), this.dropPart(this.bodyparts.pop()), this.dropPart(this.bodyparts.pop()), Math.random() > .3 && this.dropPart(this.bodyparts.pop()), Math.random() > .7 && this.dropPart(this.bodyparts.pop());
                            this.lastHitDangerousTime = this.game.time.now
                        }
                    }
            }, e.prototype.setUpJoints = function() {}, e.prototype.addJoint = function(t, e, i, s, n, r, o, a) {
                var h = this.game.physics.box2d.revoluteJoint(t, e, i, s, n, r, 0, 0, !1, o, a, !0);
                return null == t.jointA ? t.jointA = h : t.jointB = h, null == e.jointA ? e.jointA = h : e.jointB = h, h
            }, e.prototype.update = function() {
                var t = this.swingForce;
                this.steer = 0, !0 === this.isHanging ? (this.adjustedHangTargetPosition.x = this.animatedHangTarget.x + this.lowerArmL.body.velocity.x * this.game.time.elapsed / 1e3 * .6, this.adjustedHangTargetPosition.y = this.animatedHangTarget.y, this.adjustedRopeTargetPosition.x = this.ropeTarget.world.x + this.lowerArmL.body.velocity.x * this.game.time.elapsed / 1e3 * .6, this.adjustedRopeTargetPosition.y = this.ropeTarget.world.y, this.ropeRect.width = Phaser.Point.distance(this.adjustedHangTargetPosition, this.adjustedRopeTargetPosition), this.ropeRect.x = (this.adjustedHangTargetPosition.x + this.adjustedRopeTargetPosition.x) / 2, this.ropeRect.y = (this.adjustedHangTargetPosition.y + this.adjustedRopeTargetPosition.y) / 2, this.ropeRect.rotation = Phaser.Point.angle(this.adjustedHangTargetPosition, this.adjustedRopeTargetPosition), this.ropeRect.visible = !0, this.ropeRect.rotation = Phaser.Point.angle(this.adjustedHangTargetPosition, this.adjustedRopeTargetPosition), SHADOWS && (this.ropeRect_shadow.width = this.ropeRect.width + 5, this.ropeRect_shadow.visible = !0, this.copyPosition(this.ropeRect, this.ropeRect_shadow, -5, -4)), !0 === this.isHanging && this.ropeJoint.m_length > this.minRopeLength && (this.ropeJoint.m_length = this.ropeJoint.m_length - Math.min(.35 * this.ropeSpeed, this.ropeJoint.m_length / 70 * this.ropeSpeed)), this.animatedHangTarget.visible = !0, this.lowerArmL.body.x < this.hangTarget.x && this.lowerArmL.body.velocity.x < -1 && this.lowerArmL.body.velocity.x > -150 && (this.steer = -t), this.lowerArmL.body.x > this.hangTarget.x && this.lowerArmL.body.velocity.x > 1 && this.lowerArmL.body.velocity.x < 100 && (this.steer = t)) : (this.steer = t, this.animatedHangTarget.visible = !1, this.ropeRect.visible = !1, SHADOWS && (this.ropeRect_shadow.visible = !1)), 0 !== this.steer && this.lowerArmL.body.applyForce(this.steer, 0), this.bodyparts.length < 4 && (this.dead = !0), this.leftEye && (this.leftEye.updateLookDirection(this.lowerArmL.body.velocity.x, this.lowerArmL.body.velocity.y, this.head.angle), this.rightEye.updateFromEye(this.leftEye)), this.bodyparts.length < 12 && (this.bloodDropInterval = Math.max(200, 30 * this.bodyparts.length) / 1.2, this.game.time.now + (100 * Math.random() - 50) > this.lastBloodDropTime + this.bloodDropInterval && this.dropBlood()), this.lowerArmL.body.y > this.game.height + 20 && (this.isHanging && this.drop(), this.dead = !0), this.headGroup && (this.headGroup.position = this.head.position, this.headGroup.angle = this.head.angle);
                var e = !1;
                !1 === this.isHanging && this.game.time.time - this.idleTimeCheck > 7500 ? (e = !0, this.idle = !0) : this.idle = !1, this.onFire && (this.shield = 100, e = !0), e ? (this.sunglasses || (this.sunglasses = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Sunglasses), this.headGroup.addChild(this.sunglasses), this.sunglasses.x = -26, this.sunglasses.y = -10), this.sunglasses.visible = !0) : this.sunglasses && (this.sunglasses.visible = !1), this.shield > 0 && (this.shield = this.shield - .5);
                for (var i = 0, s = this.shadowParts; i < s.length; i++) {
                    var n = s[i];
                    this.copyPosition(n.bodypart, n, -5, -4)
                }
            }, e.prototype.getTorsoY = function() {
                return this.torsoA && this.torsoA.body ? this.torsoA.body.y : this.lowerArmL.body.y
            }, e.prototype.updateDebugShadow = function() {
                if (0 != OVERRIDE_COLORS.back) {
                    for (var t = 0, e = this.shadowParts; t < e.length; t++) {
                        e[t].tint = (8289918 & OVERRIDE_COLORS.back) >> 1 | 8421504 & OVERRIDE_COLORS.back
                    }
                    this.ropeRect_shadow.tint = (8289918 & OVERRIDE_COLORS.back) >> 1 | 8421504 & OVERRIDE_COLORS.back
                }
            }, e.prototype.render = function() {}, e.prototype.shoot = function(t, e) {
                if (void 0 === t && (t = 0), void 0 === e && (e = -1), !this.stopped) {
                    this.idleTimeCheck = this.game.time.time, this.isStartBoost && this.endStartBoost();
                    var i = 0;
                    "B" == LEVEL_SET ? (i = this.lowerArmL.x + 350 + t, this.lowerArmL.body.velocity.x > 0 && (i += this.lowerArmL.body.velocity.x / 6 + 200), null != d.default.currentLevel && this.lowerArmL.body.x > d.default.currentLevel.goal.x - 600 && (i = Math.min(i, this.lowerArmL.x + 75))) : (i = this.lowerArmL.x + 250 + t, this.lowerArmL.body.velocity.x > 0 && (i += this.lowerArmL.body.velocity.x / 5)), -1 != e && (i = e);
                    var s = this.game.physics.box2d.raycast(this.lowerArmL.x, this.lowerArmL.y, i, 0, !0, this.filterRaycastHit);
                    if (s.length > 0) {
                        var n = s[0];
                        n.point.y > 500 && Phaser.Point.distance(this.lowerArmL.position, n.point) < 130 && t > -1e3 ? this.shoot(t - 80) : (l.default.Instance.fx(FxEvent.SHOOT_ROPE), this.hang(n.point.x, n.point.y))
                    }
                    return -1
                }
            }, e.prototype.hang = function(t, e) {
                if (!this.stopped) {
                    this.hangTarget = this.createCircle(4, Colors.white), this.hangTarget.body.static = !0, this.hangTarget.body.x = t, this.hangTarget.body.y = e, this.hangTarget.visible = !1, TweenLite.killTweensOf(this.animatedHangTarget), this.animatedHangTarget.x = this.ropeTarget.world.x + this.lowerArmL.body.velocity.x / 70, this.animatedHangTarget.y = this.ropeTarget.world.y, TweenLite.to(this.animatedHangTarget, .15, {
                        ease: Power2.easeOut,
                        x: this.hangTarget.body.x,
                        y: this.hangTarget.body.y
                    }), this.addChild(this.hangTarget), null != this.ropeJoint && (this.game.physics.box2d.world.DestroyJoint(this.ropeJoint), this.ropeJoint = null), this.ropeJoint = this.game.physics.box2d.distanceJoint(this.lowerArmL, this.hangTarget, Phaser.Math.distance(this.lowerArmL.body.x, this.lowerArmL.body.y, t, e), -8 * this.hangerScale, 0, 0, 0, this.ropeFrequency, this.ropeDamping), this.isHanging = !0;
                    var i = this;
                    this.ropeHitEffect && (this.ropeHitEffect.x = t, this.ropeHitEffect.y = e, setTimeout(function() {
                        i.ropeHitEffect.play(), l.default.Instance.fx(FxEvent.HANG)
                    }, 100))
                }
            }, e.prototype.drop = function() {
                null != this.ropeJoint && (this.game.physics.box2d.world.DestroyJoint(this.ropeJoint), this.ropeJoint = null), null != this.hangTarget && (this.hangTarget.kill(), this.hangTarget.destroy(), this.hangTarget = null), l.default.Instance.fx(FxEvent.DROP_ROPE), this.isHanging = !1, this.idleTimeCheck = this.game.time.time
            }, e.prototype.dropPart = function(t) {
                var e = this;
                if (t) {
                    t.body.dead = !0;
                    var i = null;
                    t && (t.jointA ? (i = t.jointA, t.jointA = null) : t.jointB && (i = t.jointB, t.jointB = null)), i && setTimeout(function() {
                        e.destroyJointSoon(i)
                    }, 20), this.bleedBody = this.bodyparts[this.bodyparts.length - 1]
                }
            }, e.prototype.dropBlood = function() {
                var t;
                this.bleedBody && (this.bloodDropCount % this.maxBloodDrops >= this.bloodCircles.length ? ((t = this.createCircle(5, this.bloodColor, !0)).body.setCollisionCategory(HangerCollisionGroups.blood), t.body.setCollisionMask(HangerCollisionGroups.level), this.bloodCircles.push(t)) : t = this.bloodCircles[this.bloodDropCount % this.maxBloodDrops], this.addChild(t), this.sendToBack(t), t.scale.set((.5 * Math.random() + .25) / 1.8 * 3), t.body.x = this.bleedBody.body.x - 2, t.body.y = this.bleedBody.body.y + 10, t.body.restitution = .3, t.body.velocity.x = this.bleedBody.body.velocity.x / 3 + 150 * Math.random(), t.body.velocity.y = -50 * Math.random(), t.visible = !0, NO_BLOOD && (t.visible = !1), this.lastBloodDropTime = this.game.time.now, this.bloodDropCount++)
            }, e.prototype.destroyJointSoon = function(t) {
                t && this.game && this.game.physics && this.game.physics.box2d && this.game.physics.box2d.world && this.game.physics.box2d.world.DestroyJoint(t)
            }, e.prototype.debugRender = function() {}, e.prototype.createCircle = function(t, e, i) {
                var s;
                return void 0 === i && (i = !0), (s = t <= 100 ? this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Circle16) : this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Circle)).width = 2 * t, s.height = 2 * t, s.anchor.set(.5), !0 === i && (this.game.physics.box2d.enable(s), s.body.setCircle(t), s.body.collideWorldBounds = !1), s.tint = e, s
            }, e.prototype.createRect = function(t, e, i, s) {
                void 0 === s && (s = !0);
                var n = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Rect);
                return n.width = t, n.height = e, n.anchor.set(.5), s && (this.game.physics.box2d.enable(n), n.body.collideWorldBounds = !1), n.tint = i, n
            }, e.prototype.createRopeRect = function(t, e, i, s) {
                void 0 === s && (s = !0);
                var n = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Rope);
                return n.width = t, n.height = e, n.anchor.set(.5), n
            }, e.prototype.createImageRect = function(t, e, i, s) {
                void 0 === s && (s = 16777215);
                var n = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), i);
                return n.width = t, n.height = e, n.anchor.set(.5), this.game.physics.box2d.enable(n), n.body.collideWorldBounds = !1, n.tint = s, n
            }, e.prototype.filterRaycastHit = function(t, e, i, s) {
                return !0 === t.static && !0 === t.level
            }, e.prototype.destroy = function() {
                t.prototype.destroy.call(this), TweenMax.killTweensOf(this), clearTimeout(this.resetSlowMotionTimeout)
            }, e
        }(Phaser.Group);
    e.default = p
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = function(t) {
        function e(e, i, s, n) {
            var o = t.call(this, e, s, n) || this;
            return o.blinking = !1, o.lastBlinkTime = 0, o.blinkDuration = 100, o.closed = o.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.EyeClosed), o.closed.anchor.x = .5, o.closed.anchor.y = .5, o.closed.scale.x = 1.25, o.closed.scale.y = 1.25, o.addChild(o.closed), o.white = o.createCircle(27, 16777215), o.addChild(o.white), o.pupil = o.createCircle(13, 0), o.addChild(o.pupil), o.closed.visible = !1, o
        }
        return n(e, t), e.prototype.createCircle = function(t, e) {
            var i = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Circle16);
            return i.width = t, i.height = t, i.anchor.set(.5), i.tint = e, i
        }, e.prototype.updateLookDirection = function(t, e, i) {
            t > 20 ? t = 20 : t < -20 && (t = -20), e > 20 ? e = 20 : e < -20 && (e = -20), this.pupil.x = .03 * t * 3, this.pupil.y = .03 * e * 3, this.angle = -i, this.closed.angle = -this.angle, this.blinking ? this.game.time.now > this.lastBlinkTime + this.blinkDuration && this.toggleBlink() : 100 * Math.random() > 99 && this.toggleBlink()
        }, e.prototype.updateFromEye = function(t) {
            this.pupil.x = t.pupil.x, this.pupil.y = t.pupil.y, this.angle = t.angle, this.closed.angle = -this.angle, t.blinking !== this.blinking && this.toggleBlink()
        }, e.prototype.toggleBlink = function(t) {
            void 0 === t && (t = 0), this.blinking = !this.blinking, this.closed.visible = this.blinking, this.white.visible = !this.blinking, this.pupil.visible = !this.blinking, this.blinking && (this.lastBlinkTime = this.game.time.now, this.blinkDuration = 250 * Math.random() + 150 + t)
        }, e
    }(Phaser.Group);
    e.default = o
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = function(t) {
        function e(e) {
            var i = t.call(this, e) || this;
            i.parts = new Array;
            for (var s = 0; s < 4; s++) {
                var n = i.createCircle(1, Colors.white);
                i.parts.push(n), i.addChild(n)
            }
            return i
        }
        return n(e, t), e.prototype.setColor = function(t) {
            if (t != this.color) {
                for (var e = 0; e < this.parts.length; e++) this.parts[e].tint = t;
                this.color = t
            }
        }, e.prototype.play = function() {
            var t;
            this.visible = !0, this.renderable = !0;
            for (var e = 0; e < this.parts.length; e++) {
                t = this.parts[e], this.resetPart(t);
                var i = .15 * Math.random();
                TweenLite.to(t, .75, {
                    delay: i,
                    x: 150 * Math.random() - 75,
                    y: 75 * Math.random() + 25,
                    ease: Cubic.easeOut,
                    onCompleteScope: this,
                    onComplete: function() {
                        this.visible = !1, this.renderable = !1
                    }
                }), TweenLite.to(t.scale, .8, {
                    delay: i,
                    x: 0,
                    y: 0,
                    ease: Cubic.easeOut
                })
            }
        }, e.prototype.resetPart = function(t) {
            t.x = 0, t.y = 0, t.scale.x = 6 * (.2 + .15 * Math.random()), t.scale.y = t.scale.x, t.rotation = 0, t.alpha = 1, t.visible = !0, TweenLite.killTweensOf(t), TweenLite.killTweensOf(t.scale)
        }, e.prototype.createCircle = function(t, e) {
            var i = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Circle16);
            return i.width = t, i.height = t, i.anchor.set(.5), i.tint = e, i
        }, e
    }(Phaser.Group);
    e.default = o
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0),
        o = function(t) {
            function e(e) {
                var i = t.call(this, e) || this;
                return i.passed = !1, i.currentNumber = 0, i.line = i.createRect(22, e.world.height, Colors.white), i.line.y = e.world.centerY, i.add(i.line), i.line.autoCull = !0, i.line.alpha = .8, i.greenLine = i.createRect(22, 300, Colors.perfectGreen), i.greenLine.y = e.world.centerY, i.add(i.greenLine), i.greenLine.autoCull = !0, i.alpha = 1, i.texts = [], i.highScores = {}, i
            }
            return n(e, t), e.prototype.filterRaycastHit = function(t, e, i, s) {
                return !0 === t.static && !t.isEnemy
            }, e.prototype.place = function(t) {
                void 0 === t && (t = 0), this.y = t, TweenMax.killTweensOf(this.line), TweenMax.killTweensOf(this.greenLine), this.greenLine.height = 300, this.line.alpha = .8, this.greenLine.alpha = 1, this.bringToTop(this.greenLine)
            }, e.prototype.setNumberAtFloor = function() {}, e.prototype.hit = function(t) {
                void 0 === t && (t = !1), this.greenLine.alpha = 0, this.line.alpha = 0, t ? (this.greenLine.height = this.line.height, this.bringToTop(this.greenLine), this.greenLine.alpha = 1) : (this.line.height = this.line.height, this.line.alpha = 1, this.bringToTop(this.line)), TweenMax.to(this.line.scale, .15, {
                    x: 3,
                    yoyo: !0,
                    repeat: 1,
                    ease: Quad.easeOut
                }), TweenMax.to(this.line, .25, {
                    alpha: 0,
                    delay: .3
                }), TweenMax.to(this.greenLine.scale, .15, {
                    x: 3,
                    yoyo: !0,
                    repeat: 1,
                    ease: Quad.easeOut
                }), TweenMax.to(this.greenLine, .25, {
                    alpha: 0,
                    delay: .3
                })
            }, e.prototype.createRect = function(t, e, i) {
                var s = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Rect16);
                return s.width = t, s.height = e, s.anchor.set(.5), s.tint = i, s
            }, e
        }(Phaser.Group);
    e.default = o
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = function(t) {
        function e(e, i, s) {
            void 0 === i && (i = 0), void 0 === s && (s = 0);
            var n = t.call(this, e, i, s, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Bubble) || this;
            n.width = 110, n.height = 110, n.anchor.set(.5), n.game.physics.box2d.enable(n), n.body.setCircle(0);
            var o = n.body.addCircle(85, 0, 0);
            return n.body.sensor = !0, o.SetSensor(!0), n.body.isSensor = !0, n.body.static = !0, n.body.x = i, n.body.y = s, n.autoCull = !0, n.taken = !1, n.body.taken = !1, n.body.setCollisionCategory(HangerCollisionGroups.coin), n
        }
        return n(e, t), e.prototype.place = function(t, e) {
            this.body.x = t, this.body.y = e, this.body.taken = !1
        }, e.prototype.update = function() {
            t.prototype.update.call(this) || (this.body.angle = this.body.angle + .1 * this.game.time.elapsed, this.body.y = this.body.y + 1 * Math.sin(.002 * this.game.time.time))
        }, e
    }(Phaser.Sprite);
    e.default = o
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0),
        o = function(t) {
            function e(e, i) {
                var s = t.call(this, e, i, e.world.centerY, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Goal) || this;
                return s.isHit = !1, s.scale.set(2, 2), s.anchor.set(.5, .5), s.y = e.world.centerY + 20, s
            }
            return n(e, t), e.prototype.hit = function() {
                this.isHit || TweenLite.to(this.scale, .1, {
                    x: 2.8,
                    ease: Quad.easeOut,
                    onComplete: function() {
                        this.reverse()
                    }
                })
            }, e
        }(Phaser.Sprite);
    e.default = o
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(7),
        a = i(5),
        h = function(t) {
            function e(e, i, s, n) {
                void 0 === s && (s = 0), void 0 === n && (n = 0);
                var o = t.call(this, a.EventType.BUZZ_SAW, e, s, n, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Spikeball) || this;
                o.speed = .04 * (Math.floor(1.7 * Math.random()) + 3), o.moving = !1;
                var h = .85 + .3 * Math.random();
                return o.width = 120 * h, o.height = 120 * h, o.anchor.set(.5), o.game.physics.box2d.enable(o), o.body.static = !0, o.body.setCircle(30 * h), o.body.setCollisionCategory(HangerCollisionGroups.enemy), o.body.x = s, o.body.y = n, o.body.isEnemy = !0, o.autoCull = !0, i.add(o), o
            }
            return n(e, t), e.prototype.update = function() {
                this.body.angle = this.body.angle + this.speed * this.game.time.elapsed, this.moving && (this.body.y = this.body.y + 3 * Math.sin(.002 * (this.game.time.time + this.body.x % 600)))
            }, e.prototype.destroy = function() {
                t.prototype.destroy.call(this)
            }, e
        }(o.default);
    e.default = h
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(7),
        a = i(5),
        h = function(t) {
            function e(e, i, s, n) {
                void 0 === s && (s = 0), void 0 === n && (n = 0);
                var o = t.call(this, a.EventType.PROPELLER, e, s, n, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Propeller) || this;
                o.speed = .04 * (Math.floor(1.7 * Math.random()) + 3), o.moving = !1;
                return o.scale.set(1, 1), o.anchor.set(.5), o.game.physics.box2d.enable(o), o.body.x = s, o.body.y = n, o.body.isCrate = !0, o.body.restitution = 0, o.body.mass = 1e6, o.body.gravityScale = 0, o.body.kinematic = !0, o.autoCull = !0, i.add(o), o.alpha = 0, setTimeout(function() {
                    o.visible = !0, o.alpha = 1
                }, 400), o
            }
            return n(e, t), e.prototype.update = function() {
                this.body.angularVelocity = 6, this.moving && (this.body.y = this.body.y + 3 * Math.sin(.002 * (this.game.time.time + this.body.x % 600)))
            }, e.prototype.destroy = function() {
                t.prototype.destroy.call(this)
            }, e
        }(o.default);
    e.default = h
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(7),
        a = i(5),
        h = function(t) {
            function e(e, i, s, n) {
                void 0 === s && (s = 0), void 0 === n && (n = 0);
                var o = t.call(this, a.EventType.CRATE, e, 0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Box) || this;
                return o.width = 81, o.height = 81, o.anchor.set(.5), o.game.physics.box2d.enable(o), o.body.x = s, o.body.y = n, o.autoCull = !0, o.body.allowSleep = !1, o.body.sprite = o, o.body.mass = .45, o.body.restitution = .2, o.body.collideWorldBounds = !1, o.body.isCrate = !0, o.visible = !0, setTimeout(function() {
                    o.visible = !0
                }, 50), i.add(o), i.bringToTop(o), o
            }
            return n(e, t), e.prototype.activate = function() {
                this.body.applyForce(0, -.1), t.prototype.activate.call(this)
            }, e
        }(o.default);
    e.default = h
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(7),
        a = i(5),
        h = function(t) {
            function e(e, i, s, n) {
                void 0 === s && (s = 0), void 0 === n && (n = 0);
                var o = t.call(this, a.EventType.SPRING, e, s, n, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Spring) || this;
                return o.width = 140, o.height = 140, o.anchor.set(.5), o.game.physics.box2d.enable(o), o.body.rotation = .5, o.body.static = !0, o.body.setCollisionCategory(HangerCollisionGroups.enemy), o.body.x = s, o.body.y = n, o.body.isSpring = !0, o.body.isEnemy = !0, o.body.spring = o, o.autoCull = !0, o.body.sprite = o, i.addChild(o), o.alpha = 0, setTimeout(function() {
                    o.visible = !0, o.alpha = 1
                }, 400), o
            }
            return n(e, t), e.prototype.onHit = function(t) {
                var e = this;
                1 != this.isHit && (TweenMax.killTweensOf(t), TweenMax.from(t, .6, {
                    y: this.y - 40,
                    x: this.x + 20,
                    ease: Elastic.easeOut,
                    onComplete: function() {
                        e.isHit = !1
                    }
                }), this.isHit = !0)
            }, e.prototype.update = function() {
                t.prototype.update.call(this)
            }, e
        }(o.default);
    e.default = h
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(7),
        a = i(5),
        h = function(t) {
            function e(e, i, s, n) {
                void 0 === s && (s = 0), void 0 === n && (n = 0);
                var o = t.call(this, a.EventType.BOOST, e, 0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BoostArrows) || this;
                return o.anchor.set(.5), o.game.physics.box2d.enable(o), o.body.setRectangle(o.width + 80, o.height + 60, -60, 0), o.body.static = !0, o.body.sensor = !0, o.body.isBoost = !0, o.body.goalBoost = !0, o.autoCull = !0, o.body.setCollisionCategory(HangerCollisionGroups.enemy), o.body.x = s, o.body.y = n, o.visible = !0, setTimeout(function() {
                    o.visible = !0
                }, 50), i.add(o), o.body.angle = -20, i.sendToBack(o), o
            }
            return n(e, t), e
        }(o.default);
    e.default = h
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(7),
        a = i(5),
        h = function(t) {
            function e(e, i, s, n) {
                void 0 === s && (s = 0), void 0 === n && (n = 0);
                var o = t.call(this, a.EventType.BOOST6, e, 0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BoostArrowsSix) || this;
                return o.anchor.set(.5), o.game.physics.box2d.enable(o), o.body.setRectangle(o.width + 80, o.height + 60, -60, 0), o.body.static = !0, o.body.sensor = !0, o.body.isBoost = !0, o.autoCull = !0, o.body.setCollisionCategory(HangerCollisionGroups.enemy), o.body.x = s, o.body.y = n, o.visible = !0, setTimeout(function() {
                    o.visible = !0
                }, 50), i.add(o), o.body.angle = -20, i.sendToBack(o), o
            }
            return n(e, t), e
        }(o.default);
    e.default = h
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(7),
        a = i(5),
        h = function(t) {
            function e(e, i, s, n) {
                void 0 === s && (s = 0), void 0 === n && (n = 0);
                var o = t.call(this, a.EventType.BIGBALL, e, 0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Ball) || this;
                return o.width = 450, o.height = 450, o.anchor.set(.5), o.game.physics.box2d.enable(o), o.body.setCircle(o.width / 2), o.body.x = s, o.body.y = n, o.autoCull = !0, o.body.allowSleep = !1, o.body.sprite = o, o.body.mass = .54, o.body.restitution = .7, o.body.collideWorldBounds = !1, o.body.isCrate = !0, i.add(o), o.alpha = 0, setTimeout(function() {
                    o.visible = !0, o.alpha = 1
                }, 400), o
            }
            return n(e, t), e.prototype.activate = function() {
                this.body.applyForce(0, -.1), t.prototype.activate.call(this)
            }, e
        }(o.default);
    e.default = h
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(7),
        a = i(5),
        h = function(t) {
            function e(e, i, s, n) {
                void 0 === s && (s = 0), void 0 === n && (n = 0);
                var o = t.call(this, a.EventType.BIGPROPELLER, e, s, n, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Propeller) || this;
                o.speed = .04 * (Math.floor(1.7 * Math.random()) + 3), o.moving = !1;
                return o.scale.set(2), o.anchor.set(.5), o.game.physics.box2d.enable(o), o.body.x = s, o.body.y = n, o.body.isCrate = !0, o.body.restitution = 0, o.body.mass = 1e6, o.body.gravityScale = 0, o.body.kinematic = !0, o.autoCull = !0, i.add(o), o.alpha = 0, setTimeout(function() {
                    o.visible = !0, o.alpha = 1
                }, 400), o
            }
            return n(e, t), e.prototype.update = function() {
                this.body.angularVelocity = 3, this.moving && (this.body.y = this.body.y + 3 * Math.sin(.002 * (this.game.time.time + this.body.x % 600)))
            }, e.prototype.destroy = function() {
                t.prototype.destroy.call(this)
            }, e
        }(o.default);
    e.default = h
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = function(t) {
        function e(e, i, s) {
            void 0 === i && (i = 0), void 0 === s && (s = 0);
            var n = t.call(this, e, i, s, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Cloud) || this;
            return n.anchor.set(.5), n.animationOffset = Math.random(), n.scale.set(1 + .55 * Math.random()), Math.random() > .45 && (n.scale.x = -1 * n.scale.x), n.alpha = .5, n
        }
        return n(e, t), e.prototype.update = function() {
            t.prototype.update.call(this), this.y = this.y + .5 * Math.sin(.001 * this.game.time.time + this.animationOffset), this.game.camera.x > this.x + 248 && (this.x = this.x + 1488, this.y = this.game.height / 2 - 150 - 400 * Math.random(), this.alpha = .2 * Math.random() + .4, this.scale.set(1 + .55 * Math.random()))
        }, e
    }(Phaser.Sprite);
    e.default = o
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(3),
        a = i(99),
        h = i(100),
        l = i(107),
        c = i(4),
        u = function(t) {
            function e(i, s, n, r, o, a) {
                void 0 === a && (a = null);
                var h = t.call(this, i) || this;
                return h.created = !1, h.ninjaTimeout = null, h.screenTop = 0, h.screenBottom = 0, h.hanger = n, h.onPlay = s, h.callBacksContext = a, h.onUpgrade = r, h.fixedToCamera = !0, h.cameraOffset.x = i.width / 2, h.cameraOffset.y = i.height / 2, h.top = i.height / 2, h.bottom = -i.height / 2, h.onReload = o, e.startCount++, e.firstShow ? (h.game.camera.resetFX(), h.game.camera.fade(0, .7), setTimeout(function() {
                    h.game.camera.flash(0, 200), h.create()
                }, 500)) : h.create(), h
            }
            return n(e, t), e.prototype.create = function() {
                var t = this;
                if (!0 !== this.created) {
                    this.back = this.createRect(this.game.width + 100, this.game.height - 7 * SAFE_TOP - 90, 0), this.back.y = 1 * -SAFE_TOP - 15, this.back.alpha = 0, this.addChild(this.back), this.back.inputEnabled = !0, this.back.events.onInputDown.add(this.onPlay, this.callBacksContext), this.titleText = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Title), this.titleText.anchor.setTo(.5, .5), this.titleText.y = -this.game.height / 2 + 160 + 2 * SAFE_TOP, this.titleText.scale.set(.94), this.addChild(this.titleText), this.levelText = c.default.Instance.getBitmapText("level_x", 58, this.game.width - 20, {
                        LEVEL: LEVEL_INDEX
                    }), this.levelText.anchor.setTo(.5, .5), this.levelText.alpha = 0, this.levelText.alpha = 1, this.levelText.y = this.titleText.y + 120, this.addChild(this.levelText), this.sendToBack(this.levelText), this.startText = c.default.Instance.getBitmapText("tap_to_play", 58, this.game.width - 20), this.startText.anchor.setTo(.5, .5), this.startText.y = this.game.height / 7 - 2 * SAFE_TOP + 20, this.addChild(this.startText), this.sendToBack(this.startText), this.addChild(this.titleText), this.skinsButton = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnCharSelectTitle), this.skinsButton.y = -80, this.skinsButton.anchor.set(.5, .5), this.skinsButton.x = -this.game.width / 2 + 40, this.skinsButton.inputEnabled = !0, this.skinsButton.events.onInputDown.add(function() {
                        t.onSkins()
                    }), this.addChild(this.skinsButton), this.skinsAnimation = this.game.make.sprite(this.skinsButton.x + 12, this.skinsButton.y, r.Atlases.SpritesheetsMain.getName()), this.skinsAnimation.anchor.set(.5);
                    var i = [];
                    i[0] = r.Atlases.SpritesheetsMain.Frames.SkinTarantulaMenu, i[1] = r.Atlases.SpritesheetsMain.Frames.SkinRobotMenu, i[2] = r.Atlases.SpritesheetsMain.Frames.SkinMarioMenu, i[3] = r.Atlases.SpritesheetsMain.Frames.SkinBatmanMenu, i[4] = r.Atlases.SpritesheetsMain.Frames.SkinPigMenu, this.skinsAnimation.animations.add("skins", i, 2, !0, !1), this.skinsAnimation.play("skins"), this.addChild(this.skinsAnimation), this.noAdsButton = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnCharSelectTitle), this.noAdsButton.y = this.skinsButton.y + 140, this.noAdsButton.anchor.set(.5, .5), this.noAdsButton.x = -this.game.width / 2 + 40, this.noAdsButton.x = -600, this.noAdsButton.inputEnabled = !0, this.noAdsButton.events.onInputDown.add(function() {
                        o.default.Instance.buyIAP("hanger2_noads")
                    }), this.addChild(this.noAdsButton), this.noAdsIcon = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.NoAds), this.noAdsIcon.anchor.set(.5), this.noAdsIcon.x = this.noAdsButton.x + 12, this.noAdsIcon.y = this.noAdsButton.y - 10, this.noAdsIcon.scale.set(.7), this.addChild(this.noAdsIcon), this.noAdsText = c.default.Instance.getBitmapText("btn_no_ads", 23, 105), this.noAdsText.anchor.set(.5), this.noAdsText.y = this.noAdsIcon.y + 46, this.noAdsText.x = this.noAdsIcon.x, this.addChild(this.noAdsText), this.noAdsText.scale.x < .6 && (this.noAdsText.scale.y += .15), NO_ADS && (this.skinsButton.y = 0, this.skinsAnimation.y = 0), this.restorePurchasesButton = new Phaser.Group(this.game);
                    var s = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.RestorePurchases);
                    s.x = 10, s.scale.set(.62), this.restorePurchasesButton.add(s), this.restorePurchasesButton.x = -this.game.width / 2 + 5 + SAFE_SIDE, this.restorePurchasesButton.y = -this.game.height / 2 + 5 + SAFE_TOP, this.restorePurchasesButton.x = -600, s.inputEnabled = !0, s.events.onInputDown.add(function() {
                        o.default.Instance.restorePurchases()
                    });
                    for (var n = c.default.Instance.getText("lbl_restore_purchases").split(/(\s+)/), a = 0; a < n.length; a++) {
                        var h = this.game.add.bitmapText(0, 0, Fonts.bitmapMain, n[a], 18);
                        h.anchor.set(0, .5), h.x = 0, h.y = 55 + 8 * a, this.restorePurchasesButton.add(h), h.inputEnabled = !0, h.events.onInputDown.add(function() {
                            o.default.Instance.restorePurchases()
                        })
                    }
                    this.add(this.restorePurchasesButton), this.upgradeBoostBtn = new l.default(this.game, r.Atlases.SpritesheetsMain.Frames.BtnUpgradeBoost, function() {
                        BOOSTER_LEVEL += 1, t.upgradeBoostBtn.updateState(BOOSTER_LEVEL + 1), t.onUpgrade.call(t.callBacksContext), o.default.Instance.saveData(), t.upgradeStrengthBtn.updateState(STRENGTH_LEVEL + 1), t.hand && (t.hand.visible = !1)
                    }), this.upgradeBoostBtn.y = this.game.height / 2 - 200 - 5 * SAFE_TOP, this.upgradeBoostBtn.x = -100, this.upgradeBoostBtn.scale.set(.85), this.upgradeBoostBtn.updateState(BOOSTER_LEVEL + 1), this.add(this.upgradeBoostBtn), this.upgradeStrengthBtn = new l.default(this.game, r.Atlases.SpritesheetsMain.Frames.BtnUpgradeStrength, function() {
                        STRENGTH_LEVEL += 1, t.upgradeStrengthBtn.updateState(STRENGTH_LEVEL + 1), t.onUpgrade.call(t.callBacksContext), t.hanger.setSkin(ACTIVE_SKIN), o.default.Instance.saveData(), t.upgradeBoostBtn.updateState(BOOSTER_LEVEL + 1), t.hand && (t.hand.visible = !1)
                    }, o.AD_PLACEMENT.UPGRADE_STRENGTH, "Strength", "btn_strength"), this.upgradeStrengthBtn.y = this.game.height / 2 - 200 - 5 * SAFE_TOP, this.upgradeStrengthBtn.x = 100, this.upgradeStrengthBtn.scale.set(.85), this.upgradeStrengthBtn.updateState(STRENGTH_LEVEL + 1), this.add(this.upgradeStrengthBtn), 6 == LEVEL_INDEX && o.default.Instance.showAppReview(), LEVEL_INDEX >= 3 && 0 == BOOSTER_LEVEL && 0 == STRENGTH_LEVEL && (this.hand = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Hand), this.hand.anchor.set(.8, 1), this.hand.angle = 80, this.hand.scale.set(.5), this.hand.x = this.upgradeBoostBtn.x - 175, this.hand.y = this.upgradeBoostBtn.y + 110, this.add(this.hand), TweenMax.to(this.hand, .6, {
                        x: this.upgradeBoostBtn.x - 145,
                        y: this.upgradeBoostBtn.y + 95,
                        yoyo: !0,
                        repeat: -1,
                        ease: Strong.easeInOut
                    })), this.aboutText = this.game.add.bitmapText(0, 600, Fonts.bitmapMain, "COPYRIGHT A SMALL GAME AB 2020 VERSION 0529", 26), this.aboutText.anchor.setTo(.5, .5), this.addChild(this.aboutText), this.game.add.tween(this.aboutText).to({
                        y: this.game.height / 2 - 26
                    }, 300, Phaser.Easing.Back.Out, !0, 200), HUZ && (this.aboutText.visible = !1), 1 == LEVEL_INDEX && (this.skinsButton.visible = !1, this.skinsAnimation.visible = !1, this.upgradeBoostBtn.visible = !1, this.upgradeStrengthBtn.visible = !1, this.startText.y = this.game.height / 2 - 250), this.created = !0, this.wasFirstShow = e.firstShow
                }
            }, e.prototype.updateUpgradeButtons = function() {}, e.prototype.createDebugMenu = function(t, e) {
                this.debugMenu || (this.debugMenu = new a.default(this.game, this.onReload, this.callBacksContext, t, e), this.debugMenu.x = -this.game.width / 2, this.debugMenu.y = -this.game.height / 2 + 40, this.addChild(this.debugMenu), this.debugMenu.visible = !1)
            }, e.prototype.update = function() {
                t.prototype.update.call(this), IAP_IN_PROGRESS ? this.restorePurchasesButton && (this.restorePurchasesButton.visible = !1) : this.restorePurchasesButton && (this.restorePurchasesButton.visible = !0), NO_ADS || IAP_IN_PROGRESS || 1 == LEVEL_INDEX ? this.noAdsButton && (this.noAdsButton.visible = !1, this.noAdsIcon.visible = !1, this.noAdsText.visible = !1) : this.noAdsButton && (this.noAdsButton.visible = !0, this.noAdsIcon.visible = !0, this.noAdsText.visible = !0)
            }, e.prototype.onSkins = function() {
                this.skinsScreen && 1 == this.skinsScreen.visible || (this.skinsScreen = new h.default(this.game, this.hanger), this.skinsScreen.visible = !0)
            }, e.prototype.createRect = function(t, e, i) {
                var s = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Rect);
                return s.width = t, s.height = e, s.anchor.set(.5), s.tint = i, s
            }, e.prototype.destroy = function() {
                e.firstShow = !1, this.debugMenu && this.debugMenu.destroy(), this.upgradeBoostBtn && this.upgradeBoostBtn.destroy(), this.hand && (TweenMax.killTweensOf(this.hand), this.hand.destroy()), this.upgradeStrengthBtn && this.upgradeStrengthBtn.destroy(), this.skinsScreen && this.skinsScreen.destroy(), t.prototype.destroy.call(this)
            }, e.firstShow = !0, e.shownPlayWithFriends = !1, e.shownBotPrompt = !1, e.startCount = 0, e.shownShortcutPrompt = !1, e
        }(Phaser.Group);
    e.default = u
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(3),
        a = i(10),
        h = function(t) {
            function e(e, i, s, n, h) {
                var l = t.call(this, e) || this;
                l.level = 0, l.onReload = i, l.callBacksContext = s, l.darken = l.game.make.sprite(0, -40, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Rect), l.darken.alpha = .7, l.darken.tint = 0, l.darken.width = l.game.width, l.darken.height = 600, l.darken.inputEnabled = !0, l.addChild(l.darken), l.currentLevel = n, l.currentHanger = h, l.gradientBacks = ["sky_gradient_01.png", "sky_gradient_02.png", "sky_gradient_03.png", "sky_gradient_04.png", "sky_gradient_05.png", "sky_gradient_06.png"], l.stickmanColors = [16716032, 39962, 18920, 8061183, 14745855, 16776960, 16056443, 16734464, 6899221, 4013373, 0, 16777215], l.text = l.game.add.bitmapText(0, 50, Fonts.bitmapMain, "UNLOCK", 50), l.text.x = 200, l.text.anchor.set(.5, .5), l.text.tint = 65280, l.addChild(l.text), l.text.inputEnabled = !0, l.text.events.onInputDown.add(function() {
                    o.default.Instance.unlockAll(), l.onReload.call(l.callBacksContext)
                }), l.reload = l.game.make.sprite(0, 80, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnRestart), l.addChild(l.reload), l.reload.anchor.set(.5), l.reload.scale.set(.5), l.reload.x = l.game.width / 2, l.reload.y = 515, l.reload.tint = 16777215, l.reload.inputEnabled = !0, l.reload.events.onInputDown.add(i, s), l.reset = l.game.add.bitmapText(0, 50, Fonts.bitmapMain, "RESETSAVE", 50), l.reset.x = 380, l.reset.anchor.set(.5, .5), l.reset.tint = 65280, l.addChild(l.reset), l.reset.inputEnabled = !0, l.reset.tint = 65280, l.reset.events.onInputDown.add(l.resetProgress, l), l.backBtn = l.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnBack), l.backBtn.anchor.set(.5, .5), l.backBtn.x = 50, l.backBtn.y = 30, l.backBtn.inputEnabled = !0, l.backBtn.events.onInputDown.add(function() {
                    l.hide()
                }), l.addChild(l.backBtn), l.hideUi = l.game.add.bitmapText(0, 0, Fonts.bitmapMain, "HIDE UI ( )", 40), HIDE_UI && (l.hideUi.text = "HIDE UI (X)"), l.hideUi.x = 20, l.hideUi.y = 200, l.hideUi.anchor.set(0, .5), l.hideUi.tint = 16777215, l.addChild(l.hideUi), l.hideUi.inputEnabled = !0, l.hideUi.events.onInputDown.add(function() {
                    0 == HIDE_UI ? (HIDE_UI = !0, l.hideUi.text = "HIDE UI (X)") : (HIDE_UI = !1, l.hideUi.text = "HIDE UI ()")
                }, l), l.skinStickman = l.game.add.bitmapText(0, 0, Fonts.bitmapMain, "STICKMAN ( )", 40), MULTI_HANGERS && (l.skinStickman.text = "STICKMAN (X)"), l.skinStickman.x = 20, l.skinStickman.y = 240, l.skinStickman.anchor.set(0, .5), l.skinStickman.tint = 16777215, l.addChild(l.skinStickman), l.skinStickman.inputEnabled = !0, l.skinStickman.events.onInputDown.add(function() {
                    "skin_hanger_stickman" != ACTIVE_SKIN ? (l.skinStickman.text = "STICKMAN (X)", a.default.currentHanger.setSkin("skin_hanger_stickman")) : (l.skinStickman.text = "STICKMAN ( )", a.default.currentHanger.setSkin("skin_hanger"))
                }, l), l.grass = l.game.add.bitmapText(0, 0, Fonts.bitmapMain, "GRASS ( )", 40), GRASS && (l.grass.text = "GRASS (X)"), l.grass.x = 20, l.grass.y = 280, l.grass.anchor.set(0, .5), l.grass.tint = 16777215, l.addChild(l.grass), l.grass.inputEnabled = !0, l.grass.events.onInputDown.add(function() {
                    GRASS ? (l.grass.text = "GRASS ( )", GRASS = !1) : (l.grass.text = "GRASS (X)", GRASS = !0)
                }, l), l.pattern = l.game.add.bitmapText(0, 0, Fonts.bitmapMain, "GROUND PATTERN ( )", 40), GROUNDPATTERNS && (l.pattern.text = "GROUND PATTERN (X)"), l.pattern.x = 20, l.pattern.y = 320, l.pattern.anchor.set(0, .5), l.pattern.tint = 16777215, l.addChild(l.pattern), l.pattern.inputEnabled = !0, l.pattern.events.onInputDown.add(function() {
                    GROUNDPATTERNS ? (l.pattern.text = "GROUND PATTERN ( )", GROUNDPATTERNS = !1) : (l.pattern.text = "GROUND PATTERN (X)", GROUNDPATTERNS = !0)
                }, l), l.boxes = l.game.add.bitmapText(0, 0, Fonts.bitmapMain, "BOXES ( )", 40), LEVELBOXES && (l.boxes.text = "BOXES (X)"), l.boxes.x = 20, l.boxes.y = 360, l.boxes.anchor.set(0, .5), l.boxes.tint = 16777215, l.addChild(l.boxes), l.boxes.inputEnabled = !0, l.boxes.events.onInputDown.add(function() {
                    LEVELBOXES ? (l.boxes.text = "BOXES ( )", LEVELBOXES = !1) : (l.boxes.text = "BOXES (X)", LEVELBOXES = !0)
                }, l), l.fpsMeter = l.game.add.bitmapText(0, 0, Fonts.bitmapMain, "FPSMETER ( )", 40), FPSMETER && (l.fpsMeter.text = "FPSMETER (X)"), l.fpsMeter.x = 20, l.fpsMeter.y = 400, l.fpsMeter.anchor.set(0, .5), l.fpsMeter.tint = 16777215, l.addChild(l.fpsMeter), l.fpsMeter.inputEnabled = !0, l.fpsMeter.events.onInputDown.add(function() {
                    FPSMETER ? (l.fpsMeter.text = "FPSMETER ( )", FPSMETER = !1) : (l.fpsMeter.text = "FPSMETER (X)", FPSMETER = !0)
                }, l);
                for (var c = function() {
                        var t = u.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), u.gradientBacks[d]);
                        t.width = 60, t.height = 60, t.x = 65 * d, t.y = 90, t.source = u.gradientBacks[d], t.inputEnabled = !0, t.events.onInputDown.add(function() {
                            GRADIENT_BACK = t.source, a.default.DEBUG_back && a.default.DEBUG_back.showGradientInstead()
                        }, s), u.addChild(t)
                    }, u = this, d = 0; d < l.gradientBacks.length; d++) c();
                return l.level = LEVEL_INDEX, l.levelText = l.game.add.bitmapText(0, 0, Fonts.bitmapMain, "LEVEL " + l.level, 80), l.levelText.x = l.game.width / 2, l.levelText.anchor.set(.5, .5), l.levelText.tint = 16711935, l.addChild(l.levelText), l.levelText.y = 450, l.up = l.game.add.bitmapText(0, 0, Fonts.bitmapMain, "PREV", 60), l.addChild(l.up), l.up.anchor.set(.5, .5), l.up.tint = 65280, l.up.inputEnabled = !0, l.up.events.onInputDown.add(l.onDown, l), l.up.x = l.levelText.x - 200, l.up.y = 450, l.down = l.game.add.bitmapText(0, 0, Fonts.bitmapMain, "NEXT", 60), l.addChild(l.down), l.down.anchor.set(.5, .5), l.down.tint = 65280, l.down.inputEnabled = !0, l.down.events.onInputDown.add(l.onUp, l), l.down.x = l.levelText.x + 200, l.down.y = 450, l.cpBack = document.getElementById("backColor"), l.cpLevel = document.getElementById("levelColor"), l.cpStickman = document.getElementById("stickmanColor"), l.cpBack.addEventListener("change", function() {
                    console.log("BACKCOLOR:" + l.cpBack.value), OVERRIDE_COLORS.back = parseInt(l.cpBack.value.slice(1), 16), console.log(OVERRIDE_COLORS.back), a.default.DEBUG_back.updateDebugTint(), l.currentHanger && l.currentHanger.updateDebugShadow()
                }), l.cpLevel.addEventListener("change", function() {
                    console.log("LEVELCOLOR:" + l.cpLevel.value), OVERRIDE_COLORS.level = parseInt(l.cpLevel.value.slice(1), 16), l.currentLevel.updateColor()
                }), l.cpStickman.addEventListener("change", function() {
                    console.log("LEVELCOLOR:" + l.cpLevel.value), OVERRIDE_COLORS.stickman = parseInt(l.cpStickman.value.slice(1), 16), SKINS.skin_hanger_stickman.pantsColor = OVERRIDE_COLORS.stickman, SKINS.skin_hanger_stickman.shirtColor = OVERRIDE_COLORS.stickman, SKINS.skin_hanger_stickman.skinColor = OVERRIDE_COLORS.stickman, "skin_hanger_stickman" == ACTIVE_SKIN && a.default.currentHanger.setSkin("skin_hanger_stickman")
                }), l
            }
            return n(e, t), e.prototype.show = function() {
                this.visible = !0, document.getElementById("debugColor").style.display = "block"
            }, e.prototype.hide = function() {
                this.visible = !1, document.getElementById("debugColor").style.display = "none"
            }, e.prototype.resetProgress = function() {
                o.default.Instance.resetSaveData()
            }, e.prototype.onUp = function() {
                this.level++, LEVEL_INDEX = this.level, this.levelText.text = "LEVEL " + this.level
            }, e.prototype.onDown = function() {
                this.level--, this.level < 1 && (this.level = 1), LEVEL_INDEX = this.level, this.levelText.text = "LEVEL " + this.level
            }, e.prototype.destroy = function() {
                t.prototype.destroy.call(this), document.getElementById("debugColor").style.display = "none"
            }, e.prototype.update = function() {
                t.prototype.update.call(this)
            }, e
        }(Phaser.Group);
    e.default = h
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(3),
        a = i(101),
        h = i(102),
        l = function(t) {
            function e(e, i) {
                var s = t.call(this, e) || this;
                return s.fixedToCamera = !0, s.cameraOffset.x = s.game.width / 2, s.cameraOffset.y = s.game.height / 2, s.top = e.height / 2, s.bottom = -e.height / 2, s.hanger = i, s.create(), s
            }
            return n(e, t), e.prototype.create = function() {
                var t = this;
                if (!0 !== this.created) {
                    this.back = this.createRect(this.game.width + 100, this.game.height + 100, 0), this.back.alpha = .75, this.back.inputEnabled = !0, this.addChild(this.back), this.listView = new h.ListView(this.game, this, new Phaser.Rectangle(-this.game.width / 2 + (this.game.width / 2 - 270), -this.game.height / 2 + 100, this.game.width, this.game.height - 100), {
                        direction: "y",
                        overflow: 75,
                        padding: 10,
                        snapping: !1,
                        searchForClicks: !0,
                        autocull: !1
                    }), this.listGroup = new Phaser.Group(this.game), this.coinsIcon = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Coin), this.coinsIcon.anchor.set(.5), this.coinsIcon.x = -50, this.coinsIcon.scale.set(.8), this.coinsIcon.y = -this.game.height / 2 + 60 + SAFE_TOP, this.addChild(this.coinsIcon), this.coinsText = this.game.add.bitmapText(20, 10, Fonts.bitmapMain, "" + o.default.Instance.statsCoins, 50), this.coinsText.anchor.set(0, .5), this.coinsText.x = this.coinsIcon.x + 40 + SAFE_TOP / 2, this.coinsText.y = this.coinsIcon.y, this.addChild(this.coinsText), this.backBtn = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnBack), this.backBtn.anchor.set(.5, .5), this.backBtn.x = -this.game.width / 2 + 60, this.backBtn.y = -this.game.height / 2 + 60 + SAFE_TOP, this.backBtn.inputEnabled = !0, this.backBtn.events.onInputDown.add(function() {
                        t.visible = !1
                    }), this.addChild(this.backBtn);
                    var e = 0,
                        i = 0,
                        s = 0;
                    for (var n in SKINS)
                        if (!SKINS[n].hidden) {
                            var l = !1;
                            i % 2 == 0 && 6 != i && (l = !0);
                            var c = 0;
                            SKINS[n].score && (c = SKINS[n].score);
                            var u = new a.default(this.game, n, SKINS[n].locked, l, this.hanger, this, c);
                            u.x = 180 * e, u.y = s, this.listGroup.addChild(u), ++e > 2 && (i++, e = 0, s += 220)
                        } this.listGroup.nominalWidth = 540, this.listGroup.nominalHeight = 1725, this.listView.add(this.listGroup);
                    var d = new Phaser.Group(this.game);
                    d.nominalHeight = 20, d.nominalWidth = 20, this.listView.add(d)
                }
            }, e.prototype.update = function() {}, e.prototype.createRect = function(t, e, i) {
                var s = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Rect);
                return s.width = t, s.height = e, s.anchor.set(.5), s.tint = i, s
            }, e
        }(Phaser.Group);
    e.default = l
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(3),
        a = i(6),
        h = i(4),
        l = function(t) {
            function e(e, i, s, n, o, a, l) {
                void 0 === s && (s = !1), void 0 === n && (n = !1), void 0 === o && (o = null), void 0 === a && (a = null), void 0 === l && (l = 0);
                var c = t.call(this, e) || this;
                c.skinID = i, c.hanger = o, c.skinsScreen = a, c.back = c.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.CharSelectButton), c.back.inputEnabled = !0, c.addChild(c.back);
                var u = i;
                if (u += "_menu", c.headSkin = c.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), u + ".png"), c.headSkin.anchor.set(.5), c.headSkin.x = c.back.width / 2, c.headSkin.y = c.back.height / 2, c.headSkin.scale.set(1.2), c.addChild(c.headSkin), !1 === s) {
                    c.playBtn = c.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnPlayChar), c.addChild(c.playBtn), c.playBtn.anchor.set(.5), c.playBtn.y = c.back.height + 28, c.playBtn.x = c.back.width / 2, c.playBtn.inputEnabled = !0;
                    var d = h.default.Instance.getBitmapText("btn_play", 31, 100);
                    d.anchor.set(.5), d.x = c.playBtn.x, d.y = c.playBtn.y + 1, c.addChild(d), c.back.events.onInputUp.add(function() {
                        c.playIt()
                    }), c.playBtn.events.onInputUp.add(function() {
                        c.playIt()
                    })
                } else if (l && l > 0) {
                    if (SCORE < l) c.headSkin.tint = 0, c.questionMark = c.game.add.bitmapText(c.headSkin.x - 6, c.headSkin.y, Fonts.bitmapMain, "?", 90), c.questionMark.anchor.set(.5), c.add(c.questionMark), c.playBtn = c.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnProgressionChar), c.addChild(c.playBtn), c.playBtn.anchor.set(.5), c.playBtn.y = c.back.height + 28, c.playBtn.x = c.back.width / 2;
                    else c.playBtn = c.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnFreeChar), c.addChild(c.playBtn), c.playBtn.anchor.set(.5), c.playBtn.y = c.back.height + 28, c.playBtn.x = c.back.width / 2, c.playBtn.inputEnabled = !0, (p = h.default.Instance.getBitmapText("btn_free", 31, 76)).anchor.set(.5), p.x = c.playBtn.x + 17, p.y = c.playBtn.y + 1, c.addChild(p), c.back.events.onInputUp.add(function() {
                        c.watchAdToGetIt()
                    }), c.playBtn.events.onInputUp.add(function() {
                        c.watchAdToGetIt()
                    })
                } else if (n) {
                    var p;
                    c.playBtn = c.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnFreeChar), c.addChild(c.playBtn), c.playBtn.anchor.set(.5), c.playBtn.y = c.back.height + 28, c.playBtn.x = c.back.width / 2, c.playBtn.inputEnabled = !0, (p = h.default.Instance.getBitmapText("btn_free", 31, 76)).anchor.set(.5), p.x = c.playBtn.x + 17, p.y = c.playBtn.y + 1, c.addChild(p), c.back.events.onInputUp.add(function() {
                        c.watchAdToGetIt()
                    }), c.playBtn.events.onInputUp.add(function() {
                        c.watchAdToGetIt()
                    })
                } else c.playBtn = c.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnBuyChar), c.addChild(c.playBtn), c.playBtn.anchor.set(.5), c.playBtn.y = c.back.height + 28, c.playBtn.x = c.back.width / 2, c.playBtn.inputEnabled = !0, c.priceText = c.game.add.bitmapText(0, 0, Fonts.bitmapMain, SKINS[c.skinID].coins, 30), c.priceText.x = c.playBtn.x - 8, c.priceText.y = c.playBtn.y - 19, c.addChild(c.priceText), c.priceText.text.length > 3 && (c.priceText.x = c.playBtn.x - 15), c.playBtn.events.onInputUp.add(function() {
                    c.buyIt()
                }), c.back.events.onInputUp.add(function() {
                    c.buyIt()
                });
                return c
            }
            return n(e, t), e.prototype.watchAdToGetIt = function() {
                o.default.Instance.showRewarded(o.AD_PLACEMENT.CHARACTER_UNLOCK, this.unlockedWithAd, this)
            }, e.prototype.unlockedWithAd = function() {
                SKINS[this.skinID].locked = !1, o.default.Instance.saveData(), this.playIt()
            }, e.prototype.playIt = function() {
                ACTIVE_SKIN = this.skinID, this.hanger.setSkin(ACTIVE_SKIN), o.default.Instance.saveData(), this.skinsScreen && (this.skinsScreen.visible = !1)
            }, e.prototype.buyIt = function() {
                o.default.Instance.statsCoins - SKINS[this.skinID].coins > 0 ? (o.default.Instance.statsCoins = o.default.Instance.statsCoins - SKINS[this.skinID].coins, SKINS[this.skinID].locked = !1, o.default.Instance.saveData(), this.playIt()) : (a.default.Instance.showMessage(), a.default.Instance.fx(FxEvent.NOT_ENOUGH), this.game.camera.shake(.01, 75))
            }, e
        }(Phaser.Group);
    e.default = l
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.ScrollerEventDispatcher = e.BasicSwiper = e.DirectionalScroller = e.WheelScroller = e.SwipeCarousel = e.ListViewCore = e.ListView = e.Scroller = void 0;
    var s = u(i(12)),
        n = u(i(19)),
        r = u(i(20)),
        o = u(i(103)),
        a = u(i(104)),
        h = u(i(21)),
        l = u(i(105)),
        c = u(i(106));

    function u(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    var d = {
        Scroller: s.default,
        ListView: n.default,
        ListViewCore: r.default,
        SwipeCarousel: o.default,
        WheelScroller: a.default,
        DirectionalScroller: h.default,
        BasicSwiper: l.default,
        ScrollerEventDispatcher: c.default
    };
    e.Scroller = s.default, e.ListView = n.default, e.ListViewCore = r.default, e.SwipeCarousel = o.default, e.WheelScroller = a.default, e.DirectionalScroller = h.default, e.BasicSwiper = l.default, e.ScrollerEventDispatcher = c.default, window.PhaserListView = d, e.default = d
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s, n = i(19),
        r = (s = n) && s.__esModule ? s : {
            default: s
        };
    var o = {
            direction: "x",
            autocull: !0,
            momentum: !1,
            bouncing: !0,
            snapping: !0,
            overflow: 100,
            padding: 10,
            swipeEnabled: !0,
            offset: {
                x: 100
            }
        },
        a = function(t) {
            function e(t, i, s) {
                var n = arguments.length <= 3 || void 0 === arguments[3] ? {} : arguments[3];
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, e);
                var r = function(t, e) {
                    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !e || "object" != typeof e && "function" != typeof e ? t : e
                }(this, Object.getPrototypeOf(e).call(this, t, i, s, Object.assign({}, o, n)));
                return r.scroller.options.snapStep = s.width + r.o.padding, r
            }
            return function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }(e, r.default), e
        }();
    e.default = a
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var s = e[i];
                    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(t, s.key, s)
                }
            }
            return function(e, i, s) {
                return i && t(e.prototype, i), s && t(e, s), e
            }
        }(),
        n = function t(e, i, s) {
            null === e && (e = Function.prototype);
            var n = Object.getOwnPropertyDescriptor(e, i);
            if (void 0 === n) {
                var r = Object.getPrototypeOf(e);
                return null === r ? void 0 : t(r, i, s)
            }
            if ("value" in n) return n.value;
            var o = n.get;
            return void 0 !== o ? o.call(s) : void 0
        },
        r = (o(i(8)), o(i(12)));

    function o(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    var a = Phaser.Math,
        h = a.radToDeg,
        l = a.degToRad,
        c = new Phaser.Point,
        u = {
            direction: "angle",
            infinite: !1,
            speedLimit: 1.5
        },
        d = function(t) {
            function e(t, i) {
                var s = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2];
                return function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, e),
                    function(t, e) {
                        if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return !e || "object" != typeof e && "function" != typeof e ? t : e
                    }(this, Object.getPrototypeOf(e).call(this, t, i, {
                        angle: i.width / 2
                    }, Object.assign({}, u, s)))
            }
            return function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }(e, r.default), s(e, [{
                key: "handleDown",
                value: function(t, i) {
                    this.enabled && (this.centerPoint = this.clickObject.toGlobal(new Phaser.Point(0, 0)), c.set(i.x, i.y), this.old = this.down = Phaser.Math.normalizeAngle(Phaser.Math.angleBetweenPoints(c, this.centerPoint)), this.fullDiff = 0, n(Object.getPrototypeOf(e.prototype), "handleDown", this).call(this, t, i))
                }
            }, {
                key: "handleMove",
                value: function(t, e, i) {
                    if (this.enabled) {
                        this.isScrolling = !0, c.set(e, i);
                        var s = Phaser.Math.normalizeAngle(Phaser.Math.angleBetweenPoints(c, this.centerPoint)),
                            n = 0,
                            r = this.old - s;
                        if (this.diff = h(r), this.diff > 180 ? n = 1 : this.diff < -180 && (n = -1), 0 != n) r -= n * l(360), this.diff = h(r);
                        this.diff = this._requestDiff(this.diff, this.target, this.min, this.max, this.o.overflow), this.fullDiff -= this.diff, this.target -= this.diff, this.o.infinite && (this.target = this._wrapTarget(this.target, this.min, this.max)), this.old = s, this.o.time.move = this.game.time.time;
                        var o = this.clickObject.width,
                            a = Math.PI * o * (this.diff / 360);
                        this.acc = Math.min(Math.abs(a / 30), this.o.maxAcceleration), this.scrollObject[this.o.direction] = this.target, this.handleUpdate(), this.o.emitMoving && this.events.onInputMove.dispatch({
                            pointer: t,
                            x: e,
                            y: i
                        })
                    }
                }
            }, {
                key: "handleUp",
                value: function(t, i) {
                    c.set(i.x, i.y), this.current = Phaser.Math.normalizeAngle(Phaser.Math.angleBetweenPoints(c, this.centerPoint)), n(Object.getPrototypeOf(e.prototype), "handleUp", this).call(this, t, i)
                }
            }, {
                key: "_wrapTarget",
                value: function(t, e, i) {
                    return t > i ? t = e + (t - i) : t < e && (t = i - (e - t)), t
                }
            }]), e
        }();
    e.default = d
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s, n = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var s = e[i];
                    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(t, s.key, s)
                }
            }
            return function(e, i, s) {
                return i && t(e.prototype, i), s && t(e, s), e
            }
        }(),
        r = i(8),
        o = (s = r) && s.__esModule ? s : {
            default: s
        };
    var a = new Phaser.Point,
        h = {
            from: 0,
            to: 200,
            direction: "y",
            snapStep: 10,
            duration: 1,
            time: {},
            swipeThreshold: 5,
            swipeTimeThreshold: 250,
            addListeners: !0
        },
        l = function() {
            function t(e, i) {
                var s = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2];
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.game = e, this.clickObject = i, this.o = this.options = Object.assign({}, h, s), this._updateMinMax(), this.addListeners(), this.scrollObject = {}, this.scrollObject[this.o.direction] = this.o.from, this.tweenScroll = this.game.add.tween(this.scrollObject).to({}, 0, Phaser.Easing.Quartic.Out), this.tweenScroll.onUpdateCallback(this.handleUpdate, this), this.tweenScroll.onComplete.add(this.handleComplete, this)
            }
            return n(t, [{
                key: "addListeners",
                value: function() {
                    this.events = {
                        onUpdate: new Phaser.Signal,
                        onInputUp: new Phaser.Signal,
                        onInputDown: new Phaser.Signal,
                        onInputMove: new Phaser.Signal,
                        onComplete: new Phaser.Signal,
                        onSwipe: new Phaser.Signal
                    }, this.enable(), this.o.addListeners && (this.clickObject.inputEnabled = !0, this.clickObject.events.onInputDown.add(this.handleDown, this), this.clickObject.events.onInputUp.add(this.handleUp, this))
                }
            }, {
                key: "removeListeners",
                value: function() {
                    this.o.addListeners && (this.clickObject.events.onInputDown.remove(this.handleDown, this), this.clickObject.events.onInputUp.remove(this.handleUp, this));
                    for (var t in this.events) this.events.hasOwnProperty(t) && this.events[t].removeAll()
                }
            }, {
                key: "destroy",
                value: function() {
                    this.removeListeners()
                }
            }, {
                key: "enable",
                value: function() {
                    this.enabled = !0
                }
            }, {
                key: "disable",
                value: function() {
                    this.enabled = !1
                }
            }, {
                key: "isTweening",
                value: function() {
                    return this.tweenScroll.isRunning
                }
            }, {
                key: "handleDown",
                value: function(t, e) {
                    this.enabled ? (this.clickBlocked = !1, this.isDown = !0, this.old = this.down = e[this.o.direction], this.target = 0, this.o.time.down = e.timeDown, this.o.addListeners && this.game.input.addMoveCallback(this.handleMove, this), this.tweenScroll.stop(), this.tweenScroll.pendingDelete = !1, this.events.onInputDown.dispatch(t, e)) : this.clickBlocked = !0
                }
            }, {
                key: "handleMove",
                value: function(t, e, i) {
                    this.enabled && (a.set(e, i), this.diff = this.old - a[this.o.direction], this.target -= this.diff, this.old = a[this.o.direction], this.o.time.move = this.game.time.time, this.scrollObject[this.o.direction] = this.target, this.handleUpdate(), this.o.emitMoving && this.events.onInputMove.dispatch(t, e, i))
                }
            }, {
                key: "handleUp",
                value: function(t, e) {
                    if (this.enabled && !this.clickBlocked) {
                        this.isDown = !1, this.o.addListeners && this.game.input.deleteMoveCallback(this.handleMove, this), this.o.time.up = e.timeUp;
                        var i = {
                            duration: this.o.duration,
                            target: this.target
                        };
                        this._addSwiping(i, e), this._addSnapping(i), this.tweenTo(i.duration, i.target), this.events.onInputUp.dispatch(t, e)
                    }
                }
            }, {
                key: "_addSwiping",
                value: function(t, e) {
                    var i = Math.abs(this.down - this.old);
                    if (this.o.time.up - this.o.time.down < this.o.swipeTimeThreshold && i > this.o.swipeThreshold) {
                        var s = e[this.o.direction] < this.down ? "forward" : "backward";
                        "forward" == s ? t.target -= this.o.snapStep / 2 : t.target += this.o.snapStep / 2, this.events.onSwipe.dispatch(s)
                    }
                    return t
                }
            }, {
                key: "_addSnapping",
                value: function(t) {
                    return t.target = o.default.nearestMultiple(t.target, this.o.snapStep), t
                }
            }, {
                key: "tweenTo",
                value: function(t, e) {
                    var i = {};
                    i[this.o.direction] = e, this.tweenScroll.onUpdateCallback(this.handleUpdate, this), this.tweenScroll.onComplete.add(this.handleComplete, this), this.tweenScroll.updateTweenData("vEnd", i, -1), this.tweenScroll.updateTweenData("duration", 1e3 * t, -1), this.tweenScroll.updateTweenData("percent ", 0, -1), this.tweenScroll.start()
                }
            }, {
                key: "handleUpdate",
                value: function() {
                    this.events.onUpdate.dispatch(o.default.scaleBetween(-1, 1, o.default.percentageBetween2(this.scrollObject[this.o.direction], -this.length, this.length)))
                }
            }, {
                key: "handleComplete",
                value: function() {
                    this.o.multiplier = 1, this.events.onComplete.dispatch()
                }
            }, {
                key: "_updateMinMax",
                value: function() {
                    this.min = Math.min(this.o.from, this.o.to), this.max = Math.max(this.o.from, this.o.to), this.length = Math.abs(this.max - this.min), this.o.snapStep = this.length
                }
            }]), t
        }();
    e.default = l
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var s, n = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var s = e[i];
                    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(t, s.key, s)
                }
            }
            return function(e, i, s) {
                return i && t(e.prototype, i), s && t(e, s), e
            }
        }(),
        r = i(9),
        o = i(18);
    var a = {
            direction: "auto",
            autoDetectThreshold: ((s = o) && s.__esModule ? s : {
                default: s
            }).default.AUTO_DETECT_THRESHOLD
        },
        h = function() {
            function t(e, i) {
                var s = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2];
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.game = e, this.clickObject = i, this.clickables = [], this.o = this.options = Object.assign({}, a, s), this.addListeners()
            }
            return n(t, [{
                key: "addListeners",
                value: function() {
                    this.events = {
                        onInputUp: new Phaser.Signal,
                        onInputDown: new Phaser.Signal,
                        onInputMove: new Phaser.Signal,
                        onDirectionSet: new Phaser.Signal
                    }, this.clickObject.inputEnabled = !0, this.enable(), this.clickObject.events.onInputDown.add(this.handleDown, this), this.clickObject.events.onInputUp.add(this.handleUp, this)
                }
            }, {
                key: "removeListeners",
                value: function() {
                    this.clickObject.events.onInputDown.remove(this.handleDown, this), this.clickObject.events.onInputUp.remove(this.handleUp, this);
                    for (var t in this.events) this.events.hasOwnProperty(t) && this.events[t].removeAll()
                }
            }, {
                key: "destroy",
                value: function() {
                    this.removeListeners()
                }
            }, {
                key: "enable",
                value: function() {
                    this.enabled = !0
                }
            }, {
                key: "disable",
                value: function() {
                    this.enabled = !1
                }
            }, {
                key: "setDirection",
                value: function(t) {
                    this.direction = t, this.events.onDirectionSet.dispatch(t)
                }
            }, {
                key: "registerClickables",
                value: function(t) {
                    this.clickables = t
                }
            }, {
                key: "dispatchClicks",
                value: function(t, e, i) {
                    var s = (0, r.dispatchClicks)(t, e, i);
                    return "onInputDown" == i && (this.currentDown = s), s
                }
            }, {
                key: "handleDown",
                value: function(t, e) {
                    var i = this;
                    this.enabled ? (this.clickBlocked = !1, "auto" == this.o.direction ? (this.direction = null, this.old = null) : (this.setDirection(this.o.direction), this.old = this.down = e[this.direction]), this.game.input.addMoveCallback(this.handleMove, this), this.dispatchClicks(e, this.clickables, "onInputDown"), this.events.onInputDown.dispatch(t, e, function(t, s) {
                        return i.dispatchClicks(e, t, "onInputDown")
                    })) : this.clickBlocked = !0
                }
            }, {
                key: "handleMove",
                value: function(t, e, i) {
                    if (this.enabled) {
                        if (!this.direction && "auto" == this.o.direction) {
                            var s = Math.abs(t.positionDown.x - e),
                                n = Math.abs(t.positionDown.y - i);
                            if (!(s > this.o.autoDetectThreshold || n > this.o.autoDetectThreshold)) return;
                            this._cancelCurrentDown(t);
                            var r = s > n ? "x" : "y";
                            this.setDirection(r)
                        }
                        this.events.onInputMove.dispatch(t, e, i)
                    }
                }
            }, {
                key: "handleUp",
                value: function(t, e) {
                    var i = this;
                    this.enabled && !this.clickBlocked && (this.game.input.deleteMoveCallback(this.handleMove, this), this.dispatchClicks(e, this.clickables, "onInputUp"), this.events.onInputUp.dispatch(t, e, function(t, s) {
                        return i.dispatchClicks(e, t, "onInputUp")
                    }), this.currentDown = null)
                }
            }, {
                key: "_cancelCurrentDown",
                value: function(t) {
                    this.currentDown && this.currentDown.events && this.currentDown.events.onInputUp && this.currentDown.events.onInputUp.dispatch(this.currentDown, t, !1), this.currentDown = null
                }
            }]), t
        }();
    e.default = h
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(3),
        a = i(6),
        h = i(4),
        l = function(t) {
            function e(e, i, s, n, a, l) {
                void 0 === i && (i = r.Atlases.SpritesheetsMain.Frames.BtnUpgradeBoost), void 0 === s && (s = null), void 0 === n && (n = o.AD_PLACEMENT.UPGRADE_BOOST), void 0 === a && (a = "Boost"), void 0 === l && (l = "btn_boost");
                var c = t.call(this, e) || this;
                return c.prices = [25, 50, 100, 150, 300, 400, 500, 600, 700, 800, 900, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3], c.price = 25, c.level = 1, c.onUpgradeCallBack = s, c.adplacement = n, c.analyticsId = a, c.localeId = l, c.back = c.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), i), c.back.anchor.set(.5), c.add(c.back), c.titleText = h.default.Instance.getBitmapText(c.localeId, 36, 176), c.titleText.anchor.set(.5, .5), c.titleText.x = 0, c.titleText.y = -58, c.add(c.titleText), c.lvlText = h.default.Instance.getBitmapText("lbl_level_upgrade", 30, 70), c.lvlText.tint = Colors.dark, c.lvlText.x = -14, c.lvlText.y = c.top + 80, c.add(c.lvlText), c.priceText = c.game.make.bitmapText(18, c.top + 160, Fonts.bitmapMain, "1000", 41), c.priceText.tint = Colors.white, c.priceText.text.length < 3 && (c.priceText.x = 15), c.priceText.anchor.set(.5), c.add(c.priceText), c.rewardedButton = c.game.make.sprite(0, 50, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnUpgradeRewarded), c.rewardedButton.anchor.set(.5), c.add(c.rewardedButton), c.rewardedText = h.default.Instance.getBitmapText("btn_free", 38, 95), c.rewardedText.anchor.set(.5), c.rewardedText.x = c.rewardedButton.x + 23, c.rewardedText.y = c.rewardedButton.y - 2, c.add(c.rewardedText), c.back.inputEnabled = !0, c.back.events.onInputDown.add(c.onUpgrade, c), c
            }
            return n(e, t), e.prototype.onUpgrade = function() {
                this.maxButton && 1 == this.maxButton.visible ? (a.default.Instance.fx(FxEvent.NOT_ENOUGH), this.game.camera.shake(.01, 75)) : 1 == this.rewardedButton.visible ? (o.default.Instance.showRewarded(this.adplacement, this.onUpgradeCallBack, this), o.default.Instance.analyticsEvent("UI:LevelUp:" + this.analyticsId + ":Level" + (this.level - 1))) : this.price <= o.default.Instance.statsCoins ? (o.default.Instance.statsCoins = o.default.Instance.statsCoins - this.price, o.default.Instance.analyticsEvent("UI:LevelUp:" + this.analyticsId + ":Level" + (this.level - 1)), this.onUpgradeCallBack()) : (a.default.Instance.showMessage("NOT ENOUGH!"), a.default.Instance.fx(FxEvent.NOT_ENOUGH), this.game.camera.shake(.01, 75), this.updateState(this.level))
            }, e.prototype.updateState = function(t) {
                var e = this;
                t <= 0 && (t = 1), t >= this.prices.length && (t = this.prices.length, this.maxButton || (this.maxButton = this.game.make.sprite(0, 50, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnUpgradeMax), this.maxButton.anchor.set(.5), this.add(this.maxButton)), this.maxButton.visible = !0), this.level = t, this.price = this.prices[t - 1], this.lvlText.text = h.default.Instance.getText("lbl_level_upgrade") + t, this.priceText.text = "" + this.price, this.rewardedButton.visible = !1, (o.default.Instance.statsCoins < this.price || this.level % 3 == 0) && (o.default.Instance.isRewardedPreloaded() ? this.rewardedButton.visible = !0 : (this.rewardedButton.visible = !1, this.checkAgainTimer = setTimeout(function() {
                    e.updateState(e.level)
                }, 5e3))), this.priceText.text.length < 3 && (this.priceText.x = 15), this.rewardedText.visible = this.rewardedButton.visible
            }, e.prototype.update = function() {}, e.prototype.destroy = function() {
                this.checkAgainTimer && clearTimeout(this.checkAgainTimer), t.prototype.destroy.call(this)
            }, e
        }(Phaser.Group);
    e.default = l
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(3),
        a = i(6),
        h = i(3),
        l = i(4),
        c = function(t) {
            function e(i, s, n, r, o, a, h, l) {
                void 0 === r && (r = 0), void 0 === o && (o = null), void 0 === a && (a = !1), void 0 === h && (h = null), void 0 === l && (l = 12);
                var c = t.call(this, i) || this;
                return c.created = !1, c.coinsTaken = 0, c.screenTop = 0, c.screenBottom = 0, c.watchedRewarded = !1, c.isHighscore = !1, c.score = 0, c.shouldRestart = !1, c.onOk = s, c.onShareButton = n, c.callBacksContext = o, c.coinsTaken = r, c.score = l, c.fixedToCamera = !0, c.cameraOffset.x = c.game.width / 2, c.cameraOffset.y = c.game.height / 2, c.top = i.height / 2, c.bottom = -i.height / 2, c.isHighscore = a, c.chooseAsync = h, e.GAME_OVER_COUNT += 1, e.WATCHED_INTERSTITIAL = !1, c.create(), c
            }
            return n(e, t), e.prototype.create = function() {
                var t = this;
                if (!0 !== this.created) {
                    this.back = this.createRect(this.game.width + 100, this.game.height + 100, 0), this.back.alpha = .3, this.addChild(this.back), this.gameOverText = l.default.Instance.getBitmapText("lbl_game_over", 105, this.game.width - 50), this.gameOverText.anchor.setTo(.5, .5), this.gameOverText.y = -140, this.addChild(this.gameOverText), this.okBtn = new Phaser.Group(this.game);
                    var e = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnRestart);
                    this.addChild(this.okBtn), e.anchor.set(.5), this.okBtn.y = 100, this.okBtn.addChild(e), e.inputEnabled = !0, e.events.onInputDown.add(function() {
                        o.default.Instance.showInterstitial(h.AD_PLACEMENT.INTERSTITIAL, t.onOk, t.callBacksContext)
                    });
                    var i = l.default.Instance.getBitmapText("btn_restart", 58, 250);
                    i.anchor.set(.5), i.x = 37, this.okBtn.add(i)
                }
            }, e.prototype.doubleUp = function() {
                var t = this;
                this.doubleUpButton.visible = !1, o.default.Instance.statsCoins = o.default.Instance.statsCoins + this.coinsTaken, this.watchedRewarded = !0, o.default.Instance.saveData(), this.coinResultText.text = "YOU GOT " + this.coinsTaken + "+" + this.coinsTaken, this.coinResultIcon.x = this.coinResultIcon.x + 45, setTimeout(function() {
                    a.default.Instance.showMessage("+" + t.coinsTaken + "!", 120)
                }, 1e3)
            }, e.prototype.createRect = function(t, e, i) {
                var s = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Rect);
                return s.width = t, s.height = e, s.anchor.set(.5), s.tint = i, s
            }, e.GAME_OVER_COUNT = 0, e.WATCHED_INTERSTITIAL = !1, e
        }(Phaser.Group);
    e.default = c
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(3),
        a = i(6),
        h = i(110),
        l = i(4),
        c = function(t) {
            function e(e, i, s, n, r, o, a) {
                void 0 === s && (s = 0), void 0 === n && (n = null), void 0 === a && (a = !0);
                var h = t.call(this, e) || this;
                return h.created = !1, h.coinsTaken = 0, h.screenTop = 0, h.screenBottom = 0, h.watchedRewarded = !1, h.isHighscore = !1, h.claimedDouble = !1, h.score = 0, h.shouldRestart = !1, h.onOk = i, h.callBacksContext = n, h.coinsTaken = s, h.fixedToCamera = !0, h.cameraOffset.x = h.game.width / 2, h.cameraOffset.y = h.game.height / 2, h.top = e.height / 2, h.bottom = -e.height / 2, h.confetti = r, h.scoreText = o, h.claimedDouble = !1, h.skinToUnlockKey = null, h.showBest = a, h.create(), h
            }
            return n(e, t), e.prototype.create = function() {
                var t = this;
                if (!0 !== this.created) {
                    if (this.back = this.createRect(this.game.width + 100, this.game.height + 100, 0), this.back.alpha = .3, this.add(this.back), this.clearedRect = this.createRect(this.game.width + 100, 150, 4045466), this.clearedRect.anchor.setTo(.5, .5), this.add(this.clearedRect), this.clearedText = l.default.Instance.getBitmapText("lbl_level_cleared", 80, this.game.width - 40), this.clearedText.anchor.setTo(.5, .5), this.clearedText.y = -this.game.height / 2 + 120 + 2 * SAFE_TOP, this.add(this.clearedText), this.clearedRect.y = this.clearedText.y + 5, this.showBest) {
                        var e = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Newbest);
                        this.add(e), e.anchor.set(.5), e.scale.set(.8), e.y = this.clearedRect.y + 260 + 3 * SAFE_TOP, e.x = this.game.width / 2 - 100;
                        for (var i = l.default.Instance.getText("lbl_new_best").split(/(\s+)/), s = 0, n = [], a = 1, c = 0; c < i.length; c++) {
                            var u = this.game.add.bitmapText(0, 0, Fonts.bitmapMain, i[c], 38);
                            u.tint = 16738151, u.anchor.set(.5, .5), u.x = e.x - 10 + 8 * c, u.y = e.y - 23 + 15 * c, u.angle = -20, u.width > s && (a = 120 / (s = u.width)), this.add(u), n.push(u)
                        }
                        if (s >= 110)
                            for (c = 0; c < n.length; c++) n[c].scale.set(a, a + .15 * a), 1 == n.length && (n[c].y = e.y, n[c].x = e.x + 2)
                    }
                    this.claimBtn = new Phaser.Group(this.game);
                    var d = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnClaim);
                    d.inputEnabled = !0, d.anchor.set(.5), this.claimBtn.add(d), this.claimBtn.y = 105;
                    var p = l.default.Instance.getBitmapText("btn_claim_x_amount", 56, 240, {
                        MULTIPLE: "2"
                    });
                    p.text = p.text.replace("X", "x"), p.anchor.set(.5), p.x = 38, p.y = 2, p.tint = 15248896, this.claimBtn.add(p), this.add(this.claimBtn), d.events.onInputDown.add(function() {
                        t.alpha > 0 && 1 == t.visible && t.claimBtn.alpha > 0 && (t.claimBtn.alpha = 0, o.default.Instance.showRewarded(o.AD_PLACEMENT.DOUBLE_UP, t.claimDoubleAndMoveOn, t))
                    }), this.claimBtn.scale.set(.95), TweenMax.to(this.claimBtn.scale, .48, {
                        x: 1.05,
                        y: 1.05,
                        yoyo: !0,
                        repeat: -1,
                        ease: Quart.easeInOut
                    }), this.claimText = this.game.add.bitmapText(0, this.claimBtn.y + 115, Fonts.bitmapMain, l.default.Instance.getText("lbl_no_thanks"), 48), this.claimText.anchor.setTo(.5, .5), this.claimText.inputEnabled = !0, this.claimText.events.onInputDown.add(function() {
                        console.log("CLICK???"), t.claimText.alpha = 0, o.default.Instance.showInterstitial(o.AD_PLACEMENT.INTERSTITIAL, t.claimAndMoveOn, t)
                    }), this.add(this.claimText);
                    var f;
                    this.starburst = this.game.make.sprite(-80, -120, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Starburst), this.starburst.alpha = .5, this.starburst.anchor.set(.5, .5), this.starburst.blendMode = PIXI.blendModes.ADD, this.add(this.starburst), this.coinResultIcon = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Coin), this.add(this.coinResultIcon), this.coinResultIcon.x = -80, this.coinResultIcon.anchor.set(.5), this.coinResultIcon.scale.set(1.2), this.coinResultIcon.y = -120, this.collectedText = this.game.add.bitmapText(0, this.claimBtn.y + 120, Fonts.bitmapMain, l.default.Instance.getText("lbl_collected"), 65), this.collectedText.tint = 16710968, this.collectedText.anchor.setTo(.5, .5), this.collectedText.y = -40, this.add(this.collectedText);
                    var g = 0;
                    for (var m in SKINS) SKINS[m].score && (SCORE < SKINS[m].score ? f || (f = m) : g = SKINS[m].score);
                    var y = !1;
                    if (f) {
                        var v = SKINS[f];
                        this.unlockProgress = new h.default(this.game, f, g, v.score, SCORE, this.coinsTaken), this.unlockProgress.scale.set(.75), this.unlockProgress.x = 0, this.unlockProgress.y = this.clearedRect.y + 80, this.add(this.unlockProgress), this.unlockProgress.visible = !0, this.unlockProgress.startAnimation(), SCORE + this.coinsTaken >= v.score && (this.skinToUnlockKey = f, y = !0, setTimeout(function() {
                            t.getSkin(f)
                        }, 3e3), this.unlockProgress.visible = !0, this.unlockProgress.startAnimation())
                    }
                    y && (this.claimBtn.alpha = 0, this.claimText.alpha = 0), SCORE += this.coinsTaken
                }
            }, e.prototype.rewardDone = function() {
                this.claimBtn.alpha = 1, this.claimText.alpha = 1, this.scoreText.visible = !0, this.clearedText.text = l.default.Instance.getText("lbl_level_cleared"), this.unlockChest && (this.unlockChest.visible = !1), this.unlockProgress && (this.unlockProgress.visible = !0, this.unlockProgress.startAnimation()), this.confetti && this.confetti.shoot(this.game.width / 2, this.game.height / 2 + 200, 40)
            }, e.prototype.getSkin = function(t) {
                var e = this;
                this.claimSkinBack = this.createBackRect(), this.claimSkinBack.y = -100, this.claimSkinBtn = new Phaser.Group(this.game);
                var i = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnClaimChest);
                i.anchor.set(.5, .5), i.inputEnabled = !0, this.claimSkinBtn.y = this.claimSkinBack.y + this.claimSkinBack.height / 2 + 75, this.claimSkinBtn.add(i);
                var s = l.default.Instance.getBitmapText("btn_claim", 60, 220);
                s.anchor.set(.5), s.x = 38, s.y = 2, this.claimSkinBtn.add(s), this.scoreText.visible = !1, this.unlockProgress.visible = !1, this.claimSkinBtn.scale.set(.95), TweenMax.to(this.claimSkinBtn.scale, .48, {
                    x: 1.05,
                    y: 1.05,
                    yoyo: !0,
                    repeat: -1,
                    ease: Quart.easeInOut
                }), this.claimSkinNoThanks = this.game.add.bitmapText(0, this.claimSkinBtn.y + 110, Fonts.bitmapMain, l.default.Instance.getText("lbl_lose_it"), 50), this.claimSkinNoThanks.anchor.setTo(.5, .5), this.claimSkinNoThanks.inputEnabled = !0, TweenMax.from(this.claimSkinNoThanks, .5, {
                    alpha: 0,
                    delay: 1.5
                }), this.claimSkinNoThanks.events.onInputDown.add(this.onNoThanks, this), this.claimSkinHead = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), t + "_menu.png"), this.claimSkinHead.anchor.set(.5), this.claimSkinHead.y = this.claimSkinBack.y, this.claimSkinHead.scale.set(1.75), TweenMax.from(this.claimSkinHead.scale, 1, {
                    delay: Math.random(),
                    x: .1,
                    y: .1,
                    ease: Back.easeOut,
                    onComplete: function() {
                        TweenMax.to(e.claimSkinHead, .12, {
                            ease: Sine.easeInOut,
                            angle: 2,
                            yoyo: !0,
                            repeat: -1
                        }), TweenMax.to(e.claimSkinHead.scale, .5, {
                            ease: Strong.easeInOut,
                            x: 2,
                            y: 2,
                            yoyo: !0,
                            repeat: -1
                        })
                    }
                }), this.claimSkinStarBurst = this.game.make.sprite(0, this.claimSkinBack.y, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Starburst), this.claimSkinStarBurst.alpha = .5, this.claimSkinStarBurst.scale.set(1.5, 1.5), this.claimSkinStarBurst.anchor.set(.5, .5), this.claimSkinStarBurst.blendMode = PIXI.blendModes.ADD, this.add(this.claimSkinBack), this.add(this.claimSkinStarBurst), this.add(this.claimSkinHead), this.add(this.claimSkinBtn), this.add(this.claimSkinNoThanks), i.events.onInputDown.add(function() {
                    e.claimSkinBtn.alpha > 0 && o.default.Instance.showRewarded(o.AD_PLACEMENT.PROGRESSION_CHARACTER, e.unlockCharacter, e)
                })
            }, e.prototype.onNoThanks = function() {
                var t = this;
                this.claimSkinBack && (this.claimSkinBack.visible = !1), this.claimSkinBtn && (this.claimSkinBtn.visible = !1, TweenMax.killTweensOf(this.claimSkinBtn)), this.claimSkinStarBurst && (this.claimSkinStarBurst.visible = !1), this.claimSkinHead && (this.claimSkinHead.visible = !1, TweenMax.killTweensOf(this.claimSkinHead), TweenMax.killTweensOf(this.claimSkinHead.scale)), this.claimSkinNoThanks && (this.claimSkinNoThanks.visible = !1), setTimeout(function() {
                    t.claimBtn.alpha = 1, t.claimText.alpha = 1, t.scoreText && (t.scoreText.visible = !0)
                }, 250)
            }, e.prototype.unlockCharacter = function() {
                null != this.skinToUnlockKey && (SKINS[this.skinToUnlockKey].locked = !1, ACTIVE_SKIN = this.skinToUnlockKey);
                this.claimSkinBack && (this.claimSkinBack.visible = !1), this.claimSkinBtn && (this.claimSkinBtn.visible = !1, TweenMax.killTweensOf(this.claimSkinBtn)), this.claimSkinStarBurst && (this.claimSkinStarBurst.visible = !1), this.claimSkinHead && (this.claimSkinHead.visible = !1, TweenMax.killTweensOf(this.claimSkinHead), TweenMax.killTweensOf(this.claimSkinHead.scale)), this.claimSkinNoThanks && (this.claimSkinNoThanks.visible = !1), this.claimBtn.alpha = 1, this.claimText.alpha = 1, this.confetti && this.confetti.shoot(this.game.width / 2, this.game.height / 2 + 200, 40), this.scoreText && (this.scoreText.visible = !0)
            }, e.prototype.claimAndMoveOn = function() {
                o.default.Instance.statsCoins = o.default.Instance.statsCoins + this.coinsTaken, o.default.Instance.saveData(), this.onOk.call(this.callBacksContext)
            }, e.prototype.claimDoubleAndMoveOn = function() {
                this.claimedDouble = !0, o.default.Instance.statsCoins = o.default.Instance.statsCoins + 2 * this.coinsTaken, o.default.Instance.saveData(), this.onOk.call(this.callBacksContext)
            }, e.prototype.update = function() {
                this.starburst.angle = this.starburst.angle + .08 * this.game.time.elapsed, this.claimSkinStarBurst && (this.claimSkinStarBurst.angle = this.claimSkinStarBurst.angle + .08 * this.game.time.elapsed), this.unlockChest && this.unlockChest.update()
            }, e.prototype.doubleUp = function() {
                var t = this;
                this.doubleUpButton.visible = !1, o.default.Instance.statsCoins = o.default.Instance.statsCoins + this.coinsTaken, this.watchedRewarded = !0, o.default.Instance.saveData(), this.coinResultText.text = "YOU GOT " + this.coinsTaken + "+" + this.coinsTaken, this.coinResultIcon.x = this.coinResultIcon.x + 45, setTimeout(function() {
                    a.default.Instance.showMessage("+" + t.coinsTaken + "!", 120)
                }, 1e3)
            }, e.prototype.destroy = function() {
                TweenMax.to(this.claimBtn.scale)
            }, e.prototype.createRect = function(t, e, i) {
                var s = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Rect);
                return s.width = t, s.height = e, s.anchor.set(.5), s.tint = i, s
            }, e.prototype.createBackRect = function() {
                var t = new Phaser.Group(this.game),
                    e = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.RectMiddle);
                e.height = 300, e.y = -e.height / 2, e.x = -e.width / 2;
                var i = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.RectTop);
                i.width = e.width, i.y = -e.height / 2 - i.height, i.x = -e.width / 2;
                var s = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.RectTop);
                return s.width = e.width, s.y = e.height / 2 + i.height, s.x = -e.width / 2, s.scale.y = -1, t.add(e), t.add(i), t.add(s), t
            }, e
        }(Phaser.Group);
    e.default = c
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = function(t) {
        function e(e, i, s, n, o, a) {
            var h = t.call(this, e) || this;
            h.s = 0, h.min = 0, h.max = 0, h.toAdd = 0, h.current = 0;
            h.back = h.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Progressbar), h.back.x = 0, h.back.anchor.x = .5, h.add(h.back), h.progressRect = h.createRect(520, 55, 8438831), h.add(h.progressRect), h.progressRect.anchor.x = 0, h.progressRect.x = -h.back.width / 2, h.progressRect.y = 67, h.progressRect.scale.x = .01;
            var l = i;
            l += "_menu", h.skinHead = h.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), l + ".png"), h.skinHead.anchor.set(.5), h.skinHead.x = h.back.width / 2 - 62, h.skinHead.y = 58, h.skinHead.scale.set(1), h.text = h.game.make.bitmapText(0, 0, Fonts.bitmapMain, "50/250", 50), h.text.tint = Colors.dark, h.text.anchor.set(.5, .5), h.text.x = -30, h.text.y = 65, h.add(h.back), h.add(h.progressRect), h.add(h.skinHead), h.add(h.text), o < s && (s = o);
            var c = o - s,
                u = n - s;
            return h.text.text = c + "/" + u, h.val = c, h.totalVal = u, h.min = s, h.max = n, h.current = o, h.s = c, h.toAdd = a, h.updateProgress(c / u), h
        }
        return n(e, t), e.prototype.startAnimation = function() {
            var t = this;
            TweenMax.to(this, 3, {
                val: this.s + this.toAdd,
                delay: 1,
                onUpdate: function() {
                    t.updateValues()
                }
            })
        }, e.prototype.updateValues = function() {
            this.text.text = Math.floor(this.val) + "/" + this.totalVal, this.updateProgress(this.val / this.totalVal)
        }, e.prototype.updateProgress = function(t) {
            t > 1 && (t = 1), t < 0 && (t = 0), this.progressRect.width = 430 * t
        }, e.prototype.createCircle = function(t, e) {
            var i = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Circle);
            return i.width = t, i.height = t, i.anchor.set(.5), i.tint = e, i
        }, e.prototype.createRect = function(t, e, i) {
            var s = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Rect);
            return s.width = t, s.height = e, s.anchor.set(.5), s.tint = i, s
        }, e.prototype.createRoundedRect = function(t, e, i) {
            var s = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.RoundedScore);
            return s.width = t, s.height = e, s.anchor.set(.5), s.tint = i, s
        }, e
    }(Phaser.Group);
    e.default = o
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(3),
        a = i(6),
        h = i(4),
        l = function(t) {
            function e(e, i, s, n) {
                var o = t.call(this, e) || this;
                o.chestsUnlocked = 0, o.chances = 3, o.bestPrizeWon = !1, o.coinValuesToWin = [10, 15, 20, 5], o.fixedToCamera = !0, o.cameraOffset.x = e.width / 2, o.cameraOffset.y = e.height / 2, TweenMax.from(o.cameraOffset, .5, {
                    y: -e.height,
                    ease: Expo.easeOut
                }), o.onDone = i, o.callBacksContext = s, o.confetti = n, o.backback = o.createRect(o.game.width + 100, o.game.height + 100, 6095014), o.add(o.backback), o.backback.inputEnabled = !0, o.back = o.createBackRect(), o.back.y = -60, o.starBurst = o.game.make.sprite(0, o.back.y, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Starburst), o.starBurst.alpha = .85, o.starBurst.scale.set(3.5, 3.5), o.starBurst.anchor.set(.5, .5), o.starBurst.blendMode = PIXI.blendModes.ADD, o.chestsUnlocked = 0, o.chances = 3, o.add(o.starBurst), o.add(o.back);
                var a = o.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.CharSelectButton);
                a.anchor.set(.5), a.y = o.back.y - 360, o.add(a);
                var l = o.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BestPrizeBanner);
                l.scale.set(.75), l.anchor.set(.5), l.y = a.y + 80;
                var c = h.default.Instance.getBitmapText("lbl_best_prize", 65, 180);
                c.anchor.set(.5), c.y = l.y - 2, o.addChests(), o.addKeys();
                var u = [];
                for (var d in SKINS) SKINS[d].score || SKINS[d].locked && "skin_hanger_big" != d && u.push(d);
                if (u.length > 0) {
                    o.skinId = u[Math.floor(u.length * Math.random())];
                    var p = o.skinId;
                    p += "_menu";
                    var f = o.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), p + ".png");
                    f.anchor.set(.5), f.y = a.y, o.add(f)
                } else {
                    o.skinId, (y = o.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Coin)).anchor.set(.5), y.scale.set(.85), y.y = a.y + 20, o.add(y);
                    var g = o.game.add.bitmapText(20, 10, Fonts.bitmapMain, "20", 45);
                    g.anchor.set(.5), g.x = y.x - 3, g.y = a.y - 30, o.add(g)
                }
                o.add(l), o.add(c), o.coinParticles = [];
                for (var m = 0; m < 15; m++) {
                    var y;
                    (y = o.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Coin)).anchor.set(.5), y.scale.set(.5), o.coinParticles.push(y), y.visible = !1, o.add(y)
                }
                return o
            }
            return n(e, t), e.prototype.animateCoins = function(t, e, i) {
                a.default.Instance.fx(FxEvent.COINS_REWARD);
                Math.min(i, this.coinParticles.length);
                for (var s = 0; s < this.coinParticles.length; s++) {
                    var n = this.coinParticles[s];
                    TweenMax.killTweensOf(n), n.x = t - 10 + 5 * Math.random() - 2, n.y = e - 30 + 4 * Math.random() - 2, n.visible = !1, n.alpha = 1, TweenMax.to(n, .3 + .1 * Math.random(), {
                        onComplete: function(t) {
                            t.visible = !1
                        },
                        onCompleteParams: [n],
                        ease: Linear.easeNone,
                        delay: .3 * Math.random(),
                        x: this.game.width / 2 + SAFE_SIDE - 30,
                        y: -this.game.height / 2 + 30,
                        onStart: function(t) {
                            t.visible = !0
                        },
                        onStartParams: [n]
                    })
                }
            }, e.prototype.addKeys = function() {
                this.keys = new Phaser.Group(this.game), this.keys.y = 270, this.key1 = new Phaser.Sprite(this.game, 0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Key), this.key1.anchor.set(.5), this.key1.scale.set(.75), this.key1.x = -100, this.key1.y = 0, this.key2 = new Phaser.Sprite(this.game, 0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Key), this.key2.anchor.set(.5), this.key2.scale.set(.75), this.key2.y = 0, this.key3 = new Phaser.Sprite(this.game, 0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Key), this.key3.anchor.set(.5), this.key3.scale.set(.75), this.key3.x = 100, this.key3.y = 0, this.keys.add(this.key1), this.keys.add(this.key2), this.keys.add(this.key3), this.add(this.keys), this.lblChoose = h.default.Instance.getBitmapText("lbl_open_chests", 55, this.game.width - 100), this.lblChoose.anchor.set(.5), this.add(this.lblChoose), this.lblChoose.y = this.keys.y + 120
            }, e.prototype.addChests = function() {
                for (var t = this, e = 0, i = 0, s = function() {
                        var s = n.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.ChestPanel);
                        s.anchor.set(.5), s.scale.set(.77), s.x = 142 * e - 142, s.y = 139 * i - 144;
                        var o = n.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.ChestSmall);
                        o.anchor.set(.5), o.scale.set(.77), o.x = s.x, o.y = s.y, o.inputEnabled = !0, o.events.onInputDown.add(function(e) {
                            t.choose(e)
                        }), TweenMax.from(o.scale, 1, {
                            delay: Math.random(),
                            x: .75,
                            y: .75,
                            ease: Back.easeOut,
                            onComplete: function() {
                                TweenMax.to(o, .12, {
                                    ease: Sine.easeInOut,
                                    angle: 2,
                                    yoyo: !0,
                                    repeat: -1
                                }), TweenMax.to(o.scale, .5, {
                                    ease: Strong.easeInOut,
                                    x: .81,
                                    y: .81,
                                    yoyo: !0,
                                    repeat: -1
                                })
                            }
                        }), ++e > 2 && (e = 0, i++), n.back.add(s), n.back.add(o)
                    }, n = this, o = 0; o < 9; o++) s()
            }, e.prototype.choose = function(t) {
                if (this.chances < 1) return a.default.Instance.fx(FxEvent.NOT_ENOUGH), void this.game.camera.shake(.01, 75);
                t.visible = !1, TweenMax.killTweensOf(t), TweenMax.killTweensOf(t.scale), this.chestsUnlocked++, this.chances--, 0 == this.chances && (this.lblChoose.visible = !1, this.keys.visible = !1, this.chestsUnlocked < 9 ? this.showMoreKeysBtn() : this.showOkBtn()), this.givePrize(t.x, t.y), t.visible = !1, this.chances < 3 && (this.key3.tint = 6710886), this.chances < 2 && (this.key2.tint = 6710886), this.chances < 1 && (this.key1.tint = 6710886)
            }, e.prototype.showOkBtn = function() {
                var t = this;
                this.okBtn = new Phaser.Group(this.game);
                var e = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnClaimChar);
                e.anchor.set(.5, .5), e.inputEnabled = !0, this.okBtn.add(e);
                var i = h.default.Instance.getBitmapText("lbl_ok", 60, 220);
                i.anchor.set(.5), i.x = 0, i.y = 2, this.okBtn.add(i), e.events.onInputDown.add(function() {
                    t.onDone.call(t.callBacksContext)
                }), this.okBtn.y = this.back.y + 350, this.addChild(this.okBtn)
            }, e.prototype.showKeys = function() {
                this.keys.visible = !0, this.lblChoose.visible = !0, this.key1.tint = this.key2.tint = this.key3.tint = 16777215, this.btnMoreKeys && (this.btnMoreKeys.visible = !1, this.noThanks.visible = !1)
            }, e.prototype.showMoreKeysBtn = function() {
                var t = this;
                if (!this.btnMoreKeys) {
                    this.btnMoreKeys = new Phaser.Group(this.game);
                    var e = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnGetKeys);
                    e.anchor.set(.5), e.inputEnabled = !0, e.events.onInputDown.add(function() {
                        o.default.Instance.showRewarded(o.AD_PLACEMENT.GET_MORE_KEYS, function() {
                            t.chances = 3, t.showKeys()
                        }, t)
                    }), this.btnMoreKeys.add(e);
                    var i = h.default.Instance.getBitmapText("btn_get_3_keys", 79, 260);
                    i.anchor.set(.5), i.x = 0, i.y = 2, this.btnMoreKeys.add(i), this.noThanks = this.game.add.bitmapText(0, 300, Fonts.bitmapMain, h.default.Instance.getText("lbl_no_thanks"), 46), this.noThanks.anchor.setTo(.5, .5), this.noThanks.inputEnabled = !0, this.noThanks.events.onInputDown.add(function() {
                        t.onDone.call(t.callBacksContext)
                    }), this.btnMoreKeys.y = this.back.y + 350, this.noThanks.y = this.btnMoreKeys.y + 140, this.add(this.btnMoreKeys), this.add(this.noThanks), this.btnMoreKeys.scale.set(.95), TweenMax.to(this.btnMoreKeys.scale, .48, {
                        x: 1.05,
                        y: 1.05,
                        yoyo: !0,
                        repeat: -1,
                        ease: Quart.easeInOut
                    })
                }
                this.btnMoreKeys.visible = !0, this.noThanks.visible = !0, TweenMax.killTweensOf(this.noThanks), this.noThanks.alpha = 1, TweenMax.from(this.noThanks, .6, {
                    alpha: 0,
                    delay: 1
                })
            }, e.prototype.givePrize = function(t, e) {
                var i = 1 - this.chestsUnlocked / 3 / 10;
                if (this.chestsUnlocked > 3 && (i = 1 - this.chestsUnlocked / 2 / 10), this.chestsUnlocked > 6 && (i = 1 - this.chestsUnlocked / 10), this.chestsUnlocked > 8 && (i = -1), 0 == this.bestPrizeWon && Math.random() > i && null != this.skinId) {
                    this.bestPrizeWon = !0;
                    var s = this.skinId;
                    s += "_menu";
                    var n = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), s + ".png");
                    n.anchor.set(.5), n.y = e - 64, n.x = t, this.add(n), SKINS[this.skinId].locked = !1, ACTIVE_SKIN = this.skinId, o.default.Instance.saveData(), this.showBestPrize()
                } else {
                    var a = this.coinValuesToWin[Math.floor(this.coinValuesToWin.length * Math.random())],
                        h = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Coin);
                    h.anchor.set(.5), h.scale.set(.85), h.x = t, h.y = e - 40, this.add(h);
                    var l = this.game.add.bitmapText(20, 10, Fonts.bitmapMain, "" + a, 45);
                    l.anchor.set(.5), l.x = t - 3, l.y = h.y - 55, this.add(l), this.animateCoins(t, e, a), o.default.Instance.statsCoins += a, o.default.Instance.saveData()
                }
            }, e.prototype.showBestPrize = function() {
                var t = this;
                if (this.skinId && !this.bestPrizeGroup) {
                    a.default.Instance.fx(FxEvent.COIN), this.bestPrizeGroup = new Phaser.Group(this.game), this.add(this.bestPrizeGroup);
                    var e = this.createRect(this.game.width + 100, this.game.height + 100, 0);
                    e.alpha = .7, this.bestPrizeGroup.add(e), e.inputEnabled = !0;
                    var i = this.createBackRect(300);
                    this.bestPrizeGroup.add(i), i.y = -60, this.starBurst2 = this.game.make.sprite(0, this.back.y, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Starburst), this.starBurst2.alpha = .7, this.starBurst2.scale.set(1.8, 1.8), this.starBurst2.anchor.set(.5, .5), this.starBurst2.blendMode = PIXI.blendModes.ADD, this.bestPrizeGroup.add(this.starBurst2);
                    var s = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), this.skinId + "_menu.png");
                    s.anchor.set(.5), s.y = this.back.y, s.scale.set(1.75), this.bestPrizeGroup.add(s);
                    var n = new Phaser.Group(this.game),
                        o = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnClaimChar);
                    o.anchor.set(.5, .5), o.inputEnabled = !0, n.add(o);
                    var l = h.default.Instance.getBitmapText("lbl_ok", 60, 220);
                    l.anchor.set(.5), l.x = 0, l.y = 2, n.add(l), o.events.onInputDown.add(function() {
                        t.bestPrizeGroup.visible = !1
                    }), n.y = this.back.y + 350, this.bestPrizeGroup.addChild(n), TweenMax.from(this.bestPrizeGroup, .15, {
                        alpha: 0,
                        delay: .25
                    }), this.confetti.shoot(this.game.width / 2, this.game.height / 2, 30)
                }
            }, e.prototype.update = function() {
                this.starBurst.angle = this.starBurst.angle + .03 * this.game.time.elapsed, this.starBurst2 && (this.starBurst2.angle = this.starBurst2.angle + .06 * this.game.time.elapsed)
            }, e.prototype.destroy = function() {
                t.prototype.destroy.call(this), this.btnMoreKeys && TweenMax.killTweensOf(this.btnMoreKeys)
            }, e.prototype.createBackRect = function(t) {
                void 0 === t && (t = 400);
                var e = new Phaser.Group(this.game),
                    i = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.RectMiddle);
                i.height = t, i.y = -i.height / 2, i.x = -i.width / 2;
                var s = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.RectTop);
                s.width = i.width, s.y = -i.height / 2 - s.height, s.x = -i.width / 2;
                var n = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.RectTop);
                return n.width = i.width, n.y = i.height / 2 + s.height, n.x = -i.width / 2, n.scale.y = -1, e.add(i), e.add(s), e.add(n), e
            }, e.prototype.createRect = function(t, e, i) {
                var s = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Rect);
                return s.width = t, s.height = e, s.anchor.set(.5), s.tint = i, s
            }, e
        }(Phaser.Group);
    e.default = l
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(113),
        o = function(t) {
            function e(e) {
                var i = t.call(this, e) || this;
                i.index = 0, i.fixedToCamera = !0, i.colors = [11035901, 2739711, 7929668, 16740749, 16645994], i.all = new Array;
                for (var s = 0; s < 30; s++) {
                    var n = new r.default(i.game, i.colors[Math.floor(Math.random() * i.colors.length)]);
                    i.all.push(n), i.add(n)
                }
                return i
            }
            return n(e, t), e.prototype.shoot = function(t, e, i, s, n) {
                var r = this;
                void 0 === s && (s = 20), void 0 === n && (n = 0), this.game.world.bringToTop(this), i > this.all.length && (i = this.all.length);
                for (var o = 0; o < i; o++) setTimeout(function() {
                    r.all[r.index++ % r.all.length].shoot(t, e, n + 6 * Math.random() - 3, -8 * Math.random() - 4)
                }, o * s * (.3 * Math.random()))
            }, e
        }(Phaser.Group);
    e.default = o
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0),
        o = function(t) {
            function e(e, i) {
                var s = t.call(this, e, 0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Rect16) || this;
                return s.gravity = .2, s.fX = 0, s.fY = 0, s.velY = 0, s.velX = 0, s.damping = .2, s.active = !1, s.random = 0, s.width = 40, s.height = 20, s.tint = i, s.anchor.set(.5), s.visible = !1, s.random = 100 * Math.random() - 50, s
            }
            return n(e, t), e.prototype.shoot = function(t, e, i, s) {
                this.active = !0, this.visible = !0, this.velX = 0, this.velY = 0, this.x = t, this.y = e, this.fX = i, this.fY = s;
                var n = .5 * Math.random() + .75;
                this.scale.x = 2 * n, this.scale.y = 1 * n, TweenLite.from(this.scale, .6, {
                    x: 0,
                    y: 0
                })
            }, e.prototype.update = function() {
                this.active && (this.velY = this.velY + this.gravity + this.fY, this.velX = this.velX + this.fX, this.y = this.y + Math.min(this.velY, 4 + this.scale.x), this.x = this.x + this.velX, this.fX <= .1 && (this.x += 2 * Math.sin(.01 * (this.y + this.random))), this.fY = this.fY * this.damping, this.fX = this.fX * this.damping, this.velX > 0 && (this.velX = this.velX - .012), this.angle += this.velX + 1.4 * Math.min(this.velY, 10), this.y > this.game.height + 20 && (this.active = !1, this.visible = !1))
            }, e
        }(Phaser.Sprite);
    e.default = o
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(115),
        o = i(6),
        a = function(t) {
            function e(e, i, s, n) {
                void 0 === i && (i = 50), void 0 === s && (s = 1.5), void 0 === n && (n = 1);
                var o = t.call(this, e) || this;
                o.index = 0, o.lastCount = 0, o.yForce = 0, o.coinScale = .8, o.fixedToCamera = !0, o.yForce = s, o.coinScale = n, o.colors = [11035901, 2739711, 7929668, 16740749, 16645994], o.all = new Array;
                for (var a = 0; a < i; a++) {
                    var h = new r.default(o.game, o.colors[Math.floor(Math.random() * o.colors.length)]);
                    o.all.push(h), o.add(h)
                }
                return o
            }
            return n(e, t), e.prototype.shoot = function(t, e, i, s, n, r) {
                var a = this;
                void 0 === s && (s = 20), void 0 === n && (n = 0), void 0 === r && (r = !1), this.game.world.bringToTop(this), i > this.all.length && (i = this.all.length);
                for (var h = 0; h < i; h++) {
                    var l = h * s * (.3 * Math.random());
                    r && (l = 0), setTimeout(function() {
                        a.all[a.index++ % a.all.length].shoot(t, e, n + 4 * Math.random() - 2, (-8 * Math.random() - 8) * a.yForce)
                    }, l)
                }
                o.default.Instance.fx(FxEvent.CONFETTI), this.lastCount = i
            }, e.prototype.claimAll = function() {
                var t;
                o.default.Instance.fx(FxEvent.COINS_REWARD);
                for (var e = 0; e < this.lastCount; e++) {
                    (t = this.all[e]).active = !1;
                    var i = .4 * Math.random() + .5;
                    t.scale.set((.2 * Math.random() + 1) * this.coinScale), t.visible = !0, (t.x < 0 || t.y < 100) && this.game && this.game.height && (t.y = this.game.height + 20, t.x = this.game.width * Math.random()), this.game && this.game.width && (TweenMax.to(t, i, {
                        x: this.game.width - 24 - SAFE_SIDE,
                        y: 20 + SAFE_TOP,
                        delay: e / 150 + .1 * Math.random()
                    }), TweenMax.to(t.scale, i + .1, {
                        x: 0,
                        y: 0,
                        delay: e / 150 + .15
                    }))
                }
            }, e
        }(Phaser.Group);
    e.default = a
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0),
        o = function(t) {
            function e(e, i) {
                var s = t.call(this, e, 0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Coin) || this;
                return s.gravity = .4, s.fX = 0, s.fY = 0, s.velY = 0, s.velX = 0, s.damping = .2, s.active = !1, s.random = 0, s.ground = 150, s.width = 30, s.height = 30, s.anchor.set(.5), s.visible = !1, s.random = 100 * Math.random() - 50, s
            }
            return n(e, t), e.prototype.shoot = function(t, e, i, s) {
                this.active = !0, this.visible = !0, this.velX = 0, this.velY = 0, this.x = t, this.y = e, this.fX = i, this.fY = s;
                var n = .2 * Math.random() + .8;
                this.scale.x = n, this.scale.y = n, TweenLite.from(this.scale, .6, {
                    x: 0,
                    y: 0
                })
            }, e.prototype.update = function() {
                this.active && (this.velY = this.velY + this.gravity + this.fY, this.velX = this.velX + this.fX, this.y = this.y + Math.min(this.velY, 6 + this.scale.x), this.x = this.x + this.velX, this.fX <= .1 && (this.x += .2 * Math.sin(.01 * (this.y + this.random))), this.fY = this.fY * this.damping, this.fX = this.fX * this.damping, this.velX > 0 && (this.velX = this.velX - .012), this.angle += this.velX + 1.2 * Math.min(this.velY, 10), this.y > this.game.height + 20 && (this.active = !1, this.visible = !1, this.x = Math.random() * this.game.width, this.scale.set(.2 * Math.random() + 1)))
            }, e
        }(Phaser.Sprite);
    e.default = o
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = function(t) {
        function e(e, i, s) {
            void 0 === i && (i = 4), void 0 === s && (s = 1);
            var n = t.call(this, e) || this;
            n.comboScore = 0, n.keyCount = 0, n.color1 = Colors.white, n.color2 = Colors.dark, n.fixedToCamera = !0, n.cameraOffset.x = e.width / 2, n.cameraOffset.y = 92 + SAFE_TOP, n.first = !0;
            var o = n.createCircle(64, n.color2);
            o.x = -190;
            var a = n.createCircle(64, n.color1);
            a.x = 190, n.circle2 = a;
            var h = n.createRect(380, 18, n.color1);
            n.add(h), n.progressRect = n.createRect(348, 18, n.color2), n.progressRect.anchor.x = 0, n.progressRect.x = -174, n.progressRect.scale.x = .01, n.add(n.progressRect), n.scoreParts = new Array;
            for (var l = 0; l < i; l++) {
                var c = n.createRoundedRect(7, 40, n.color1);
                c.x = 360 / i * (l + 1) - 180, n.add(c), n.scoreParts.push(c), c.x > 170 && (c.visible = !1)
            }
            var u = n.game.make.bitmapText(0, 0, Fonts.bitmapMain, "" + s, 55);
            u.anchor.set(.5, .5), u.x = -193, u.y = -2;
            var d = n.game.make.bitmapText(0, 0, Fonts.bitmapMain, "" + (s + 1), 55);
            return d.anchor.set(.5, .5), d.x = 187, d.y = -2, d.tint = Colors.dark, n.text2 = d, 2 === d.text.length && (d.fontSize = 45), 2 === u.text.length && (u.fontSize = 45), 3 === d.text.length && (d.fontSize = 35), 3 === u.text.length && (u.fontSize = 35), n.add(o), n.add(a), n.add(u), n.add(d), n.keys = new Phaser.Group(n.game), n.keys.y = 44, n.key1 = new Phaser.Sprite(n.game, n.w / 2 - 100, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Key), n.key1.anchor.set(.5), n.key1.scale.set(.32), n.key1.x = -60, n.key1.y = 0, n.key2 = new Phaser.Sprite(n.game, n.w / 2, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Key), n.key2.anchor.set(.5), n.key2.scale.set(.32), n.key2.y = 0, n.key3 = new Phaser.Sprite(n.game, n.w / 2 + 100, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Key), n.key3.anchor.set(.5), n.key3.scale.set(.32), n.key3.x = 60, n.key3.y = 0, n.key1.tint = n.key2.tint = n.key3.tint = 6710886, n.keys.add(n.key1), n.keys.add(n.key2), n.keys.add(n.key3), n.keys.alpha = 0, n.add(n.keys), n.keyCount = KEYS, n.updateKeys(), n
        }
        return n(e, t), e.prototype.showKeys = function() {
            TweenMax.to(this.keys, .5, {
                alpha: 1,
                repeat: 1,
                yoyo: !0,
                repeatDelay: 4
            })
        }, e.prototype.updateComboScore = function(t) {}, e.prototype.updateProgress = function(t) {
            this.progressRect.width = 348 * t, t >= 1 && (this.circle2.tint = this.color2), KEYS != this.keyCount && this.updateKeys()
        }, e.prototype.updateKeys = function() {
            this.keyCount = KEYS, this.key1.tint = this.key2.tint = this.key3.tint = 4473924, this.keyCount > 0 && (this.key1.tint = 16777215), this.keyCount > 1 && (this.key2.tint = 16777215), this.keyCount > 2 && (this.key3.tint = 16777215), 1 != this.first && (TweenMax.killTweensOf(this.keys), this.keys.alpha = 0, TweenMax.to(this.keys, .25, {
                alpha: 1,
                yoyo: !0,
                repeat: 1,
                repeatDelay: 1
            })), this.first = !1
        }, e.prototype.updateScorePart = function(t) {
            for (var e = 0; e < this.scoreParts.length; e++) t > (e + 1) / this.scoreParts.length && (this.scoreParts[e].tint = this.color2)
        }, e.prototype.createCircle = function(t, e) {
            var i = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Circle);
            return i.width = t, i.height = t, i.anchor.set(.5), i.tint = e, i
        }, e.prototype.createRect = function(t, e, i) {
            var s = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Rect);
            return s.width = t, s.height = e, s.anchor.set(.5), s.tint = i, s
        }, e.prototype.createRoundedRect = function(t, e, i) {
            var s = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.RoundedScore);
            return s.width = t, s.height = e, s.anchor.set(.5), s.tint = i, s
        }, e
    }(Phaser.Group);
    e.default = o
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = function(t) {
        function e(e) {
            var i = t.call(this, e) || this;
            return i.soundOn = i.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.SoundOn), i.soundOff = i.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.SoundOff), i.addChild(i.soundOn), i.addChild(i.soundOff), i.soundOff.visible = !1, i.soundOn.inputEnabled = !0, i.soundOn.events.onInputDown.add(i.onSound, i), i.soundOff.inputEnabled = !0, i.soundOff.events.onInputDown.add(i.onSound, i), i.soundOff.visible = i.game.sound.mute, i.soundOn.visible = !i.game.sound.mute, i
        }
        return n(e, t), e.prototype.onSound = function() {
            this.game.sound.mute = !this.game.sound.mute, this.soundOff.visible = this.game.sound.mute, this.soundOn.visible = !this.game.sound.mute
        }, e
    }(Phaser.Group);
    e.default = o
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(3),
        a = i(3),
        h = i(4),
        l = function(t) {
            function e(e, i, s, n) {
                var r = t.call(this, e) || this;
                return r.created = !1, r.counter = 5, r.fixedToCamera = !0, r.cameraOffset.x = e.width / 2, r.cameraOffset.y = e.height / 2, r.callBacksContext = n, r.onRevive = i, r.onGameOver = s, r.create(), r
            }
            return n(e, t), e.prototype.create = function() {
                var t = this;
                if (!0 !== this.created) {
                    this.back = this.createRect(this.game.width + 100, this.game.height + 100, 0), this.back.alpha = .3, this.addChild(this.back), this.title = this.game.add.bitmapText(0, -400, Fonts.bitmapMain, "CONTINUE?", 200), this.title.anchor.setTo(.5, .5), this.title.visible = !1, this.addChild(this.title), this.countText = this.game.add.bitmapText(0, -120, Fonts.bitmapMain, "5", 180), this.countText.anchor.setTo(.5, .5), this.addChild(this.countText), this.okButton = new Phaser.Group(this.game);
                    var e = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnContinue);
                    e.anchor.set(.5), this.okButton.y = 150, e.inputEnabled = !0, e.events.onInputDown.add(function() {
                        t.stop(), t.countText.visible = !1, o.default.Instance.showRewarded(a.AD_PLACEMENT.CONTINUE, t.onRevive, t.callBacksContext)
                    }), this.okButton.scale.set(.95), this.addChild(this.okButton), this.okButton.add(e), TweenMax.to(this.okButton.scale, .48, {
                        x: 1.05,
                        y: 1.05,
                        yoyo: !0,
                        repeat: -1,
                        ease: Quart.easeInOut
                    }), this.okButtonText = h.default.Instance.getBitmapText("btn_continue", 56, 260), this.okButtonText.anchor.set(.5), this.okButtonText.x = 38, this.okButton.add(this.okButtonText), this.noThanks = this.game.add.bitmapText(0, this.okButton.y + 120, Fonts.bitmapMain, h.default.Instance.getText("lbl_no_thanks"), 45), this.noThanks.anchor.setTo(.5, .5), this.noThanks.inputEnabled = !0, this.noThanks.events.onInputDown.add(this.onGameOver, this.callBacksContext), this.addChild(this.noThanks), this.countInterval = setInterval(function() {
                        t.counter < 2 && (t.onGameOver(), clearInterval(t.countInterval)), t.countText.text = "" + --t.counter
                    }, 1e3), this.created = !0
                }
            }, e.prototype.stop = function() {
                this.countText.visible = !1, clearInterval(this.countInterval)
            }, e.prototype.destroy = function() {
                this.game.world.filters = null, TweenMax.killTweensOf(this.okButton.scale), clearInterval(this.countInterval), t.prototype.destroy.call(this)
            }, e.prototype.createRect = function(t, e, i) {
                var s = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Rect);
                return s.width = t, s.height = e, s.anchor.set(.5), s.tint = i, s
            }, e
        }(Phaser.Group);
    e.default = l
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = function(t) {
        function e(e) {
            var i = t.call(this, e) || this;
            return i.fixedToCamera = !0, i.cameraOffset.x = e.width / 2 + 142, i.cameraOffset.y = e.height / 2 + 400, i.alpha = 0, i.handhit = i.game.make.sprite(-142, -215, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.HandHit), i.handhit.anchor.set(.5, .5), i.add(i.handhit), i.hand = i.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Hand), i.hand.anchor.set(.8, 1), i.hand.angle = 20, i.add(i.hand), TweenMax.to(i.hand, .6, {
                angle: 0,
                yoyo: !0,
                repeat: -1,
                ease: Strong.easeInOut
            }), TweenMax.to(i, .2, {
                alpha: 1,
                delay: .5
            }), i
        }
        return n(e, t), e.prototype.update = function() {
            this.hand.angle < 10 ? this.handhit.visible = !0 : this.handhit.visible = !1
        }, e.prototype.destroy = function() {
            t.prototype.destroy.call(this), TweenMax.killTweensOf(this.hand), TweenMax.killTweensOf(this.handhit)
        }, e
    }(Phaser.Group);
    e.default = o
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), i(1);
    var r = i(0);
    i(2);
    var o = i(3),
        a = i(4),
        h = function(t) {
            function e(e, i, s, n, h) {
                var l = t.call(this, e) || this;
                l.skinId = "", l.coinWin = -1, l.fixedToCamera = !0, l.cameraOffset.x = e.width / 2, l.cameraOffset.y = e.height / 2, l.skinId = i, l.skinId.length < 4 && (l.coinWin = parseInt(l.skinId)), l.onDone = s, l.callBacksContext = n, l.confetti = h, l.backback = l.createRect(l.game.width + 100, l.game.height + 100, 0), l.backback.alpha = .3, l.add(l.backback), l.back = l.createBackRect(), l.back.y = -100, l.add(l.back), l.clearedRect = l.createRect(l.game.width + 100, 150, 4045466), l.clearedRect.anchor.setTo(.5, .5), l.add(l.clearedRect), l.clearedText = a.default.Instance.getBitmapText("lbl_your_reward", 80, l.game.width - 100), l.clearedText.anchor.setTo(.5, .5), l.clearedText.y = -l.game.height / 2 + 120 + 2 * SAFE_TOP, l.clearedRect.y = l.clearedText.y, l.add(l.clearedText), l.claimBtn = new Phaser.Group(l.game);
                var c = l.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnClaimChest);
                c.anchor.set(.5, .5), l.claimBtn.y = l.back.y + l.back.height / 2 + 75, c.inputEnabled = !0, c.events.onInputDown.add(function() {
                    o.default.Instance.showRewarded(o.AD_PLACEMENT.CLAIM_REWARD, l.adComplete, l)
                }), l.claimBtn.add(c);
                var u = a.default.Instance.getBitmapText("btn_claim", 56, 220);
                return u.anchor.set(.5), u.x = 38, u.y = 2, l.claimBtn.add(u), l.claimBtn.scale.set(.95), TweenMax.to(l.claimBtn.scale, .48, {
                    x: 1.05,
                    y: 1.05,
                    yoyo: !0,
                    repeat: -1,
                    ease: Quart.easeInOut
                }), -1 == l.coinWin ? (l.skinhead = l.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), l.skinId + "_menu.png"), l.skinhead.anchor.set(.5), l.skinhead.y = l.back.y, l.skinhead.visible = !1, l.skinhead.scale.set(1.75)) : (l.skinhead = l.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.CoinPile), l.skinhead.anchor.set(.5), l.skinhead.y = l.back.y - 40, l.skinhead.visible = !1, l.skinhead.scale.set(1), l.coinText = l.game.add.bitmapText(20, 10, Fonts.bitmapMain, l.coinWin.toString(), 90), l.coinText.anchor.set(.5), l.coinText.x = l.skinhead.x, l.coinText.y = l.skinhead.y + 150, l.coinText.visible = !1), l.chest = l.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Giftbox), l.chest.anchor.set(.5), l.chest.y = l.back.y, l.chest.inputEnabled = !0, l.chest.events.onInputDown.add(function() {
                    o.default.Instance.showRewarded(o.AD_PLACEMENT.CLAIM_REWARD, l.adComplete, l)
                }), l.starBurst = l.game.make.sprite(0, l.back.y, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Starburst), l.starBurst.alpha = .7, l.starBurst.scale.set(2.5, 2.5), l.starBurst.anchor.set(.5, .5), l.starBurst.blendMode = PIXI.blendModes.ADD, l.noThanks = l.game.add.bitmapText(0, l.claimBtn.y + 110, Fonts.bitmapMain, a.default.Instance.getText("lbl_no_thanks"), 46), l.noThanks.anchor.setTo(.5, .5), l.noThanks.inputEnabled = !0, TweenMax.from(l.noThanks, .5, {
                    alpha: 0,
                    delay: 1.5
                }), l.noThanks.events.onInputDown.add(l.onDone, l.callBacksContext), l.add(l.noThanks), l.add(l.back), l.add(l.starBurst), l.add(l.skinhead), l.coinText && l.add(l.coinText), l.add(l.claimBtn), l.add(l.chest), l.chest.angle = -2, TweenMax.from(l.starBurst.scale, 1, {
                    x: .1,
                    y: .1
                }), TweenMax.from(l.chest.scale, 1, {
                    x: .1,
                    y: .1,
                    ease: Back.easeOut,
                    onComplete: function() {
                        TweenMax.to(l.chest, .12, {
                            ease: Sine.easeInOut,
                            angle: 2,
                            yoyo: !0,
                            repeat: -1
                        }), TweenMax.to(l.chest.scale, .5, {
                            ease: Strong.easeInOut,
                            x: 1.1,
                            y: 1.1,
                            yoyo: !0,
                            repeat: -1
                        })
                    }
                }), l
            }
            return n(e, t), e.prototype.adComplete = function() {
                var t = this;
                this.chest.visible = !1, this.skinhead.visible = !0, this.coinText && (this.coinText.visible = !0), this.noThanks.visible = !1, -1 == this.coinWin ? (SKINS[this.skinId].locked = !1, ACTIVE_SKIN = this.skinId) : o.default.Instance.statsCoins += this.coinWin, TweenMax.to(this.starBurst.scale, .5, {
                    x: 1.5,
                    y: 1.5
                }), this.confetti && this.confetti.shoot(this.game.width / 2, this.game.height / 2, 30), this.claimBtn.visible = !1, this.claimAfterBtn = new Phaser.Group(this.game);
                var e = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.BtnClaimChar);
                e.anchor.set(.5, .5), this.claimAfterBtn.y = this.back.y + this.back.height / 2 + 75, e.inputEnabled = !0, this.claimAfterBtn.add(e);
                var i = a.default.Instance.getBitmapText("lbl_ok", 60, 220);
                i.anchor.set(.5), i.x = 0, i.y = 2, this.claimAfterBtn.add(i), e.events.onInputDown.add(function() {
                    t.onDone.call(t.callBacksContext)
                }), this.addChild(this.claimAfterBtn)
            }, e.prototype.update = function() {
                this.starBurst.angle = this.starBurst.angle + .06 * this.game.time.elapsed
            }, e.prototype.destroy = function() {
                t.prototype.destroy.call(this), TweenMax.killTweensOf(this.chest), TweenMax.killTweensOf(this.claimBtn.scale)
            }, e.prototype.createBackRect = function() {
                var t = new Phaser.Group(this.game),
                    e = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.RectMiddle);
                e.height = 300, e.y = -e.height / 2, e.x = -e.width / 2;
                var i = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.RectTop);
                i.width = e.width, i.y = -e.height / 2 - i.height, i.x = -e.width / 2;
                var s = this.game.make.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.RectTop);
                return s.width = e.width, s.y = e.height / 2 + i.height, s.x = -e.width / 2, s.scale.y = -1, t.add(e), t.add(i), t.add(s), t
            }, e.prototype.createRect = function(t, e, i) {
                var s = this.game.add.sprite(0, 0, r.Atlases.SpritesheetsMain.getName(), r.Atlases.SpritesheetsMain.Frames.Rect);
                return s.width = t, s.height = e, s.anchor.set(.5), s.tint = i, s
            }, e
        }(Phaser.Group);
    e.default = h
}, function(t, e, i) {
    "use strict";
    var s, n = this && this.__extends || (s = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        },
        function(t, e) {
            function i() {
                this.constructor = t
            }
            s(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        });
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = i(17),
        o = i(22),
        a = i(16),
        h = function(t) {
            function e() {
                var e = null !== t && t.apply(this, arguments) || this;
                return e.startX = 0, e.cameraStartX = 0, e
            }
            return n(e, t), e.prototype.create = function() {
                this.game.physics.startSystem(Phaser.Physics.BOX2D), this.game.physics.box2d.gravity.y = 600, this.game.physics.box2d.useElapsedTime = !1, this.game.world.setBounds(-200, 0, 3e6, this.game.world.bounds.height), this.back = new a.default(this.game, this.camera), this.game.add.existing(this.back);
                var t = new URL(window.location.href);
                t.searchParams.get("level") && (LEVEL_INDEX = parseInt(t.searchParams.get("level")));
                var e = COLOR_THEMES[(LEVEL_INDEX - 1) % COLOR_THEMES.length];
                GRADIENT_BACK = e.back, SHADOW_COLOR = e.shadow;
                var i = o.default.GenerateRandomLevelBasedOnIndex(LEVEL_INDEX);
                i.levelColor = e.ground, i.grassColor = e.grass, this.level = new r.default(this.game, i), this.level.blockCount = 5 * this.level.config.length, this.level.create(), this.level.scale.set(.7), this.level.y = 100, document.body.style.backgroundColor = "#999999", this.addHTMLUI()
            }, e.prototype.addHTMLUI = function() {
                var t = this,
                    e = document.createElement("div");
                e.style.width = "100%", e.style.height = "100%", e.style.position = "absolute", e.style.top = "0px", e.style.left = "0px", this.scrollTarget = e, document.body.appendChild(e);
                var i = document.createElement("div");
                i.style.position = "absolute", i.style.bottom = "0px", i.style.width = "100%", i.style.height = "130px", i.style.backgroundColor = "rgba(0, 0, 0, 0.5)", i.style.fontFamily = "arial", document.body.appendChild(i), this.div = i;
                var s = document.createElement("span");
                s.textContent = "Level " + LEVEL_INDEX, s.style.fontSize = "50pt", s.style.width = "100%", s.style.textAlign = "center", s.style.display = "block", i.appendChild(s);
                var n = document.createElement("button");
                n.textContent = "NEXT", n.style.fontSize = "30pt", n.style.right = "10px", n.style.position = "absolute", n.addEventListener("click", function(e) {
                    LEVEL_INDEX += 1, t.reload()
                }), i.appendChild(n);
                var r = document.createElement("button");
                r.textContent = "PREVIOUS", r.style.fontSize = "30pt", r.style.left = "10px", r.style.position = "absolute", r.addEventListener("click", function(e) {
                    LEVEL_INDEX -= 1, t.reload()
                }), i.appendChild(r), this.initDATGUI(), e.addEventListener("mousedown", function(e) {
                    t.isDown = !0, t.cameraStartX = t.game.camera.x, t.startX = e.pageX
                }), e.addEventListener("mouseleave", function() {
                    t.isDown = !1
                }), e.addEventListener("mouseup", function() {
                    t.isDown = !1
                }), e.addEventListener("mousemove", function(e) {
                    if (t.isDown) {
                        e.preventDefault();
                        var i = 3 * (e.pageX - t.startX);
                        t.game.camera.x = t.cameraStartX - i
                    }
                })
            }, e.prototype.refreshLevel = function() {
                var t = this.level;
                t.config;
                t.config.cacheRandomBlockPositions(), t.config.cacheEventPositions(), this.level = new r.default(this.game, t.config), this.level.blockCount = 5 * this.level.config.length, this.level.create(), this.level.scale.set(.7), this.level.y = 100, t.destroy()
            }, e.prototype.initDATGUI = function() {
                var t = this;
                if (dat || setTimeout(function() {
                        t.initDATGUI
                    }, 1e3), !window.datGUIINITED) {
                    window.datGUIINITED = !0;
                    var e = {
                            refresh: function() {
                                t.refreshLevel()
                            }
                        },
                        i = new dat.GUI;
                    i.add(this.level.config, "length", 0, 50), i.add(this.level.config, "tightness", 0, 1), i.add(this.level.config, "tightnessVariation", 0, 1), i.add(this.level.config, "holes", 0, 1), i.add(this.level.config, "islands", 0, 1);
                    var s = i.addFolder("autoEvents");
                    s.add(this.level.config, "autoEvents", 0, 1), s.add(this.level.config, "buzzSaw", 0, 1), s.add(this.level.config, "crateStack", 0, 1), s.add(this.level.config, "propeller", 0, 1), s.add(this.level.config, "spring", 0, 1), this.gui = i, i.add(e, "refresh"), document.body.appendChild(i.domElement.parentElement)
                }
            }, e.prototype.reload = function() {
                window.datGUIINITED = !1, this.level.destroy(), this.gui.destroy(), this.div.parentElement.removeChild(this.div), this.scrollTarget.parentElement.removeChild(this.scrollTarget), this.game.state.restart(!0, !1)
            }, e.prototype.preRender = function() {}, e
        }(Phaser.State);
    e.default = h
}]);